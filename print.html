<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Tangle Improvement Proposal (TIP) Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="tips/TIP-0001/tip-0001.html">TIP-1 TIP Process</a></li><li class="chapter-item expanded "><a href="tips/TIP-0002/tip-0002.html">TIP-2 White Flag Ordering</a></li><li class="chapter-item expanded "><a href="tips/TIP-0003/tip-0003.html">TIP-3 Uniform Random Tip Selection</a></li><li class="chapter-item expanded "><a href="tips/TIP-0004/tip-0004.html">TIP-4 Milestone Merkle Validation</a></li><li class="chapter-item expanded "><a href="tips/TIP-0005/tip-0005.html">TIP-5 Binary To Ternary Encoding</a></li><li class="chapter-item expanded "><a href="tips/TIP-0006/tip-0006.html">TIP-6 Tangle Message</a></li><li class="chapter-item expanded "><a href="tips/TIP-0007/tip-0007.html">TIP-7 Transaction Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0008/tip-0008.html">TIP-8 Milestone Payload</a></li><li class="chapter-item expanded "><a href="tips/TIP-0009/tip-0009.html">TIP-9 Local Snapshot File Format</a></li><li class="chapter-item expanded "><a href="tips/TIP-0010/tip-0010.html">TIP-10 Mnemonic Ternary Seed</a></li><li class="chapter-item expanded "><a href="tips/TIP-0011/tip-0011.html">TIP-11 Bech32 Address Format</a></li><li class="chapter-item expanded "><a href="tips/TIP-0012/tip-0012.html">TIP-12 Message PoW</a></li><li class="chapter-item expanded "><a href="tips/TIP-0013/tip-0013.html">TIP-13 REST API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0014/tip-0014.html">TIP-14 Ed25519 Validation</a></li><li class="chapter-item expanded "><a href="tips/TIP-0015/tip-0015.html">TIP-15 Dust Protection</a></li><li class="chapter-item expanded "><a href="tips/TIP-0016/tip-0016.html">TIP-16 Event API</a></li><li class="chapter-item expanded "><a href="tips/TIP-0017/tip-0017.html">TIP-17 Wotsicide</a></li><li class="chapter-item expanded "><a href="tips/TIP-0019/tip-0019.html">TIP-19 Dust Protection Based on Byte Costs (Storage Deposit)</a></li><li class="chapter-item expanded "><a href="tips/TIP-0031/tip-0031.html">TIP-31 Bech32 Address Format</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Tangle Improvement Proposal (TIP) Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tangle-improvement-proposal-tip-repository"><a class="header" href="#tangle-improvement-proposal-tip-repository">Tangle Improvement Proposal (TIP) Repository</a></h1>
<p>TIPs are improvement proposals for bettering the IOTA technology stack.</p>
<p>Building the IOTA ecosystem is a community effort, therefore we welcome anyone to propose, discuss and debate ideas that will later become formalized TIPs.</p>
<h2 id="propose-new-ideas"><a class="header" href="#propose-new-ideas">Propose new ideas</a></h2>
<p>Do you have an idea how to improve the IOTA technology stack?</p>
<ul>
<li>Head over to the <a href="https://github.com/iotaledger/tips/discussions">discussions</a> page to browse already submitted ideas or share yours!</li>
<li>Once your idea is discussed, you can submit a draft TIP (<a href="./tip-template.html">template here</a>) as a PR to the repository.</li>
<li>You will receive feedback from the TIP Editors and review from core devs.</li>
<li>Once accepted, your TIP is merged as Draft.</li>
<li>It is your responsibility to drive its implementation and to present a clear plan on how the new feature will be adopted by the network.</li>
<li>Once implementation is ready and testing yields satisfactory result, the TIP becomes Proposed.</li>
<li>Proposed TIPs that are supported by majority of the network become Active.</li>
</ul>
<p>You may find more information about the TIP Process in <a href="./tips/TIP-0001/tip-0001.html">TIP-1</a>.</p>
<h2 id="stardust-tips"><a class="header" href="#stardust-tips">Stardust TIPs</a></h2>
<p>Stardust is the next upgrade of the IOTA protocol that adds tokenization and smart contract chain support besides many
more improvements. Browse the <a href="introduction.html#list-of-tips">list of TIPs</a> below with the <em>Stardust</em> tag to learn more about what changes.</p>
<h2 id="list-of-tips"><a class="header" href="#list-of-tips">List of TIPs</a></h2>
<ul>
<li>Last updated: 2022-05-20</li>
<li>The <em>Status</em> of a TIP reflects its current state with respect to its progression to being supported on the IOTA mainnet.
<ul>
<li><code>Draft</code> TIPs are work in progress. They may or may not have a working implementation on a testnet.</li>
<li><code>Proposed</code> TIPs are demonstrated to have a working implementation. These TIPs are supported on Shimmer, the staging network of IOTA.</li>
<li><code>Active</code> TIPs are supported on the IOTA mainnet.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Title</th><th>Description</th><th>Type</th><th>Layer</th><th>Status</th><th>Initial Target</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tips/TIP-0001/tip-0001.html">TIP Process</a></td><td>Purpose and guidelines of the contribution framework</td><td>Process</td><td>-</td><td>Active</td><td>-</td></tr>
<tr><td>2</td><td><a href="tips/TIP-0002/tip-0002.html">White Flag Ordering</a></td><td>Mitigate conflict spamming by ignoring conflicts</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>3</td><td><a href="tips/TIP-0003/tip-0003.html">Uniform Random Tip Selection</a></td><td>Perform fast tip-selection to increase message throughput</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>4</td><td><a href="tips/TIP-0004/tip-0004.html">Milestone Merkle Validation</a></td><td>Add Merkle tree hash to milestone for local ledger state verification</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>5</td><td><a href="tips/TIP-0005/tip-0005.html">Binary To Ternary Encoding</a></td><td>Define the conversion between binary and ternary data</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>6</td><td><a href="tips/TIP-0006/tip-0006.html">Tangle Message</a></td><td>Generalization of the Tangle transaction concept</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>7</td><td><a href="tips/TIP-0007/tip-0007.html">Transaction Payload</a></td><td>UTXO-based transaction structure</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>8</td><td><a href="tips/TIP-0008/tip-0008.html">Milestone Payload</a></td><td>Coordinator issued milestone structure with Ed25519 authentication</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>9</td><td><a href="tips/TIP-0009/tip-0009.html">Local Snapshot File Format</a></td><td>File format to export/import ledger state</td><td>Standards</td><td>Interface</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>10</td><td><a href="tips/TIP-0010/tip-0010.html">Mnemonic Ternary Seed</a></td><td>Represent ternary seed as a mnemonic sentence</td><td>Standards</td><td>IRC</td><td>Obsolete</td><td>Legacy IOTA</td></tr>
<tr><td>11</td><td><a href="tips/TIP-0011/tip-0011.html">Bech32 Address Format</a></td><td>Extendable address format supporting various signature schemes and address types</td><td>Standards</td><td>Interface</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>12</td><td><a href="tips/TIP-0012/tip-0012.html">Message PoW</a></td><td>Define message proof-of-work as a means to rate-limit the network</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>13</td><td><a href="tips/TIP-0013/tip-0013.html">REST API</a></td><td>Node REST API routes and objects in OpenAPI Specification</td><td>Standards</td><td>Interface</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>14</td><td><a href="tips/TIP-0014/tip-0014.html">Ed25519 Validation</a></td><td>Adopt <a href="https://zips.z.cash/zip-0215">ZIP-215</a> to explicitly define Ed25519 validation criteria</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>15</td><td><a href="tips/TIP-0015/tip-0015.html">Dust Protection</a></td><td>Prevent bloating the ledger size with to dust outputs</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>16</td><td><a href="tips/TIP-0016/tip-0016.html">Event API</a></td><td>Node event API definitions in AsyncAPI Specification</td><td>Standards</td><td>Interface</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>17</td><td><a href="tips/TIP-0017/tip-0017.html">Wotsicide</a></td><td>Define migration from legacy WOTS addresses to post-Chrysalis Phase 2 network</td><td>Standards</td><td>Core</td><td>Active</td><td>Chrysalis</td></tr>
<tr><td>18</td><td><a href="https://github.com/iotaledger/tips/pull/38">Multi-Asset Ledger and ISC Support</a></td><td>Transform IOTA into a multi-asset ledger that supports running IOTA Smart Contracts</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>19</td><td><a href="https://github.com/iotaledger/tips/pull/39">Dust Protection Based on Byte Costs</a></td><td>Prevent bloating the ledger size with dust outputs</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>20</td><td><a href="https://github.com/iotaledger/tips/pull/40">Transaction Payload with New Output Types</a></td><td>UTXO-based transaction structure with TIP-18</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>21</td><td><a href="https://github.com/iotaledger/tips/pull/41">Serialization Primitives</a></td><td>Introduce primitives to describe the binary serialization of objects</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>22</td><td><a href="https://github.com/iotaledger/tips/pull/43">IOTA Protocol Parameters</a></td><td>Describes the global protocol parameters for the IOTA protocol</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>23</td><td><a href="https://github.com/iotaledger/tips/pull/54">Tagged Data Payload</a></td><td>Payload for arbitrary data</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>24</td><td><a href="https://github.com/iotaledger/tips/pull/55">Tangle Block</a></td><td>A new version of TIP-6 that renames messages to blocks and removes the Indexation Payload in favor of the Tagged Data Payload. Replaces TIP-6.</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>25</td><td><a href="https://github.com/iotaledger/tips/pull/57">Core REST API</a></td><td>Node Core REST API routes and objects in OpenAPI Specification. Replaces TIP-13.</td><td>Standards</td><td>Interface</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>26</td><td><a href="https://github.com/iotaledger/tips/pull/62">UTXO Indexer REST API</a></td><td>UTXO Indexer REST API routes and objects in OpenAPI Specification.</td><td>Standards</td><td>Interface</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>27</td><td><a href="https://github.com/iotaledger/tips/pull/65">IOTA NFT standards</a></td><td>Define NFT metadata standard, collection system and creator royalties</td><td>Standards</td><td>IRC</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>28</td><td><a href="https://github.com/iotaledger/tips/pull/66">Node Event API</a></td><td>Node event API definitions in AsyncAPI Specification. Replaces TIP-16.</td><td>Standards</td><td>Interface</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>29</td><td><a href="https://github.com/iotaledger/tips/pull/69">Milestone Payload</a></td><td>Milestone Payload with keys removed from essence. Replaces TIP-8.</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>30</td><td><a href="https://github.com/iotaledger/tips/pull/68">Native Token Metadata Standard</a></td><td>A JSON schema that describes token metadata format for native token foundries</td><td>Standards</td><td>IRC</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>31</td><td><a href="https://github.com/iotaledger/tips/pull/70">Bech32 Address Format for IOTA and Shimmer</a></td><td>Extendable address format supporting various signature schemes and address types. Replaces TIP-11.</td><td>Standards</td><td>Interface</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>32</td><td><a href="https://github.com/iotaledger/tips/pull/71">Shimmer Protocol Parameters</a></td><td>Describes the global protocol parameters for the Shimmer network</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>33</td><td><a href="https://github.com/iotaledger/tips/pull/72">Public Token Registry</a></td><td>Defines an open public registry for NFT collection ID and native tokens metadata</td><td>Standards</td><td>IRC</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>34</td><td><a href="https://github.com/iotaledger/tips/pull/74">Wotsicide (Stardust update)</a></td><td>Define migration from legacy W-OTS addresses to post-Chrysalis networks. Replaces TIP-17.</td><td>Standards</td><td>Core</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
<tr><td>35</td><td><a href="https://github.com/iotaledger/tips/pull/76">Local Snapshot File Format (Stardust Update)</a></td><td>File format to export/import ledger state. Replaces TIP-9.</td><td>Standards</td><td>Interface</td><td>Draft</td><td><strong>Stardust</strong></td></tr>
</tbody></table>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need help?</a></h2>
<p>If you want to get involved in the community, need help getting started, have any issues related to the repository or just want to discuss blockchain, distributed ledgers, and IoT with other people, feel free to join our <a href="https://discord.iota.org/">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 1
title: TIP Process
description:  Purpose and guidelines of the contribution framework
author: Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/discussions
status: Active
type: Process
created: 2021-12-15
</pre>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>A Tangle Improvement Proposal (TIP) is a design document providing information to the IOTA community, or describing a new feature for IOTA or its processes or environment. The TIP should provide a concise technical specification of the feature and a rationale for the feature.</p>
<p>TIPs are the primary mechanism for proposing new features and standards to the IOTA protocol and related applications, furthermore for collecting input from the wider community and documenting the design decisions that go into the IOTA technology.</p>
<p>TIPs are maintained as text files inside the repository, therefore the history and evolution of protocol features are transparent and well documented.</p>
<p>This TIP defines the TIP Process itself to establish a common way of working.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The motivation of this TIP is to create a public platform to discuss improvement ideas related to the IOTA technology and define an easy-to-follow process of contributing to their development and implementation.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="tip-types"><a class="header" href="#tip-types">TIP Types</a></h3>
<p>There are 3 types of TIPs:</p>
<ul>
<li>A <strong>Standards Track TIP</strong> describes any change that affects most or all IOTA node implementations, such as a change to the network protocol, a change in transaction validity rules, or any change or addition that affects the interoperability of applications using IOTA. Standards Track TIPs consist of two parts, a design document and a reference implementation. Standards Track TIPs can be broken down into layers:
<ul>
<li><strong>Core</strong>: includes improvements requiring a consensus fork (e.g. new transaction validation rules, change in protocol message layouts), as well as any change that concerns the protocol specification.</li>
<li><strong>Networking</strong>: includes improvements around the networking layer of the network, e.g. gossip protocol or autopeering.</li>
<li><strong>Interface</strong>: includes improvements around the client APIs of base layer nodes as well as around the interface definitions of IOTA Smart Contracts (ISC), such as contract schemas or ISC node APIs.</li>
<li><strong>IRC</strong>: includes improvements around application-level standards and conventions such as contract standards, token standards or metadata format standards.</li>
</ul>
</li>
<li>An <strong>Informational TIP</strong> describes an IOTA design issue, or provides general guidelines or information to the IOTA community, but does not propose a new feature. Informational TIPs do not necessarily represent an IOTA community consensus or recommendation, so users and implementors are free to ignore Informational TIPs or follow their advice.</li>
<li>A <strong>Process TIP</strong> describes a process surrounding IOTA, or proposes a change to (or an event in) a process. Process TIPs are like Standards Track TIPs but apply to areas other than the IOTA protocol itself. They may propose an implementation, but not to IOTA's codebase; they often require community consensus; unlike Informational TIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in IOTA development.</li>
</ul>
<p>It is highly recommended that a TIP outlines a single key proposal, idea or feature; the narrower the scope of the TIP is, the easier it becomes to reach consensus on the proposed feature and incorporate it into the protocol. Several TIPs can form a bundle of changes when linked to each other.</p>
<h3 id="tip-format-and-structure"><a class="header" href="#tip-format-and-structure">TIP Format and Structure</a></h3>
<p>TIPs must adhere to the format and structure requirements that are outlined in this document. A TIP is written in <a href="https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax">Markdown</a> format and should have the following parts (optional parts are marked with a *):</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Preamble</td><td><a href="https://www.ietf.org/rfc/rfc822.txt">RFC 822</a> style headers containing metadata about the TIP, including the TIP number, a short descriptive title (limited to a maximum of 44 characters), a description (limited to a maximum of 140 characters), and the author details. Irrespective of the category, the title and description should not include TIP number. <a href="tips/TIP-0001/tip-0001.html#tip-header-preamble">See below</a> for details.</td></tr>
<tr><td>Abstract</td><td>A short summary of the technical issue being addressed by the TIP.</td></tr>
<tr><td>Motivation</td><td>A motivation section is critical for TIPs that want to change the IOTA protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the TIP solves. TIP submissions without sufficient motivation may be rejected outright.</td></tr>
<tr><td>Specification</td><td>The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current IOTA platforms.</td></tr>
<tr><td>Rationale</td><td>The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.</td></tr>
<tr><td>Backwards Compatibility*</td><td>All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities. TIP submissions without a sufficient backwards compatibility treatise may be rejected outright.</td></tr>
<tr><td>Test Cases*</td><td>Test cases for an implementation are mandatory for TIPs that are affecting consensus changes. Tests should either be inlined in the TIP as data or placed in the TIP folder.</td></tr>
<tr><td>Reference Implementation*</td><td>An optional section that contains a reference/example implementation that people can use to assist in understanding or implementing this specification.</td></tr>
<tr><td>Copyright</td><td>All TIPs must be in the public domain. See the bottom of this TIP for an example copyright waiver.</td></tr>
</tbody></table>
</div>
<h3 id="tip-template"><a class="header" href="#tip-template">TIP Template</a></h3>
<p>The template to follow for new TIPs is located in the <a href="tips/TIP-0001/../../tip-template.html">repository</a>.</p>
<h3 id="tip-process"><a class="header" href="#tip-process">TIP Process</a></h3>
<p>Parties involved in the process are:</p>
<ul>
<li><em>TIP author</em>: you, the champion who proposes a new TIP. It is the responsibility of the <em>TIP author</em> to drive the progression of the TIP to <code>Active</code> status. This includes initiating public discussion and implementing the proposal as well.</li>
<li><em>TIP editor</em>: they deal with administering the TIP process and ensure process requirements are fulfilled.</li>
<li><em>Technical Committee</em>: technical experts of IOTA who evaluate new TIPs, provide feedback and ensure that only sound and secure features are added to the protocol.</li>
</ul>
<h4 id="tip-statuses"><a class="header" href="#tip-statuses">TIP Statuses</a></h4>
<p>The status of the TIP describes its current stage in the TIP process.</p>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Idea</td><td>An idea for an improvement to the IOTA technology. Not yet tracked as an official TIP.</td></tr>
<tr><td>Draft</td><td>The idea has been formally accepted in the repository, and is being worked on by its authors.</td></tr>
<tr><td>Proposed</td><td>The TIP has a working implementation and has clear plans on how to progress to <code>Active</code> status.</td></tr>
<tr><td>Active</td><td>The TIP is deployed to the main network or some TIP specific adoption criteria has been met.</td></tr>
<tr><td>Deferred</td><td>The <em>TIP author(s)</em> are not working on the TIP currently, but plan to continue in the future. TIP is on hold.</td></tr>
<tr><td>Rejected</td><td>The TIP is rejected.</td></tr>
<tr><td>Withdrawn</td><td>The TIP has been withdrawn by the <em>TIP author(s)</em>.</td></tr>
<tr><td>Replaced</td><td>The TIP is replaced by a newer TIP. Must point to the new TIP in the header.</td></tr>
<tr><td>Obsolete</td><td>The TIP is rendered obsolete by some future change.</td></tr>
</tbody></table>
</div>
<h4 id="tip-workflow"><a class="header" href="#tip-workflow">TIP Workflow</a></h4>
<p><em>How are new proposal get added to the protocol?</em></p>
<ol>
<li>
<p>All TIPs begin life as an <code>Idea</code> proposed in the public <a href="https://github.com/iotaledger/tips/discussions">IOTA discussion forum, that is the GitHub Discussion page of the TIP repository</a>. A public, open discussion should predate any formal TIP submission. If you want to propel your proposal to acceptance, you should make sure to build consensus and support in the community around your proposed changes already in the idea stage.</p>
</li>
<li>
<p>Once the idea has been vetted, your next task is to submit a <code>Draft</code> TIP to the TIP repository as a pull request. Do not assign a TIP number yet to the draft, but make sure that the proposal is technically sound and follows the format and style guides of the TIP Process. Create a sub-folder under <code>tips</code> folder with the title of the draft (<code>tips/title_of_draft/</code>) and put all assets in this folder.</p>
</li>
<li>
<p>A <em>TIP editor</em> reviews your PR and assigns a TIP number to the draft.</p>
</li>
<li>
<p>The <em>Technical Committee</em> as well as the broader public evaluate the draft proposal and might ask for modifications or clarifications. The proposal can only be merged into the repository as a draft if it represents a net improvement and does not complicate the protocol unduly.</p>
</li>
<li>
<p>The TIP is merged into the repo with <code>Draft</code> status by <em>TIP editor/author</em>.</p>
</li>
<li>
<p>When a working implementation is presented and there are clear plans on how to progress the TIP to  completion, the <em>TIP author</em> submits a subsequent PR that links its implementation to the TIP and progresses it to <code>Proposed</code> stage. The TIP is ready to be deployed on testnet.</p>
</li>
<li>
<p>When a <code>Proposed</code> TIP is deemed to have met all appropriate criteria and its implementation has been demonstrated to work reliably in testnet environment, it is ready to be moved to the main network. Upon deployment, the TIP status must change to <code>Active</code>.</p>
</li>
</ol>
<p><em>How can a TIP transition from one status to another?</em></p>
<p><img src="tips/TIP-0001/./process.svg" alt="image" /></p>
<p>A <code>Draft</code> TIP might be moved to <code>Deferred</code> status by the <em>TIP author(s)</em> when they are no longer working on the proposal, but plan to continue it in the future.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Withdrawn</code> status by the <em>TIP author(s)</em>.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Rejected</code> status by <em>TIP editor(s)</em> or <em>Technical Committee</em> if it does not meet the appropriate TIP criteria, or no relevant progress has been demonstrated on the TIP for at least 3 years.</p>
<p>A <code>Draft</code> TIP might be moved to <code>Proposed</code> status by TIP author(s) if it is considered complete, has a working implementation and clear plans on how to progress it to <code>Active</code> status.</p>
<p>A <code>Proposed</code> TIP might be moved to <code>Active</code> status if a TIP specific adoption criteria has been met. For Core TIPs this means deployment on the main network.</p>
<p>A <code>Proposed</code> TIP might be moved to <code>Rejected</code> status by <em>TIP editor(s)</em> or <em>Technical Committee</em> if its implementation puts unduly burden and complexity on the protocol, or other significant problems are discovered during testing.</p>
<p>An <code>Active</code> TIP might be moved to <code>Replaced</code> status by a newer TIP. The replaced TIP must point to the TIP that replaces it.</p>
<p>An <code>Active</code> TIP might be moved to <code>Obsolete</code> status when the feature is deprecated.</p>
<p><em>How to champion the TIP Process as a TIP author?</em></p>
<ul>
<li>Browse the <a href="https://github.com/iotaledger/tips/discussions">idea discussion forum</a> before posting a new TIP idea. Someone else might already have proposed your idea, or a similar one. Take inspiration from previous ideas and discussions.</li>
<li>It is your responsibility as a <em>TIP author</em> to build community consensus around your idea. Involve as many people in the discussion as you can. Use social media platforms, Discord or Reddit to raise awareness of your idea.</li>
<li>Submit a draft TIP as a PR to the TIP repository. Put extra care into following TIP guidelines and formats. TIPs must contain a link to previous discussions on the topic, otherwise your submissions might be rejected. TIPs that do not present convincing motivation, demonstrate lack of understanding of the design's impact, or are disingenuous about the drawbacks or alternatives tend to be poorly-received.</li>
<li>Your draft TIP gets a TIP number assigned by a <em>TIP editor</em> and receives review and feedback from the larger community as well as from the <em>Technical Committee</em>. Be prepared to revise your draft based on this input.</li>
<li>TIPs that have broad support are much more likely to make progress than those that don't receive any comments. Feel free to reach out to the <em>TIP editors</em> in particular to get help to identify stakeholders and obstacles.</li>
<li>Submitted draft TIPs rarely go through the process unchanged, especially as alternatives and drawbacks are shown. You can make edits, big and small, to the draft TIP to clarify or change the design, but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li>
<li>When your draft TIP PR gets enough approvals from <em>TIP editors</em> and <em>Technical Committee</em> members, it can be merged into the repository, however, your job is far from complete! To move the draft into the next status (proposed), you have to demonstrate a working implementation of your TIP. For Core TIPs, seek help from protocol developers and/or client teams to coordinate the feature implementation. For IRCs for example you need to provide their implementation yourself.</li>
<li>You also need to present a clear plan on how the TIP will be moved to the <code>Active</code> status, by for example agreeing on a TIP deployment strategy with the <em>Technical Committee</em> or core developers.</li>
<li>To move your <code>Draft</code> TIP to the <code>Proposed</code> phase, submit a subsequent PR that links its implementation and devises its route to become <code>Active</code>. The latter might be an additional document in the TIP's folder, a link to a public discussion or a short description or comment on the PR itself.</li>
<li>To move your <code>Proposed</code> TIP to <code>Active</code> status you need to demonstrate that it has met its specific adoption criteria. For Core TIPs, this means that majority of network nodes support it. For other TIPs, especially for IRCs, adoption might mean that the standard is publicly available, well documented and there are applications building on it.</li>
</ul>
<h3 id="tip-header-preamble"><a class="header" href="#tip-header-preamble">TIP Header Preamble</a></h3>
<p>Each TIPs must have an RFC 822 style header preamble preceded and followed by three hyphens (---). The headers must appear in the following order. Headers marked with &quot;*&quot; are optional and are described below. All other headers are required.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tip</code></td><td>TIP number, or &quot;?&quot; before being assigned (assigned by <em>TIP editor</em>)</td></tr>
<tr><td><code>title</code></td><td>Few words describing the TIP, maximum 44 characters</td></tr>
<tr><td><code>description*</code></td><td>One full short sentence</td></tr>
<tr><td><code>author</code></td><td>A comma separated list of the author's or authors' name + GitHub username (in parenthesis), or name and email (in angle brackets). Example, FirstName LastName (@GitHubUsername), FirstName LastName <a href="mailto:tips/TIP-0001/foo@bar.com">foo@bar.com</a>, FirstName (@GitHubUsername) and GitHubUsername (@GitHubUsername)</td></tr>
<tr><td><code>discussions-to*</code></td><td>The url pointing to the official discussion thread</td></tr>
<tr><td><code>status</code></td><td>Current status of the TIP. One of: <code>Draft</code>, <code>Proposed</code>, <code>Active</code>, <code>Deferred</code>, <code>Rejected</code>, <code>Withdrawn</code>, <code>Obsolete</code> or <code>Replaced</code></td></tr>
<tr><td><code>type</code></td><td>TIP type, one of: <code>Standards Track</code>, <code>Process</code> or <code>Informational</code></td></tr>
<tr><td><code>layer*</code></td><td>Only for Standards Track, defines layer: <code>Core</code>, <code>Networking</code>, <code>Interface</code> or <code>IRC</code></td></tr>
<tr><td><code>created</code></td><td>Date created on, in ISO 8601 (yyyy-mm-dd) format</td></tr>
<tr><td><code>requires*</code></td><td>Link dependent TIPs by number</td></tr>
<tr><td><code>replaces*</code></td><td>Older TIP being replaced by this TIP</td></tr>
<tr><td><code>superseded-by*</code></td><td>Newer TIP replaces this TIP</td></tr>
<tr><td><code>withdrawal-reason*</code></td><td>A sentence explaining why the TIP was withdrawn. (Optional field, only needed when status is <code>Withdrawn</code>)</td></tr>
<tr><td><code>rejection-reason*</code></td><td>A sentence explaining why the TIP was rejected. (Optional field, only needed when status is <code>Rejected</code>)</td></tr>
</tbody></table>
</div>
<h3 id="linking-tips"><a class="header" href="#linking-tips">Linking TIPs</a></h3>
<p>References to other TIPs should follow the format TIP-N where N is the TIP number you are referring to. Each TIP that is referenced in an TIP MUST be accompanied by a relative Markdown link the first time it is referenced, and MAY be accompanied by a link on subsequent references. The link MUST always be done via relative paths so that the links work in this GitHub repository or forks of this repository. For example, you would link to this TIP with <code>[TIP-1](../TIP-0001/tip-0001.md)</code>.</p>
<h3 id="auxiliary-files"><a class="header" href="#auxiliary-files">Auxiliary Files</a></h3>
<p>Images, diagrams and auxiliary files should be included in the subdirectory of the TIP.  When linking to an image in the TIP, use relative links such as <code>[TIP Process Diagram](../TIP-0001/process.png)</code>.</p>
<h3 id="transferring-tip-ownership"><a class="header" href="#transferring-tip-ownership">Transferring TIP Ownership</a></h3>
<p>It occasionally becomes necessary to transfer ownership of TIPs to a new champion. In general, we'd like to retain the original author as a co-author of the transferred TIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the TIP process, or has fallen off the face of the 'net (i.e. is unreachable or isn't responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the TIP. We try to build consensus around a TIP, but if that's not possible, you can always submit a competing TIP.</p>
<p>If you are interested in assuming ownership of a TIP, send a message asking to take over, addressed to both the original author and the <em>TIP editors</em>. If the original author doesn't respond to the email in a timely manner, the <em>TIP editors</em> will make a unilateral decision (it's not like such decisions can't be reversed :)).</p>
<h3 id="tip-editors"><a class="header" href="#tip-editors">TIP Editors</a></h3>
<p>The current TIP editors are:</p>
<ul>
<li>Kumar Anirudha (@anistark, kumar.anirudha@iota.org)</li>
<li>Levente Pap (@lzpap, levente.pap@iota.org)</li>
</ul>
<h3 id="tip-editor-responsibilities"><a class="header" href="#tip-editor-responsibilities">TIP Editor Responsibilities</a></h3>
<p>TIP editors' essential role is to assist and guard the process of contributing to the IOTA ecosystem, provide help and directions to community members as well as to external contributors. If you have a question regarding the TIP process, reach out to them, they will point you to the right direction.</p>
<p>They ensure that only quality contributions are added as TIPs, provide support for TIP authors, furthermore monitor that the TIP process is fair, objective and well documented.</p>
<p>For each new TIP that comes in, an editor does the following:</p>
<ul>
<li>Read the TIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to get to <code>Active</code> status.</li>
<li>The title should accurately describe the content.</li>
<li>Check the TIP for language (spelling, grammar, sentence structure, etc.), markup (GitHub flavored Markdown), code style.</li>
</ul>
<p>If the TIP isn't ready, the editor will send it back to the author for revision, with specific instructions.</p>
<p>Once the TIP is ready to be merged as a draft, the editor will:</p>
<ul>
<li>Assign a TIP number that does not conflict with other TIP numbers. It might be the PR number, but might also be selected as the next unused TIP number in line.</li>
<li>Merge the corresponding pull request.</li>
<li>Send a message back to the TIP author with the next step.</li>
</ul>
<p>The editors don't pass judgment on TIPs. We merely do the administrative &amp; editorial part.</p>
<h3 id="technical-committee"><a class="header" href="#technical-committee">Technical Committee</a></h3>
<p>The <em>Technical Committee</em> consists of several core contributors of the IOTA ecosystem and core developers. Their job is to evaluate technical details of TIPs, judge their technical feasibility and safeguard the evolution of the protocol. Core improvement ideas must be carefully thought through and their benefits must outweigh their drawbacks.</p>
<p>In order for a draft TIP to be accepted into the repo, it must be signed-off by the <em>Technical Committee</em>. It is also the committee that gives the green light for drafts to become proposed or active.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>The TIP process is intended to replace the formerly adopted RFC process to achieve:</p>
<ul>
<li>Simpler workflow and less rigid process structure,</li>
<li>Broader platform for ideation and early phase improvement discussions,</li>
<li>A layered protocol specification approach that can describe not only core components, but also higher layer protocols and application-level conventions.</li>
</ul>
<p>In order not to reinvent the wheel, the TIP Process draws heavily on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki">BIP</a> and <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1.md">EIP</a> processes.</p>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<ul>
<li>The current <code>iotaledger/protocol-rfcs</code> repository will be renamed to <code>iotaledger/tips</code>.</li>
<li>Merged RFCs will receive a TIP number and header with <code>Active</code> status.</li>
<li>PRs in the repo will be mapped as <code>Draft</code> TIPs, either modifications to existing TIPs or new ones.</li>
<li>The GitHub Discussion page of the repository will be restructured to accommodate TIP idea discussions.</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki">BIP-1</a> and<a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki"> BIP-2</a>, Bitcoin Improvement Proposal Purpose and Guidelines</li>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1.md">EIP-1</a>, Ethereum Improvement Proposal Purpose and Guidelines</li>
<li><a href="https://github.com/cardano-foundation/CIPs/tree/master/CIP-0001">CIP-1</a>, Cardano Improvement Proposal Process</li>
</ul>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 2
title: White Flag Ordering
description: Mitigate conflict spamming by ignoring conflicts
author: Thibault Martinez (@thibault-martinez) <thibault@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/5, https://github.com/iotaledger/tips/pull/30
status: Active
type: Standards
layer: Core
created: 2020-03-06
</pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This RFC is part of a set of protocol changes, <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, aiming at improving the
network before <a href="https://coordicide.iota.org/">Coordicide</a> is complete.</p>
<p>The feature presented in this RFC, White Flag, allows milestones to confirm conflicting messages by enforcing
deterministic ordering of the Tangle and applying only the first message(s) that will not violate the ledger state.</p>
<p>The content of this RFC is based on <a href="https://iota.cafe/t/conflict-white-flag-mitigate-conflict-spamming-by-ignoring-conflicts/233">Conflict white flag: Mitigate conflict spamming by ignoring conflicts</a>.</p>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<ul>
<li>Eliminates the <a href="https://iota.cafe/t/conflict-spamming-attack/232">Conflict spamming attack</a>;</li>
<li>As conflicts are ignored in the balance computation, they do not need to be considered during tip selection of the
nodes allowing much easier tip selection algorithms leading to increased TPS;</li>
<li>By using this approach in combination with an appropriate TSA, during regular use, no honest message will ever
require re-attaching leading to increased CTPS;</li>
<li>Does not come with added computation complexity by integrating nicely into already existing algorithms;</li>
</ul>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<p>First, let us define what it means for a message A to be:</p>
<ul>
<li>referenced (indirectly or directly) by message B: A is contained in the past cone of B;</li>
<li>confirmed: A is referenced by a milestone;</li>
<li>applied: A is confirmed and applied to the ledger state;</li>
<li>ignored: A is confirmed but not applied because it is semantically invalid;</li>
<li>conflicting: A would lead to an invalid ledger state if applied;</li>
</ul>
<p>In case of conflicting messages with White Flag, a node applies only one message to the ledger state and ignores
all the others. For this to work, all the nodes need to be sure they are all applying the same message; hence, the
need for a deterministic ordering of the Tangle.</p>
<p>First, this RFC proposes a deterministic ordering of the Tangle, then it explains which message is selected in case
of conflicts.</p>
<p><strong>Note: The past-cone of milestone can only contain syntactically valid messages. If an invalid message is encountered,
operations must be stopped immediately.</strong></p>
<h2 id="deterministically-ordering-the-tangle"><a class="header" href="#deterministically-ordering-the-tangle">Deterministically ordering the Tangle</a></h2>
<p>When a new milestone is broadcasted to the network, nodes will need to order the set of messages it confirms.</p>
<p>A subset of the Tangle can be ordered depending on many of its properties (e.g. alphanumeric sort of the message
hashes); however, to compute the ledger state, a graph traversal has to be done so it can be used to order the messages
in a deterministic order with no extra overhead.</p>
<p>This ordering is then defined as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological ordering</a> because
it respects the dependency of messages, ensuring that parents of a message are applied before it.
Since there are multiple valid topological orders for the same graph and, to avoid conflicting ledger states, it
is required that all nodes apply messages in the exact same order.</p>
<p>For this reason, this RFC proposes an order that has to be rigorously followed by all node implementations.
This order is the topological ordering generated by a post-order <a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search (DFS)</a>
starting from a milestone message, going through its parents (in the order they appear in the message) and finally
analysing the current message. Since only a subset of messages is considered, the stopping condition of this DFS is
reaching messages that are already confirmed by another milestone.</p>
<h2 id="applying-first-messages-that-does-not-violate-the-ledger-state"><a class="header" href="#applying-first-messages-that-does-not-violate-the-ledger-state">Applying first message(s) that does not violate the ledger state</a></h2>
<p>If a conflict is occurring in the set of messages confirmed by a milestone, nodes have to apply the first - with regards
to the order previously proposed - of the conflicting messages to the ledger and ignore all the others.</p>
<p>Once a message is marked as ignored, this is final and cannot be changed by a later milestone.</p>
<p>Since the ledger state is maintained from one milestone to another, a message conflicting with a message already
confirmed by a previous milestone would also be ignored.</p>
<h2 id="pseudo-code"><a class="header" href="#pseudo-code">Pseudo-code</a></h2>
<p>The following algorithm describes the process of updating the ledger state which is usually triggered by the arrival of
a new milestone confirming many new messages.</p>
<p>Pseudo-code means that implementation details such as types, parameters, ..., are not important but that the logic has
to be followed with care when implementing a node to avoid differences in the ledger state.</p>
<pre><code>update_ledger_state(ledger, milestone, solid_entry_points) {
    s = new Stack()
    visited = new Set()

    s.push(milestone)

    while (!s.is_empty()) {
        curr = s.peek()
        next = null

        // Look for the first eligible parent that was not already visited
        for parent in curr.parents {
          if (!solid_entry_points.contains(parent) &amp;&amp; !parent.confirmed &amp;&amp; !visited.contains(parent)) {
            next = parent
            break
          }
        }

        // All parents have been visited, apply and visit the current message
        if next == null {
          ledger.apply(curr)
          visited.add(curr)
          s.pop()
        }
        // Otherwise, go to the parent
        else {
          s.push(next)
        }
    }
}
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>solid_entry_points</code> is a set of hashes that are considered solid even though we do not have them or their past in
a database. They often come from a snapshot file and allow a node to solidify without needing the full tangle history.
The hash of the genesis message is also a solid entry point.</li>
<li><code>confirmation_index</code> is the index of the milestone that confirmed the message.</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>In this example, there are 26 messages labeled from <code>A</code> to <code>Z</code>.
The set of red messages <code>{A, B, C, E, F, H}</code> is confirmed by milestone <code>H</code>.
The set of purple messages <code>{D, G, J, L, M, N, K, I, O, S, R, V}</code> is confirmed by milestone <code>V</code>.
The set of blue messages <code>{Q, U, X, Y, Z, W, T, P}</code> is confirmed by another milestone.</p>
<p><img src="tips/TIP-0002/tangle.svg" alt="" /></p>
<p>Applying the previously shown algorithm on the purple set produces the topological order
<code>{D, G, J, L, M, R, I, K, N O, S, V}</code>.</p>
<p><img src="tips/TIP-0002/tangle-conflict.svg" alt="" /></p>
<p>Here, message <code>G</code> and message <code>O</code>, both confirmed by milestone <code>V</code>, are conflicting. Since in the topological order just
produced, <code>G</code> appears before <code>O</code>, <code>G</code> is applied to the ledger and <code>O</code> is ignored.</p>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<ul>
<li>The ledger state is now only well-defined at milestones, meaning that we have to wait until each milestone is
issued in order to confirm a spend;</li>
<li>Everything that is seen is now part of the Tangle, including double-spend attempts, meaning that malicious data will
now be saved as part of the consensus set of the Tangle;</li>
<li>To prove that a specific (non-milestone) message is valid, it is no longer sufficient to just provide the &quot;path&quot;
to its confirming milestone, but instead all messages in its past cone.</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>The main alternative to White Flag is what has been done so far i.e. not allowing conflicting messages confirmation.
As explained in this RFC, this comes with added complexity when performing a Tip Selection Algorithm because a node has
to constantly check for ledger inconsistencies.</p>
<p>As part of Chrysalis and coupled with an adequate Tip Selection Algorithm, White Flag is an improvement of the network
by allowing a potential increase of TPS/CTPS.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<p>A node consumes and produces snapshot files and bases the computation of its ledger state on them. In the current
network, if one of these files was tampered with and fed to a node, it would eventually lead to an invalid ledger state
where a message confirmed by a milestone would actually be a double spend. This situation would be detected by the node
and it would stop its activities as a security measure. However, with White Flag, such messages would be confirmed by
milestones but ignored by the node, the fake snapshot then going unnoticed. The ledger state would then become more and
more corrupted and the view of the balances completely wrong, errors just accumulating over time. The need for a
snapshot verification mechanism is then amplified by the implementation of White Flag. This mechanism being out of the
scope of this RFC, it will be described in another RFC.</p>
<h1 id="copyright-1"><a class="header" href="#copyright-1">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 3
title: Uniform Random Tip Selection
description: Perform fast tip-selection to increase message throughput
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/8
status: Active
type: Standards
layer: Core
created: 2020-03-09
</pre>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Weighted Uniform Random Tip Selection on a subset enables a node to perform fast tip-selection to increase message throughput.
The algorithm selects tips which are non-lazy to maximize confirmation rate.</p>
<h1 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h1>
<p>Because of the <code>white-flag</code> confirmation algorithm, it is no longer necessary to perform complex
tip-selection which evaluates ledger mutations while walking. Therefore, a more simple, better 
performing algorithm can be used to select tips, which in turn increases overall message throughput.</p>
<p>To maximize confirmation rate however, the algorithm needs to return tips which are <code>non-lazy</code>.
Non-lazy in this context means that a tip does not attach to a cone of messages which is too far
in the past. Such a cone is likely to be already confirmed and does not contribute to the
rate of newly confirmed messages when a milestone is issued.</p>
<h1 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h1>
<p>Definitions:</p>
<ul>
<li><code>Direct Approvers</code> - The set of messages which directly approve a given message.</li>
<li><code>Approvee</code> - The directly approved message of a given message.</li>
<li><code>Solid Message</code> - A message that its past cone is known to the node.</li>
<li><code>Valid Message</code>- A message which is syntactically valid.</li>
<li><code>Tip</code> - A valid solid message that doesn't have approvers. Its past cone contains only valid messages.</li>
<li><code>Score</code> - An integer assigned to a <code>tip</code>. The tip selection algorithm uses it to determine how to select tips.</li>
<li><code>Confirmed Root Message</code> - The set of first seen messages which are confirmed by a previous milestone 
when we walk the past cone of a given message. The walk stops on a confirmed message.<br />
Note that the red marked milestone is also a <code>Confirmed Root Message</code>.
<img src="tips/TIP-0003/cnf_tx_roots.PNG" alt="sdf" /></li>
<li><code>Message Snapshot Index (MSI)</code> defines the index of the milestone which confirmed a given message.</li>
<li><code>Oldest Message Root Snapshot Index (OMRSI)</code> defines the lowest milestone index of a set of
<code>Confirmed Root Messages</code> of a given messages.</li>
<li><code>Youngest Message Root Snapshot Index (YMRSI)</code> defines the highest milestone index of a set of
<code>Confirmed Root Messages</code> of a given message.</li>
<li><code>Latest Solid Milestone Index (LSMI)</code> the index of the latest solid milestone.</li>
<li><code>Below Max Depth (BMD)</code> defines a threshold value up on which it is decided on whether a message is not
relevant in relation to the recent parts of the Tangle. The current <code>BMD</code> for mainnet nodes is 15 milestones, 
which means that messages of which their <code>OMRSI</code> in relation to the <code>LSMI</code> is more than 15, are &quot;below max depth&quot;.</li>
</ul>
<h3 id="omrsi--ymrsi-example"><a class="header" href="#omrsi--ymrsi-example">OMRSI / YMRSI example</a></h3>
<p>Given the blue PoV message, the <code>OMRSI</code> of it is milestone 1 and <code>YMRSI</code> milestone 2.
Note that, here again, the milestones are also <code>Confirmed Root Messages</code>.
<img src="tips/TIP-0003/otrsi_ytrsi.PNG" alt="sdf" /></p>
<h3 id="milestone-based-tip-scoring"><a class="header" href="#milestone-based-tip-scoring">Milestone based tip scoring</a></h3>
<p>The milestone based scoring defines a tip's score by investigating the tip's relation to
the cone it approves and previous issued  milestones.</p>
<p>A tip can have one of 3 score states:</p>
<ul>
<li><code>0</code>: The tip is lazy and should not be selected.</li>
<li><code>1</code>: The tip is somewhat lazy.</li>
<li><code>2</code>: The tip is a non-lazy tip.</li>
</ul>
<p>Definitions:</p>
<ul>
<li><code>C1</code>: Max allowed delta value for the <code>YMRSI</code> of a given message in relation to the current <code>LSMI</code>.</li>
<li><code>C2</code>: Max allowed delta value between <code>OMRSI</code> of a given message in relation to the current <code>LSMI</code>. </li>
<li><code>M</code>: Max allowed delta value between <code>OMRSI</code> of the given message in relation to the current <code>LSMI</code>.
<code>M</code> is the <code>below max depth (BMD)</code> parameter.</li>
</ul>
<p>Recommended defaults:</p>
<ul>
<li><code>C1</code> = 8 milestones</li>
<li><code>C2</code> = 13 milestones</li>
<li><code>M</code> = 15 milestones</li>
</ul>
<p>Scoring Algorithm (pseudo code):</p>
<pre><code>
enum Score (
    LAZY = 0
    SEMI_LAZY = 1
    NON_LAZY = 2
)

const (
    C1 = 8
    C2 = 13
    M = 15
)

func score(tip Tip) Score {
    
    // if the LSMI to YMRSI delta is over C1, then the tip is lazy
    if (LSMI - YMRSI(tip) &gt; C1) {
        return Score.LAZY
    }
    
    // if the OMRSI to LSMI delta is over M/below-max-depth, then the tip is lazy
    if (LSMI - OMRSI(tip) &gt; M) {
        return Score.LAZY
    }
    
    if (LSMI - OMRSI(tip) &gt; C2) {
        return Score.SEMI_LAZY
    }

    return Score.NON_LAZY
}
</code></pre>
<h3 id="random-tip-selection"><a class="header" href="#random-tip-selection">Random Tip-Selection</a></h3>
<p>A node should keep a set of non-lazy tips (score 2).
Every time a node is asked to select tips to be approved, it will pick randomly from the set. 
A node must not execute tip-selection if it is not synchronized.</p>
<p>A tip should not be removed from the tips set immediately after it was selected in <code>select()</code>,  to make it possible for it to be re-selected, which in turn makes the Tangle wider
and improves synchronization speed. A tip is removed from the tips set if <code>X</code> amount of direct
approvers are reached or if a certain amount of time <code>T</code> passed. 
It is recommended to use <code>X</code> = 2 and <code>T</code> = 3  but the threshold should be configurable.</p>
<h3 id="purpose-of-semi-lazy-tips"><a class="header" href="#purpose-of-semi-lazy-tips">Purpose Of Semi-Lazy Tips</a></h3>
<p>Semi-Lazy tips are not eligible for tip-selection, but the coordinator node may implement a tip selection algorithm
that confirms semi-lazy tips. Semi-lazy tips will usually be left behind, but parties interested in having them confirmed
are incentivized to run spammers that will actively reduce the amount of semi-lazy tips eligible for coordinator's tip selection. 
Given a coordinator that chooses semi-lazy tips, running such spammers may get those messages confirmed before
they become lazy.</p>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<p>Depending on when and how often <code>YMRSI</code>/<code>OMRSI</code> values are computed, this tip-selection could still
have a slow runtime, as one would need to constantly walk down the Tangle to compute those
values. However, smart caching might resolve this issue. </p>
<h1 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h1>
<p>The previous tip-selection was written in accordance to the original IOTA whitepaper, as it also
functioned as part of the consensus mechanism.
However, relatively soon it became apparent that the cumulative weight computation was too heavy
for an actual high throughput scenario and, as such, the CW calculation is currently not used within
node implementations at all.</p>
<p>Because confirmations with the <a href="tips/TIP-0003/../TIP-0002/tip-0002.html">white-flag</a> approach no longer approve cones only with state mutations,
which are consistent with a previous ledger state, it makes sense to alter the tip-selection to provide 
a fast way to get tips to approve with one's own message.
The only important thing is to disincentive lazy behaviour to be able to maximize confirmation rate.</p>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<h4 id="when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction"><a class="header" href="#when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction">When to compute the score and <code>YMRSI</code>/<code>OMRSI</code> of a transaction?</a></h4>
<p>It is not yet clear when or how often the <code>YMRSI</code>/<code>OMRSI</code> values of a transaction should be updated.
If the values are only computed once after a transaction became solid, the <code>YMRSI</code>/<code>OMRSI</code> might not
resemble the true values, as subsequent milestones might confirm transactions within the same cone the
given transaction approved.</p>
<p>Currently, we suggest recomputing the values every time a new milestone solidifies. 
Since different tips indirectly reference the same transactions, this computation can be optimized.</p>
<h1 id="copyright-2"><a class="header" href="#copyright-2">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 4
title: Milestone Merkle Validation
description: Add Merkle tree hash to milestone for local ledger state verification
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/12, https://github.com/iotaledger/tips/pull/31
status: Active
type: Standards
layer: Core
created: 2020-05-04
</pre>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>In the IOTA protocol, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC adds extra information to each milestone in the form of a Merkle tree hash, which allows nodes to explicitly validate their local view of the ledger state against the Coordinator's. This mechanism further enables a simple cryptographic proof of inclusion for transactions confirmed by the particular milestone.</p>
<h1 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h1>
<p>With the changes proposed in the IOTA protocol <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a>, milestones are allowed to reference conflicting transactions. These conflicts are then resolved by traversing the newly confirmed transactions in a global, deterministic order and applying the corresponding ledger state changes in that order. Conflicts or invalid transactions are ignored, but stay in the Tangle.
This approach has considerable advantages in terms of network security (e.g. protection against <a href="https://iota.cafe/t/conflict-spamming-attack/232">conflict spamming attacks</a>) and network performance. However, a milestone no longer represents the inclusion state of all its referenced transactions, but only marks the order in which transactions are checked against the ledger state and then, if not violating, applied. This has two significant drawbacks:</p>
<ul>
<li>Milestone validation: In the IOTA protocol, each node always compares the milestones issued by the Coordinator against its current ledger state. Discrepancies are reported and force an immediate halt of the node software. However, in the white flag proposal this detection is no longer possible as any milestone can lead to a valid ledger state by ignoring the corresponding violating ledger changes.</li>
<li>Proof of inclusion: In the pre-white-flag protocol, the inclusion of transaction t in the Tangle, and thus, the ledger, can be shown by providing an audit path of referencing transactions from t to its confirming milestone. In the white flag proposal this is no longer possible, as such an audit path does not provide any information on whether the transaction has been included or ignored.</li>
</ul>
<p>Note that the white flag proposal only changes the behavior of conflicting transactions. Messages without a transaction payload can never conflict and are thus always included in Tangle when they are first referenced by a milestone. As such, these messages do not need to be considered by the RFC and their processing and inclusion proof remain unchanged.</p>
<p>Where previously the structure of the Tangle alone was sufficient to address those issues, this RFC proposes to add the Merkle tree hash of all the valid (i.e. not ignored) newly confirmed transactions to the signed part of a milestone. This way, each IOTA node can check that the hash matches its local ledger state changes or provide a Merkle audit path for that milestone to prove the inclusion of a particular transaction.</p>
<h1 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed design</a></h1>
<h2 id="creating-a-milestone"><a class="header" href="#creating-a-milestone">Creating a Milestone</a></h2>
<ul>
<li>Perform tip selection to choose the parents referenced by the milestone.</li>
<li>Determine the topological order according to <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a> of the referenced messages that are not yet confirmed by a previous milestone.</li>
<li>Construct the list D consisting of the message IDs of all the not-ignored state-mutating transaction payloads in that particular order. A UTXO transaction is considered state-mutating, if it creates a new output.</li>
<li>Compute the 32-byte Merkle tree hash H = MTH(D).</li>
<li>Prepare the milestone payload as described in <a href="tips/TIP-0004/../TIP-0008/tip-0008.html">TIP-8</a>, where the field <code>Inclusion Merkle Root</code> is set to H.</li>
</ul>
<h2 id="milestone-validation"><a class="header" href="#milestone-validation">Milestone validation</a></h2>
<ul>
<li>Verify the signature of the milestone m.</li>
<li>Construct the ordered list D of the message IDs  of all the not-ignored state-mutating transaction payloads m confirms.</li>
<li>Compute H = MTH(D).</li>
<li>Verify that the field <code>Inclusion Merkle Root</code> in m matches H.</li>
</ul>
<h2 id="proof-of-inclusion"><a class="header" href="#proof-of-inclusion">Proof of inclusion</a></h2>
<ul>
<li>Identify the confirming milestone m of the input transaction t.</li>
<li>Determine the ordered list of the not-ignored messages m confirms.</li>
<li>Compute the Merkle audit path of t with respect to the Merkle tree for this ordered list.</li>
<li>Provide the audit path as well as m as proof of inclusion for t.</li>
</ul>
<h2 id="cryptographic-components"><a class="header" href="#cryptographic-components">Cryptographic components</a></h2>
<h3 id="merkle-hash-trees"><a class="header" href="#merkle-hash-trees">Merkle hash trees</a></h3>
<p>This RFC uses a binary Merkle hash tree for efficient auditing. In general, any cryptographic hashing algorithm can be used for this. However, we propose to use <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a>, as it provides a faster and more secure alternative to the widely used SHA-256. 
In the following we define the Merkle tree hash (MTH) function that returns the hash of the root node of a Merkle tree:</p>
<ul>
<li>The input is a list of binary data entries; these entries will be hashed to form the leaves of the tree.</li>
<li>The output is a single 32-byte hash.</li>
</ul>
<p>Given an ordered list of n input strings D<sub>n</sub> = {d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>n</sub>}, the Merkle tree hash of D is defined as follows:</p>
<ul>
<li>If D is an empty list, MTH(D) is the hash of an empty string:<br>
MTH({}) = BLAKE2().</li>
<li>If D has the length 1, the hash (also known as a leaf hash) is:<br>
MTH({d<sub>1</sub>}) = BLAKE2( 0x00 || d<sub>1</sub> ).</li>
<li>Otherwise, for D<sub>n</sub> with n &gt; 1:
<ul>
<li>Let k be the largest power of two less than n, i.e. k &lt; n ≤ 2k.</li>
<li>The Merkle tree hash can be defined recursively:<br>
MTH(D<sub>n</sub>) = BLAKE2( 0x01 || MTH({d<sub>1</sub>, ..., d<sub>k</sub>}) || MTH({d<sub>k+1</sub>, ..., d<sub>n</sub>}) ).</li>
</ul>
</li>
</ul>
<p>Note that the hash calculations for leaves and nodes differ. This is required to provide second preimage resistance: Without such a prefix, for a given input D an attacker could replace  two (or more) leaves with their corresponding aggregated node hash without changing the final value of MTH(D). This violates the fundamental assumption that, given MTH(D), it should be practically impossible to find a different input D' leading to the same value. Adding a simple prefix mitigates this issue, since now leaf and node hashes are computed differently and can no longer be interchanged.</p>
<p>Note that we do not require the length of the input to be a power of two. However, its shape is still uniquely determined by the number of leaves.</p>
<h3 id="merkle-audit-paths"><a class="header" href="#merkle-audit-paths">Merkle audit paths</a></h3>
<p>A Merkle audit path for a leaf in a Merkle hash tree is the shortest list of additional nodes in a Merkle tree required to compute the Merkle tree hash for that tree. At each step towards the root, a node from the audit path is combined with a node computed so far. If the root computed from the audit path matches the Merkle tree hash, then the audit path is proof that the leaf exists in the tree.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Merkle tree with 7 leaves:</p>
<ul>
<li>input D:
<ol>
<li>52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649</li>
<li>81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999</li>
<li>eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1</li>
<li>5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621</li>
<li>6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2</li>
<li>0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083</li>
<li>6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f</li>
</ol>
</li>
<li>Merkle tree hash H = MTH(D) (32-byte): bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb</li>
</ul>
<pre><code>root: bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb
 ├─ node: 03bcbb3cf4314eab2f5ae68c767ff0a5fec4573c865728231f71d596fd867b56
 │  ├─ node: ae4505f4cfae93586e23958ca88d35d2f34d43def49786b6d0d4224b819f4cda
 │  │  │  ┌ msg id: 52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649
 │  │  ├──┴ leaf: 3d1399c64ff0ae6a074afa4cd2ce4eab8d5c499c1da6afdd1d84b7447cc00544
 │  │  │  ┌ msg id: 81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999
 │  │  └──┴ leaf: 83b0b255014e9a3656f0004a3f17943a20b715ef9c3e7cb85a6b2abac15e00d0
 │  └─ node: 54d51291aca22ce5b04cd3e6584fa3026ebe86ef86f0a6dfb47ab843801d4b38
 │     │  ┌ msg id: eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1
 │     ├──┴ leaf: ad4bc0a34b27f37810f2ff3a8177ecc98402f8f59a06270f9d285fdf764e45fe
 │     │  ┌ msg id: 5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621
 │     └──┴ leaf: ffb3a7c6bea8f9fdcfb26f4701ad6e912a6076e1a40663607dbe110ebfc9a571
 └─ node: ce22d5bc728023e7ab6a9eb8f58baf62b9565fc8baeef4b377daa6709dbe598c
    ├─ node: e14c8af1258005cd0dbed88f0c5885c6988f319bb8f24272a7495592b873c169
    │  │  ┌ msg id: 6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2
    │  ├──┴ leaf: 1c062628a7a147cc6a4defa655ce6c4ae5b838b4b4cd81b12e8924b5b4b5cca6
    │  │  ┌ msg id: 0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083
    │  └──┴ leaf: 2ef4e2ad06b8c8ae1fd4b28b5ed166829533fbfff1f6c14218358537da277fa3
    │  ┌ msg id: 6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f
    └──┴ leaf: 7ec774ebc33ed4ca298e8a1cf1f569e36c6784467d63b055efd7612abe2858a4
</code></pre>
<h1 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h1>
<ul>
<li>The computation of the Merkle tree hash of D<sub>n</sub> requires 2n-1 evaluations of the underlying hashing algorithm. This makes the milestone creation and validation computationally slightly more expensive.</li>
</ul>
<h1 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h1>
<p>It is a crucial security feature of the IOTA network that nodes are able to validate the issued milestones. As a result, if the Coordinator were to ever send an invalid milestone, such as one that references counterfeit transactions, the rest of the nodes would not accept it. In a pure implementation of <a href="tips/TIP-0004/../TIP-0002/tip-0002.html">TIP-2</a> this feature is lost and must be provided by external mechanisms.
A Merkle tree hash provides an efficient, secure and well-established method to compress the information about the confirmed transactions in such a way, that they fit in the milestone transaction.</p>
<p>In this context, it could also be possible to use an unsecured checksum (such as CRCs) of the message IDs instead of a Merkle tree hash. However, the small benefit of faster computation times does no justify the potential security risks and attack vectors.</p>
<h1 id="reference-implementation"><a class="header" href="#reference-implementation">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Merkle tree computation of message IDs: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/merkle/merkle.go">pkg/merkle/merkle.go</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/merkle/pt2">examples/merkle/pt2</a></li>
</ul>
<h1 id="copyright-3"><a class="header" href="#copyright-3">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 5
title: Binary To Ternary Encoding
description: Define the conversion between binary and ternary data
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/15
status: Active
type: Standards
layer: Core
created: 2020-06-08
</pre>
<h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>In the IOTA protocol, a transaction is represented as ternary data. However, sometimes it is necessary to store binary data (e.g. the digest of a binary hash function) inside of a transaction. This requires the conversion of binary into ternary strings.
The IOTA client libraries support the opposite conversion that encodes 5 trits as 1 byte (sometimes also referred to as <code>t5b1</code> encoding), which is used for network communication and in storage layers. This RFC describes the corresponding counterpart to encode 1 byte as 6 trits.</p>
<h1 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h1>
<p>A byte is composed of 8 bits that can represent 2<sup>8</sup> = 256 different values. On the other hand, 6 trits can hold 3<sup>6</sup> = 729 values while 5 trits can hold 3<sup>5</sup> = 243 values. Therefore, the most memory-efficient way to encode one byte requires the use of 6 trits. Although there exist many potential encoding schemes to convert binary data into ternary, the proposed version has been designed to directly match the widely used <code>t5b1</code> encoding.</p>
<p>It is important to note that the <code>b1t6</code> encoding presented in this RFC does not replace the current <code>t5b1</code> encoding (or its corresponding decoding): <code>t5b1</code> is for example used to store trytes in a binary database, while <code>b1t6</code> will be used to attach binary data to an IOTA transaction.</p>
<h1 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed design</a></h1>
<h3 id="bytes-to-trits"><a class="header" href="#bytes-to-trits">Bytes to trits</a></h3>
<p>In order to encode a binary string S into ternary, each byte of S is interpreted as a signed (two's complement) 8-bit integer value v. Then, v is encoded as a little-endian 6-trit string in balanced ternary representation. Finally, the resulting groups of trits are concatenated.</p>
<p>This algorithm can also be described using the following pseudocode:</p>
<pre><code>T ← []
foreach byte b in S:
  v ← int8(b)
  g ← IntToTrits(v, 6)
  T ← T || g
</code></pre>
<p>Here, the function <code>IntToTrits</code> converts a signed integer value into its corresponding balanced ternary representation in little-endian order of the given length. The functionality of <code>IntToTrits</code> exactly matches the one used to e.g. encode the transaction values as trits in the current IOTA protocol.</p>
<h3 id="trits-to-bytes"><a class="header" href="#trits-to-bytes">Trits to bytes</a></h3>
<p>Given a trit string T as the result of the previous encoding, T is converted back to its original byte string S by simply reversing the conversion:</p>
<pre><code>S ← []
foreach 6-trit group g in T:
  v ← TritsToInt(g)
  b ← byte(v)
  S ← S || b
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li>I
<ul>
<li>binary (hex): <code>00</code></li>
<li>ternary (trytes): <code>99</code></li>
</ul>
</li>
<li>II
<ul>
<li>binary (hex): <code>0001027e7f8081fdfeff</code></li>
<li>ternary (trytes):
<code>99A9B9RESEGVHVX9Y9Z9</code></li>
</ul>
</li>
<li>III
<ul>
<li>binary (hex): <code>9ba06c78552776a596dfe360cc2b5bf644c0f9d343a10e2e71debecd30730d03</code></li>
<li>ternary (trytes): <code>GWLW9DLDDCLAJDQXBWUZYZODBYPBJCQ9NCQYT9IYMBMWNASBEDTZOYCYUBGDM9C9</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h1>
<ul>
<li>Conceptually, one byte can be encoded using log<sub>3</sub>(256) ≈ 5.0474 trits. Thus, encoding 1 byte as 6 trits consumes considerably more memory than the mathematical minimum.</li>
<li>Depending on the actual implementation the conversion might be malleable: E.g. since <code>byte(-1) = 0xff</code> and <code>byte(255) = 0xff</code>, both <code>Z9</code> (-1) and <code>LI</code>(255) could be decoded as <code>ff</code>. However, <code>LI</code> can never be the result of a valid <code>b1t6</code> encoding. As such, the implementation must reject such invalid inputs.</li>
</ul>
<h1 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h1>
<p>There are several ways to convert binary data into ternary, e.g.</p>
<ul>
<li>the conversion used as part of the <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md">Kerl</a> hash function encoding chunks of 48 bytes as 242 trits,</li>
<li>or by encoding each bit as one trit with the corresponding value.</li>
</ul>
<p>The current client libraries do not provide any functionality to convert an arbitrary amount of bytes into trits. The closest available functionality is the ASCII to trit conversion, which is used for human-readable messages in transactions:</p>
<pre><code>T ← []
foreach char c in S:
  first ← uint8(c) mod 27
  second ← (uint8(c)-first) / 27
  T ← T || IntToTrits(first, 3) || IntToTrits(second, 3)
</code></pre>
<p>This function can be adapted to encode any general byte string. However, the conversion seems rather arbitrary and the algorithm is computationally more intense than the proposed solution.
On the other hand, using the algorithm from this RFC also for the conversion of ASCII messages would break backward compatibility, which is also undesirable.</p>
<p>Each conversion method has different advantages and disadvantages. However, since the <code>t5b1</code> encoding is well-defined and has been used in <a href="https://github.com/iotaledger/iri">IRI</a> for both network communications and storage layers for a long time, choosing the direct counterpart for the opposite conversion represents the most logical solution providing a nice balance between performance and memory-efficiency.</p>
<h1 id="reference-implementation-1"><a class="header" href="#reference-implementation-1">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Binary-to-Ternary Encoding: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/encoding/ternary/ternary.go">pkg/encoding/ternary/ternary.go</a></li>
</ul>
<h1 id="copyright-4"><a class="header" href="#copyright-4">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 6
title: Tangle Message
description: Generalization of the Tangle transaction concept
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/17
status: Active
type: Standards
layer: Core
created: 2020-07-28
</pre>
<ul>
<li>Changelog:
<ul>
<li>(<a href="https://github.com/iotaledger/tips/pull/0037">iotaledger/tips#0037</a>) Fixed internal links</li>
</ul>
</li>
</ul>
<h1 id="summary-4"><a class="header" href="#summary-4">Summary</a></h1>
<p>The Tangle is the graph data structure behind IOTA. In the current IOTA protocol, the vertices of the Tangle are represented by transactions. This document proposes an abstraction of this idea where the vertices are generalized <em>messages</em>, which then contain the transactions or other structures that are processed by the IOTA protocol. Just as before, each message directly approves other messages, which are known as <em>parents</em>.</p>
<p>The messages can contain payloads. These are core payloads that will be processed by all nodes as part of the IOTA protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.</p>
<h1 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h1>
<p>To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a certain responsibility and once this responsibility is completed, we move on to the next layer.</p>
<p>The same is true with how messages are parsed. The outer layer of the message enables the mapping of the message to a vertex in the Tangle and allow us to perform some basic validation. The next layer may be a transaction that mutates the ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.</p>
<p>By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to accommodate future needs.</p>
<h1 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed design</a></h1>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<p>The following are data types that will be used when we specify fields in the message and payloads.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>uint8</td><td>An unsigned 8-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint16</td><td>An unsigned 16-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint32</td><td>An unsigned 32-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint64</td><td>An unsigned 64-bit integer encoded in Little Endian.</td></tr>
<tr><td>ByteArray[N]</td><td>A static size byte array of length N.</td></tr>
<tr><td>ByteArray</td><td>A dynamically sized byte array. A leading uint32 denotes its length in bytes.</td></tr>
</tbody></table>
</div>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<h3 id="message-id"><a class="header" href="#message-id">Message ID</a></h3>
<p>The <em>Message ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized message.</p>
<h3 id="serialized-layout"><a class="header" href="#serialized-layout">Serialized Layout</a></h3>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. This field denotes whether the message was meant for mainnet, testnet, or a private net. It also marks what protocol rules apply to the message. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Parents Count</td>
    <td>uint8</td>
    <td>The number of messages that are directly approved.</td>
  </tr>
  <tr>
    <td valign="top">Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved message.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Message ID</td>
            <td>ByteArray[32]</td>
            <td>The Message ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td valign="top">Payload <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Generic Payload</summary>
        <blockquote>
          An outline of a generic payload
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>
              The type of the payload. It will instruct the node how to parse the fields that follow.
            </td>
          </tr>
          <tr>
            <td>Data Fields</td>
            <td>ANY</td>
            <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
          </tr>
        </table>
      </details>
  <tr>
    <td>Nonce</td>
    <td>uint64</td>
    <td>The nonce which lets this message fulfill the PoW requirement.</td>
  </tr>
</table>
<h2 id="message-validation"><a class="header" href="#message-validation">Message validation</a></h2>
<p>The following criteria defines whether the message passes the syntactical validation:</p>
<ul>
<li>The total message size must not exceed 32 KiB (32 * 1024 bytes).</li>
<li>Parents:
<ul>
<li><code>Parents Count</code> must be at least 1 and not larger than 8.</li>
<li><code>Parents</code> must be sorted in lexicographical order.</li>
<li>Each <code>Message ID</code> must be unique.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0006/tip-0006.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li><code>Nonce</code> must be a valid solution of the message PoW as described in <a href="tips/TIP-0006/../TIP-0012/tip-0012.html">TIP-12</a>.</li>
<li>There must be no trailing bytes after all message fields have been parsed.</li>
</ul>
<h2 id="payloads"><a class="header" href="#payloads">Payloads</a></h2>
<p>While messages without a payload, i.e. <code>Payload Length</code> set to zero, are valid, such messages do not contain any information. As such, messages usually contain a payload. The detailed specification of each payload type is out of scope of this RFC. The following table lists all currently specified payloads that can be part of a message and links to their specification. The <em>indexation payload</em> will be specified here as an example:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Transaction</td><td>0</td><td><a href="tips/TIP-0006/../TIP-0007/tip-0007.html">TIP-7</a></td></tr>
<tr><td>Milestone</td><td>1</td><td><a href="tips/TIP-0006/../TIP-0008/tip-0008.html">TIP-8</a></td></tr>
<tr><td>Indexation</td><td>2</td><td><a href="tips/TIP-0006/tip-0006.html#indexation-payload">TIP-6</a></td></tr>
</tbody></table>
</div>
<h3 id="indexation-payload"><a class="header" href="#indexation-payload">Indexation payload</a></h3>
<p>This payload allows the addition of an index to the encapsulating message, as well as some arbitrary data. Nodes will expose an API that allows to query messages by index.</p>
<p>The structure of the indexation payload is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Payload Type</td><td>uint32</td><td>Set to <b>value 2</b> to denote an <i>Indexation Payload</i>.</td></tr>
<tr><td>Index Length</td><td>uint16</td><td>The length of the following index field in bytes.</td></tr>
<tr><td>Index</td><td>ByteArray[Index Length]</td><td>The index key of the message</td></tr>
<tr><td>Data</td><td>ByteArray</td><td>Binary data.</td></tr>
</tbody></table>
</div>
<p>Note that <code>Index</code> field must be at least 1 byte and not longer than 64 bytes for the payload to be valid. The <code>Data</code> may have a length of 0.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Below is the full serialization of a valid message with an indexation payload. The index is the &quot;IOTA&quot; ASCII string and the data is the &quot;hello world&quot; ASCII string. Bytes are expressed as hexadecimal numbers.</p>
<ul>
<li>Network ID (8-byte): <code>0000000000000000</code> (0)</li>
<li>Parents Count (1-byte): <code>02</code> (2)</li>
<li>Parents (64-byte):
<ul>
<li><code>210fc7bb818639ac48a4c6afa2f1581a8b9525e20fda68927f2b2ff836f73578</code></li>
<li><code>db0fa54c29f7fd928d92ca43f193dee47f591549f597a811c8fa67ab031ebd9c</code></li>
</ul>
</li>
<li>Payload Length (4-byte): <code>19000000</code> (25)</li>
<li>Payload (25-byte):
<ul>
<li>Payload Type (4-byte): <code>02000000</code> (2)</li>
<li>Index Length (2-byte): <code>0400</code> (4)</li>
<li>Index (4-byte): <code>494f5441</code> (&quot;IOTA&quot;)</li>
<li>Data (15-byte):
<ul>
<li>Length (4-byte): <code>0b000000</code> (11)</li>
<li>Data (11-byte): <code>68656c6c6f20776f726c64</code> (&quot;hello world&quot;)</li>
</ul>
</li>
</ul>
</li>
<li>Nonce (8-byte): <code>ce6d000000000000</code> (28110)</li>
</ul>
<h1 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h1>
<p>Instead of creating a layered approach, we could have simply created a flat transaction message that is tailored to mutate the ledger state, and try to fit all the use cases there. For example, with the indexed data use case, we could have filled some section of the transaction with that particular data. Then, this transaction would not correspond to a ledger mutation but instead only carry data.</p>
<p>This approach seems less extensible. It might have made sense if we had wanted to build a protocol that is just for ledger mutating transactions, but we want to be able to extend the protocol to do more than that.</p>
<h1 id="copyright-5"><a class="header" href="#copyright-5">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 7
title: Transaction Payload
description: UTXO-based transaction structure
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/18
status: Active
type: Standards
layer: Core
created: 2020-07-10
</pre>
<h1 id="summary-5"><a class="header" href="#summary-5">Summary</a></h1>
<p>In the current IOTA protocol, transactions are grouped into so-called bundles to assure that they can only be confirmed as one unit. This TIP proposes a new UTXO-based transaction structure containing all the inputs and outputs of a transfer. Specifically, this TIP defines a transaction payload for the <em>messages</em> described in the IOTA protocol <a href="tips/TIP-0007/../TIP-0006/tip-0006.html">TIP-6</a>.</p>
<h1 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h1>
<p>Currently, the vertices of the Tangle are represented by transactions, where each transaction defines either an input or output. A grouping of those input/output transaction vertices makes up a bundle which transfers the given values as an atomic unit (the entire bundle is applied or none of it). An applied bundle consumes the input transactions' funds and creates the corresponding deposits into the output transactions' target addresses. Furthermore, additional meta transactions can be part of the bundle to carry parts of the signature which do not fit into a single input transaction.</p>
<p>The bundle concept has proven to be very challenging in practice because of the following issues:</p>
<ul>
<li>Since the data making up the bundle is split across multiple vertices, it complicates the validation of the entire transfer. Instead of being able to immediately tell whether a bundle is valid or not, a node implementation must first collect all parts of the bundle before any actual validation can happen. This increases the complexity of the node implementation.</li>
<li>Reattaching the tail transaction of a bundle causes the entire transfer to be reapplied.</li>
<li>Due to the split across multiple transaction vertices and having to do PoW for each of them, a bundle might already be lazy in terms of where it attaches, reducing its chances to be confirmed.</li>
</ul>
<p>To fix the problems mentioned above and to create a more flexible transaction structure, the goal is to achieve a self-contained transaction structure defining the data of the entire transfer as a payload to be embedded into a message.</p>
<p>The new transaction structure should fulfil the following criteria:</p>
<ul>
<li>Support for Ed25519 (and thus reusable addresses).</li>
<li>Support for adding new types of signature schemes, addresses, inputs, and outputs as part of protocol upgrades.</li>
<li>Self-contained, as in being able to validate the transaction immediately after receiving it.</li>
<li>Enable unspent transaction outputs (UTXO) as inputs instead of an account based model.</li>
</ul>
<h1 id="detailed-design-5"><a class="header" href="#detailed-design-5">Detailed design</a></h1>
<h2 id="utxo"><a class="header" href="#utxo">UTXO</a></h2>
<p>The <em>unspent transaction output</em> (UTXO) model defines a ledger state where balances are not directly associated to addresses but to the outputs of transactions. In this model, transactions reference outputs of previous transactions as inputs, which are consumed (removed) to create new outputs. A transaction must consume all the funds of the referenced inputs.</p>
<p>Using a UTXO based model provides several benefits:</p>
<ul>
<li>Parallel validation of transactions.</li>
<li>Easier double-spend detection, since conflicting transactions would reference the same UTXO.</li>
<li>Replay-protection which is important when having reusable addresses. Replaying the same transaction would manifest itself as already being applied or existent and thus not have any impact.</li>
<li>Technically seen, balances are no longer associated to addresses which raises the level of abstraction and thus enables other types of outputs with particular unlock criteria.</li>
</ul>
<p>Within a transaction using UTXOs, inputs and outputs make up the to-be-signed data of the transaction. The section unlocking the inputs is called the <em>unlock block</em>. An unlock block may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="tips/TIP-0007/utxo.png" alt="UTXO flow" /></p>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<h3 id="serialized-layout-1"><a class="header" href="#serialized-layout-1">Serialized layout</a></h3>
<p>A <em>Transaction Payload</em> is made up of two parts:</p>
<ol>
<li>The <em>Transaction Essence</em> part which contains the inputs, outputs and an optional embedded payload.</li>
<li>The <em>Unlock Blocks</em> which unlock the inputs of the <em>Transaction Essence</em>. When an unlock block contains a signature, it signs the entire <em>Transaction Essence</em> part.</li>
</ol>
<p>All values are serialized in little-endian encoding. The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence.</p>
<p>The <em>Transaction ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized payload data including signatures.</p>
<p>The following table structure describes the entirety of a <em>Transaction Payload</em> in its serialized form:</p>
<ul>
<li>Data Type Notation, see <a href="tips/TIP-0007/../TIP-0006/tip-0006.html#data-types">TIP-6</a></li>
<li><details>
  <summary>Subschema Notation</summary>
  <table>
      <tr>
          <th>Name</th>
          <th>Description</th>
      </tr>
      <tr>
          <td><code>oneOf</code></td>
          <td>One of the listed subschemas.</td>
      </tr>
      <tr>
          <td><code>optOneOf</code></td>
          <td>Optionally one of the listed subschemas.</td>
      </tr>
      <tr>
          <td><code>anyOf</code></td>
          <td>Any (one or more) of the listed subschemas.</td>
      </tr>
  </table>
</li>
</ul>
</details>
<p></p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>
      Set to <strong>value 0</strong> to denote a <i>Transaction Payload</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Transaction Essence</summary>
        <blockquote>
          Describes the essence data making up a transaction by defining its inputs, outputs and an optional payload.
        </blockquote>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Transaction Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Transaction Essence</i>.
            </td>
          </tr>
          <tr>
            <td>Inputs Count</td>
            <td>uint16</td>
            <td>The number of input entries.</td>
          </tr>
          <tr>
            <td valign="top">Inputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>UTXO Input</summary>
                <blockquote>
                  Describes an input which references an unspent transaction output to consume.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Transaction ID</td>
                    <td>ByteArray[32]</td>
                    <td>The BLAKE2b-256 hash of the transaction payload containing the referenced output.</td>
                  </tr>
                  <tr>
                    <td>Transaction Output Index</td>
                    <td>uint16</td>
                    <td>The output index of the referenced output.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Outputs Count</td>
            <td>uint16</td>
            <td>The number of output entries.</td>
          </tr>
          <tr>
            <td valign="top">Outputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>SigLockedSingleOutput</summary>
                <blockquote>
                  Describes a deposit to a single address which is unlocked via a signature.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
              <details>
                <summary>SigLockedDustAllowanceOutput</summary>
                <blockquote>
                  Describes a deposit which as a special property also alters the dust allowance of the target address.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
          <tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Unlock Blocks Count</td>
    <td>uint16</td>
     <td>The number of unlock block entries. It must match the field <code>Inputs Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Unlock Blocks <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Signature Unlock Block</summary>
        <blockquote>
          Defines an unlock block containing a signature.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td valign="top">Signature <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Signature</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Signature Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Public key</td>
                    <td>ByteArray[32]</td>
                    <td>The Ed25519 public key of the signature.</td>
                  </tr>
                  <tr>
                    <td>Signature</td>
                    <td>ByteArray[64]</td>
                    <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
        </table>
      </details>
      <details open="true">
        <summary>Reference Unlock Block</summary>
        <blockquote>
          References a previous unlock block, where the same unlock block can be used for multiple inputs.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td>Reference</td>
            <td>uint16</td>
            <td>Represents the index of a previous unlock block.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h3 id="transaction-parts"><a class="header" href="#transaction-parts">Transaction parts</a></h3>
<p>In general, all parts of a <i>Transaction Payload</i> begin with a byte describing the type of the given part. This improves the flexibility to introduce new types/versions of the given part in the future.</p>
<h4 id="transaction-essence-data"><a class="header" href="#transaction-essence-data">Transaction Essence data</a></h4>
<p>The <i>Transaction Essence</i> of a <i>Transaction Payload</i> carries the inputs, outputs, and an optional payload. The <i>Transaction Essence</i> is an explicit type and therefore starts with its own <i>Transaction Essence Type</i> byte which is of value 0.</p>
<h5 id="inputs"><a class="header" href="#inputs">Inputs</a></h5>
<p>The <i>Inputs</i> part holds the inputs to consume in order to fund the outputs of the <i>Transaction Payload</i>. Currently, there is only one type of input, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each input must be accompanied by a corresponding <i>Unlock Block</i> at the same index in the <i>Unlock Blocks</i> part of the <i>Transaction Payload</i>.</p>
<h6 id="utxo-input"><a class="header" href="#utxo-input">UTXO Input</a></h6>
<p>A <i>UTXO Input</i> is an input which references an unspent output of a previous transaction. This UTXO is uniquely defined by the <em>Transaction ID</em> of that transaction together with corresponding output index. Each <i>UTXO Input</i> must be accompanied by an <i>Unlock Block</i> that is allowed to unlock the output the <i>UTXO Input</i> is referencing.</p>
<p>Example:
If the input references an output to an Ed25519 address, then the corresponding unlock block must be of type <i>Signature Unlock Block</i> holding an Ed25519 signature.</p>
<h5 id="outputs"><a class="header" href="#outputs">Outputs</a></h5>
<p>The <i>Outputs</i> part holds the outputs that are created by this <i>Transaction Payload</i>. The following output types are supported:</p>
<h6 id="siglockedsingleoutput"><a class="header" href="#siglockedsingleoutput">SigLockedSingleOutput</a></h6>
<p>The <i>SigLockedSingleOutput</i> defines an output (with a certain amount) to a single target address which is unlocked via a signature proving ownership over the given address. This output supports addresses of different types.</p>
<h6 id="siglockeddustallowanceoutput"><a class="header" href="#siglockeddustallowanceoutput">SigLockedDustAllowanceOutput</a></h6>
<p>The <i>SigLockedDustAllowanceOutput</i> works in the same way as a <i>SigLockedSingleOutput</i> but additionally controls the dust allowance on the target address. See <a href="tips/TIP-0007/../TIP-0014/tip-0014.html">TIP-14</a> for further information.</p>
<h5 id="payload"><a class="header" href="#payload">Payload</a></h5>
<p>The  <em>Transaction Essence</em> itself can contain another payload as described in general in  <a href="tips/TIP-0007/../TIP-0006/tip-0006.html">TIP-6</a>. The <a href="tips/TIP-0007/tip-0007.html#semantic-validation">semantic validity</a> of the encapsulating <em>Transaction Payload</em> does not have any impact on the payload.</p>
<p>The following table lists all the payload types that can be nested inside a <em>Transaction Essence</em> as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Indexation</td><td>2</td><td><a href="tips/TIP-0007/../TIP-0006/tip-0006.html#indexation-payload">TIP-6</a></td></tr>
</tbody></table>
</div>
<h4 id="unlock-blocks"><a class="header" href="#unlock-blocks">Unlock Blocks</a></h4>
<p>The <i>Unlock Blocks</i> part holds the unlock blocks unlocking inputs within a <i>Transaction Essence</i>. The following types of unlock blocks are supported:</p>
<h5 id="signature-unlock-block"><a class="header" href="#signature-unlock-block">Signature Unlock Block</a></h5>
<p>A <i>Signature Unlock Block</i> defines an <i>Unlock Block</i> which holds a signature signing the BLAKE2b-256 hash of the <i>Transaction Essence</i> (including the optional payload).</p>
<h5 id="reference-unlock-block"><a class="header" href="#reference-unlock-block">Reference Unlock block</a></h5>
<p>A <i>Reference Unlock Block</i> defines an <i>Unlock Block</i> which references a previous <i>Unlock Block</i> (which must not be another <i>Reference Unlock Block</i>). It <strong>must</strong> be used if multiple inputs can be unlocked via the same <i>Unlock Block</i>.</p>
<p>Example:
Consider a <i>Transaction Essence</i> containing the <i>UTXO Inputs</i> 0, 1 and 2, where 0 and 2 are both spending outputs belonging to the same Ed25519 address A and 1 is spending from a different address B. This results in the following structure of the <i>Unlock Blocks</i> part:</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>Unlock Block</th></tr></thead><tbody>
<tr><td>0</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address A.</td></tr>
<tr><td>1</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address B.</td></tr>
<tr><td>2</td><td>A <em>Reference Unlock Block</em> which references 0, as both require the same signature for A.</td></tr>
</tbody></table>
</div>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>A <i>Transaction Payload</i> has different validation stages, since some validation steps can only be executed when certain information has (or has not) been received. We therefore distinguish between syntactic and semantic validation:</p>
<h3 id="syntactic-validation"><a class="header" href="#syntactic-validation">Syntactic validation</a></h3>
<p>Syntactic validation is checked as soon as the transaction data has been received in its entirety. It validates the structure but not the signatures of the transaction. If the transaction does not pass this stage, it must not be broadcasted further and can be discarded right away.</p>
<p>The following criteria defines whether a payload passes the syntactical validation:</p>
<ul>
<li>Essence:
<ul>
<li><code>Transaction Type</code> value must denote a <em>Transaction Essence</em>.</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Input Type</code> must denote a <em>UTXO Input</em>.</li>
<li><code>Transaction Output Index</code> must be 0 ≤ x &lt; 127.</li>
</ul>
</li>
<li><code>Inputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each pair of <code>Transaction ID</code> and <code>Transaction Output Index</code> must be unique in the inputs set.</li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Output Type</code> must denote a <em>SigLockedSingleOutput</em> or a <em>SigLockedDustAllowanceOutput</em>.</li>
<li><code>Address Type</code> must denote an <em>Ed25519 Address</em>.</li>
<li><code>Amount</code> must be larger than zero.</li>
</ul>
</li>
<li><code>Outputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each <code>Address</code> must be unique per output type. For example, a <em>SigLockedSingleOutput</em> and a <em>SigLockedDustAllowanceOutput</em> can have the same address, but not two <em>SigLockedSingleOutputs</em>.</li>
<li>The sum of all <code>Amount</code> fields must not exceed the total IOTA supply of 2,779,530,283,277,761.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0007/tip-0007.html#payload">Payload</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
</ul>
</li>
<li>Unlock Blocks:
<ul>
<li><code>Unlock Blocks Count</code> must match <code>Inputs Count</code> of the <em>Transaction Essence</em>.</li>
<li>Each <code>Unlock Type</code> must denote a <em>Signature Unlock Block</em> or a <em>Reference Unlock Block</em>.</li>
<li>Each <em>Signature Unlock Block</em> must contain an <em>Ed25519 Signature</em>.</li>
<li>Each <em>Signature Unlock Block</em> must be unique.</li>
<li>A <em>Reference Unlock Block</em> at index i must have <code>Reference</code> &lt; i and the unlock block at index <code>Reference</code> must be a <em>Signature Unlock Block</em>.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Transaction Payload</em> must consume the entire byte array of the <code>Payload</code> field of the encapsulating object.</li>
</ul>
<p><sup>1</sup> ensures that serialization of the transaction becomes deterministic, meaning that libraries always produce the same bytes given the logical transaction.</p>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic validation</a></h3>
<p>The Semantic validation of a <em>Transaction Payload</em> is performed when its encapsulating message is confirmed by a milestone. The semantic validity of transactions depends on the order in which they are processed. Thus, it is necessary that all the nodes in the network perform the checks in the same order, no matter the order in which the transactions are received. This is assured by using the White-Flag ordering as described in  <a href="tips/TIP-0007/../TIP-0002/tip-0002.html#deterministically-ordering-the-tangle">TIP-2</a>.</p>
<p>Processing transactions according to the White-Flag ordering enables users to spend UTXOs which are created in the same milestone confirmation cone, as long as the spending transaction comes after the funding transaction in the aforementioned White-Flag order. In this case, it is recommended that users include the <em>Message ID</em> of the funding transaction as a parent of the message containing the spending transaction.</p>
<p>The following criteria defines whether a payload passes the semantic validation:</p>
<ul>
<li>Each input must reference a valid UTXO, i.e. the output referenced by the input's <code>Transaction ID</code> and <code>Transaction Output Index</code> is known (booked) and unspent.</li>
<li>The transaction must spend the entire balance, i.e. the sum of the <code>Amount</code> fields of all the UTXOs referenced by inputs must match the sum of the <code>Amount</code> fields of all outputs.</li>
<li>Each unlock block must be valid with respect to the UTXO referenced by the input of the same index:
<ul>
<li>If it is a <em>Signature Unlock Block</em>:
<ul>
<li>The <code>Signature Type</code> must match the <code>Address Type</code> of the UTXO, </li>
<li>the BLAKE2b-256 hash of <code>Public Key</code> must match the <code>Address</code> of the UTXO and</li>
<li>the <code>Signature</code> field must contain a valid signature for <code>Public Key</code>.</li>
</ul>
</li>
<li>If it is a <em>Reference Unlock Block</em>, the referenced <em>Signature Unlock Block</em> must be valid with respect to the UTXO.</li>
</ul>
</li>
</ul>
<p>If a <em>Transaction Payload</em> passes the semantic validation, its referenced UTXOs must be marked as spent and its new outputs must be created/booked in the ledger. The <em>Message ID</em> of the message encapsulating the processed payload then also becomes part of the input for the White-Flag Merkle tree hash of the confirming milestone (<a href="tips/TIP-0007/../TIP-0004/tip-0004.html">TIP-4</a>).</p>
<p>Transactions that do not pass semantic validation are ignored. Their UTXOs are not marked as spent and their outputs are not booked in the ledger.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="transaction-timestamps"><a class="header" href="#transaction-timestamps">Transaction timestamps</a></h3>
<p>Since transaction timestamps – whether they are signed or not – do not provide any guarantee of correctness, they have been left out of the <em>Transaction Payload</em>. Applications relying on some notion of time for transactions can use the local solidification time or the global timestamp of the confirming milestone (<a href="tips/TIP-0007/../TIP-0008/tip-0008.html">TIP-6</a>).</p>
<h3 id="address-reuse"><a class="header" href="#address-reuse">Address reuse</a></h3>
<p>While, in contrast to Winternitz one-time signatures (W-OTS), producing multiple Ed25519 signatures for the same private key and address does not decrease its security, it still drastically reduces the privacy of users. It is thus considered best practice that applications and services create a new address per deposit to circumvent these privacy issues.</p>
<p>In essence, Ed25519 support allows for smaller transaction sizes and to safely spend funds which were sent to an already used deposit address. Ed25519 addresses are not meant to be used like email addresses. See this <a href="https://en.bitcoin.it/wiki/Address_reuse">Bitcoin wiki article</a> for further information.</p>
<h1 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h1>
<ul>
<li>The new transaction format is the core data type within the IOTA ecosystem. Changing it means that all projects need to accommodate it, including wallets, web services, client libraries and applications using IOTA in general. It is not possible to keep these changes backwards compatible, meaning that all nodes must upgrade to further participate in the network.</li>
<li>Additionally, local snapshots can no longer be represented by a list of addresses and their balances, since the ledger is now made up of the UTXOs on which the actual funds reside. Therefore, local snapshot file schemes have to be adjusted to incorporate the transaction hashes, output indices, and then the destination addresses including the balances.</li>
</ul>
<h1 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h1>
<ul>
<li>Introducing this new transaction structure allows for extensions in the future, to accommodate new requirements. With the support for Ed25519 addresses/signatures, transaction size is drastically reduced and allows for safe re-signing in case of address reuse. Due to the switch to a complete binary transaction, the transaction size is reduced even further, saving network bandwidth and processing time.</li>
<li>Other transaction structures have been considered but they would have misused existing transaction fields to accommodate for new features, instead of putting them into a proper descriptive structure. Additionally, those ideas would not have been safe against replay attacks, which deems reusing the old transaction structure, for example for Ed25519 addresses/signatures, as infeasible.</li>
<li>Not switching to the new transaction structure described in this RFC would have led to more people losing funds because of W-OTS address reuse and it would prevent extending the IOTA protocol further down the line.</li>
</ul>
<h1 id="copyright-6"><a class="header" href="#copyright-6">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 8
title: Milestone Payload
description: Coordinator issued milestone structure with Ed25519 authentication
author: Angelo Capossele (@capossele) <angelo.capossele@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/19
status: Active
type: Standards
layer: Core
created: 2020-07-28
</pre>
<h1 id="summary-6"><a class="header" href="#summary-6">Summary</a></h1>
<p>In IOTA, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC proposes a milestone payload for the messages described in the IOTA protocol <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a>. It uses Edwards-curve Digital Signature Algorithm (EdDSA) to authenticate the milestones.</p>
<h1 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h1>
<p>In the current IOTA protocol, milestones are authenticated using a ternary Merkle signature scheme. In the Chrysalis update, ternary transactions are replaced with binary messages containing different payload types. In order to address these new requirements, this RFC proposes the use of a dedicated payload type for milestones. It contains the same essential data fields that were previously included in the milestone bundle. Additionally, this document also describes how Ed25519 signatures are used to assure authenticity of the issued milestones. In order to make the management and security of the used private keys easier, simple multisignature features with support for key rotation have been added.</p>
<h1 id="detailed-design-6"><a class="header" href="#detailed-design-6">Detailed design</a></h1>
<p>The <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the <em>Milestone Essence</em>, consisting of the actual milestone information (like its index number or position in the tangle), is signed using the Ed25519 signature scheme as described in the IRTF <a href="https://tools.ietf.org/html/rfc8032">RFC 8032</a>. It uses keys of 32 bytes, while the generated signatures are 64 bytes.</p>
<p>To increase the security of the design, a milestone can (optionally) be independently signed by multiple keys at once. These keys should be operated by detached signature provider services running on independent infrastructure elements. This assist in mitigating the risk of an attacker having access to all the key material necessary for forging milestones. While the Coordinator takes responsibility for forming Milestone Payload Messages, it delegates signing in to these providers through an ad-hoc RPC connector. Mutual authentication should be enforced between the Coordinator and the signature providers: a <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">client-authenticated TLS handshake</a> scheme is advisable. To increase the flexibility of the mechanism, nodes can be configured to require a quorum of valid signatures to consider a milestone as genuine.</p>
<p>In addition, a key rotation policy can also be enforced by limiting key validity to certain milestone intervals. Accordingly, nodes need to know which public keys are applicable for which milestone index. This can be provided by configuring a list of entries consisting of the following fields:</p>
<ul>
<li><em>Index Range</em> providing the interval of milestone indices for which this entry is valid. The interval must not overlap with any other entry.</li>
<li><em>Applicable Public Keys</em> defining the set of valid public keys.</li>
<li><em>Signature Threshold</em> specifying the minimum number of valid signatures. Must be at least one and not greater than the number of <em>Applicable Public Keys</em>.</li>
</ul>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p>All values are serialized in little-endian encoding. The serialized form of the milestone is deterministic, meaning the same logical milestone always results in the same serialized byte sequence.</p>
<p>The following table structure describes the entirety of a <em>Milestone Payload</em> in its serialized form (<a href="tips/TIP-0008/../TIP-0006/tip-0006.html#data-types">TIP-6 Data Types</a>):</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Milestone Payload</i>.</td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Milestone Essence</summary>
        <blockquote>Describes the signed part of a <i>Milestone Payload</i>.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Index Number</td>
            <td>uint32</td>
            <td>The index number of the milestone.</td>
          </tr>
          <tr>
            <td>Timestamp</td>
            <td>uint64</td>
            <td>The Unix time (seconds since Unix epoch) at which the milestone was issued.</td>
          </tr>
          <tr>
            <td>Parents Count</td>
            <td>uint8</td>
            <td>The number of messages that are directly approved.</td>
          </tr>
          <tr>
            <td valign="top">Parents <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Parent</summary>
                <blockquote>
                  References another directly approved message.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Message ID</td>
                    <td>ByteArray[32]</td>
                    <td>The Message ID of the parent.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inclusion Merkle Root</td>
            <td>ByteArray[32]</td>
            <td>The Merkle tree hash (BLAKE2b-256) of the message IDs of all the not-ignored state-mutating transaction payloads referenced by the milestone (<a href="https://iotaledger.github.io/protocol-rfcs/0012-milestone-merkle-validation/0012-milestone-merkle-validation.html">RFC-0012</a>).</td>
          </tr>
          <tr>
            <td>Next PoW Score</td>
            <td>uint32</td>
            <td>The new PoW score all messages should adhere to. If 0 then the PoW score should not change.</td>
          </tr>
          <tr>
            <td>Next PoW Score Milestone Index</td>
            <td>uint32</td>
            <td>The index of the first milestone that will require a new minimal pow score for applying transactions. This field comes into effect only if the <code>Next PoW Score</code> field is not 0.</td>
          </tr>
          <tr>
            <td>Keys Count</td>
            <td>uint8</td>
            <td>Number of public keys entries.</td>
          </tr>
          <tr>
            <td valign="top">Keys <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Public Key</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Public Key</td>
                    <td>ByteArray[32]</td>
                    <td>The public key of the Ed25519 keypair which is used to verify the correspondig signature.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
          <tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Signatures Count</td>
    <td>uint8</td>
    <td>Number of signature entries. The number must match the field <code>Keys Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Signatures <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Raw Ed25519 Signature</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature signing the BLAKE2b-256 hash of the serialized <i>Milestone Essence</i>. The signatures must be in the same order as the specified public keys.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<ul>
<li>Generate a new <em>Milestone Essence</em> corresponding to the Coordinator milestone.</li>
<li>Transmit the serialized <em>Milestone Essence</em> to the corresponding number of signature service providers.
<ul>
<li>The signature provider service will sign the received serialized bytes as-is.</li>
<li>The signature provider will serialize the signature bytes and return them to the Coordinator.</li>
</ul>
</li>
<li>Fill the <code>Signatures</code> field of the milestone payload with the received signature bytes.</li>
<li>Generate a <em>Message</em> as defined in <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a> using the same <code>Parents</code> as in the created <em>Milestone Payload</em>.</li>
</ul>
<h2 id="syntactical-validation"><a class="header" href="#syntactical-validation">Syntactical validation</a></h2>
<ul>
<li><code>Parents</code> of the payload must match <code>Parents</code> of the encapsulating <em>Message</em>.</li>
<li>PoW score:
<ul>
<li>If <code>Next Pow Score</code> is zero, <code>Next PoW Score Milestone Index</code> must also be zero.</li>
<li>Otherwise <code>Next PoW Score Milestone Index</code> must be larger than <code>Index Number</code>.</li>
</ul>
</li>
<li>Keys:
<ul>
<li><code>Keys Count</code> must be at least the <em>Signature Threshold</em> and at most the number of <em>Applicable Public Keys</em> for the current milestone index.</li>
<li><code>Keys</code> must be sorted in lexicographical order.</li>
<li>Each <code>Public Key</code> must be unique.</li>
<li><code>Keys</code> must form a subset of the <em>Applicable Public Keys</em> for the current milestone index.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="tips/TIP-0008/tip-0008.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li>Signatures:
<ul>
<li><code>Signatures Count</code> must match <code>Keys Count</code>.</li>
<li><code>Signature</code> at index i must be valid with respect to the <code>Public Key</code> at the same index.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Milestone Payload</em> must consume the entire byte array of the <code>Payload</code> field of the <em>Message</em>.</li>
</ul>
<h3 id="payloads-1"><a class="header" href="#payloads-1">Payloads</a></h3>
<p>The  <em>Milestone Payload</em> itself can contain another payload as described in general in <a href="tips/TIP-0008/../TIP-0006/tip-0006.html">TIP-6</a>. The following table lists all the payloads types that can be nested inside a <em>Milestone Payload</em> as well as links to the corresponding specification:</p>
<div class="table-wrapper"><table><thead><tr><th>Payload Name</th><th>Type Value</th><th>TIP</th></tr></thead><tbody>
<tr><td>Receipts</td><td>4</td><td><a href="tips/TIP-0008/../TIP-0015/tip-0015.html#receipts">TIP-15</a></td></tr>
</tbody></table>
</div>
<h1 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h1>
<ul>
<li>Instead of using EdDSA we could have chosen ECDSA. Both algorithms are well supported and widespread. However, signing with ECDSA requires fresh randomness while EdDSA does not. Especially in the case of milestones where essences are signed many times using the same key, this is a crucial property.</li>
<li>Due to the layered design of messages and payloads, it is practically not possible to prevent reattachments of <em>Milestone Payloads</em>. Hence, this payload has been designed in a way to be independent from the message it is contained in. A milestone should be considered as a virtual marker (referencing <code>Parents</code>) rather than an actual message in the Tangle. This concept is compatible with reattachments and supports a cleaner separation of the message layers.</li>
<li>Forcing matching <code>Parents</code> in the <em>Milestone Payload</em> and its <em>Message</em> makes it impossible to reattach the same payload at different positions in the Tangle. This does not prevent reattachments in general (a different, valid <code>Nonce</code>, for example would lead to a new Message ID) and it violates a strict separation of payload and message. However, it simplifies milestone processing as the position of the <em>Message</em> will be the same as the possition encoded in the <em>Milestone Payload</em>. Having this clear structural properties seem to be more desirable than a strict separation of layers.</li>
</ul>
<h1 id="copyright-7"><a class="header" href="#copyright-7">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 9
title: Local Snapshot File Format
description: File format to export/import ledger state 
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/25
status: Active
type: Standards
layer: Interface
created: 2020-08-25
</pre>
<h1 id="summary-7"><a class="header" href="#summary-7">Summary</a></h1>
<p>This RFC defines a file format for local snapshots which is compatible with Chrysalis Phase 2.</p>
<h1 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h1>
<p>Nodes create local snapshots to produce ledger representations at a point in time of a given milestone to be able to:</p>
<ul>
<li>Start up from a recent milestone instead of having to synchronize from the genesis transaction.</li>
<li>Delete old transaction data below a given milestone.</li>
</ul>
<p>Current node implementations use a <a href="https://github.com/iotaledger/iri-ls-sa-merger/tree/351020d3b5e342b6e9a41f2868575ab7ff8c251c#generating-an-export-file-from-a-localsnapshots-db">local snapshot file format</a> which only works with account based ledgers. For Chrysalis Phase 2, this file format has to be assimilated to support a
UTXO based ledger.</p>
<h1 id="detailed-design-7"><a class="header" href="#detailed-design-7">Detailed design</a></h1>
<p>Since a UTXO based ledger is much larger in size, this RFC proposes two formats for snapshot files:</p>
<ul>
<li>A <code>full</code> format which represents a complete ledger state.</li>
<li>A <code>delta</code> format which only contains diffs (created and consumed outputs) of milestones from a given milestone index onwards.</li>
</ul>
<p>This separation allows nodes to swiftly create new delta snapshot files, which then can be distributed with a companion full snapshot file to reconstruct a recent state.</p>
<p>Unlike the current format, these new formats do not include spent addresses since this information is no longer held by nodes.</p>
<h3 id="formats"><a class="header" href="#formats">Formats</a></h3>
<blockquote>
<p>All types are serialized in little-endian</p>
</blockquote>
<h4 id="full-ledger-state"><a class="header" href="#full-ledger-state">Full Ledger State</a></h4>
<p>A full ledger snapshot file contains the UTXOs (<code>outputs</code> section) of a node's confirmed
milestone (<code>ledger_milestone_index</code>). The <code>diffs</code> contain the diffs to rollback the <code>outputs</code> state to regain the ledger state of the snapshot milestone at (<code>seps_milestone_index</code>).</p>
<p><img src="tips/TIP-0009/diffs_1.png" alt="" /></p>
<p>While the node producing such a full ledger state snapshot could theoretically pre-compute the actual snapshot milestone state, this is deferred to the consumer of the data to speed up local snapshot creation.</p>
<h4 id="delta-ledger-state"><a class="header" href="#delta-ledger-state">Delta Ledger State</a></h4>
<p>A delta ledger state local snapshot only contains the <code>diffs</code> of milestones starting from a
given <code>ledger_milestone_index</code>. A node consuming such data must know the state of the ledger at <code>ledger_milestone_index</code>.</p>
<p><img src="tips/TIP-0009/diffs_2.png" alt="" /></p>
<h4 id="schema"><a class="header" href="#schema">Schema</a></h4>
<h5 id="output"><a class="header" href="#output">Output</a></h5>
<p>Defines an output.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Message Hash</td>
        <td>Array<byte>[32]</td>
        <td>The hash of the message in which the transaction was contained which generated this output.</td>
    </tr>
    <tr>
        <td>Transaction hash</td>
        <td>Array<byte>[32]</td>
        <td>The hash of the transaction which generated this output.</td>
    </tr>
    <tr>
        <td>Output index</td>
        <td>uint16</td>
        <td>The index of this output within the transaction.</td>
    </tr>
    <tr>
        <td valign="top">Output <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>SigLockedSingleDeposit</summary>
                <table>
                    <tr>
                        <td><b>Name<b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Output Type</td>
                        <td>byte</td>
                        <td>Set to <strong>value 0</strong> to denote a <i>SigLockedSingleDeposit</i>.</td>
                    </tr>
                    <tr>
                        <td valign="top">Address <code>oneOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>Ed25519 Address</summary>
                                <table>
                                    <tr>
                                        <td><b>Name<b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Address Type</td>
                                        <td>byte/varint</td>
                                        <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.</td>
                                    </tr>
                                    <tr>
                                        <td>Address</td>
                                        <td>ByteArray[32]</td>
                                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint64</td>
                        <td>The amount of tokens this output deposits.</td>
                    </tr>
                </table>
            </details>
            <details>                                 
                <summary>SigLockedDustAllowanceDeposit</summary>
                <table>
                    <tr>
                        <td><b>Name<b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Output Type</td>
                        <td>byte</td>
                        <td>Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceDeposit</i>.</td>
                    </tr>
                    <tr>
                        <td valign="top">Address <code>oneOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>Ed25519 Address</summary>
                                <table>
                                    <tr>
                                        <td><b>Name<b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Address Type</td>
                                        <td>byte/varint</td>
                                        <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.</td>
                                    </tr>
                                    <tr>
                                        <td>Address</td>
                                        <td>ByteArray[32]</td>
                                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint64</td>
                        <td>The amount of tokens this output deposits.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<h5 id="milestone-diff"><a class="header" href="#milestone-diff">Milestone Diff</a></h5>
<p>Defines the diff a milestone produced by listing the created/consumed outputs and the milestone payload itself.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Milestone Payload length</td>
        <td>uint32</td>
        <td>Denotes the length of the milestone payload.</td>
    </tr>
    <tr>
        <td>Milestone Payload</td>
        <td>Array<byte>[Milestone Payload length]</td>
        <td>The milestone payload in its serialized binary form.</td>
    </tr>
    <tr>
        <td>
        Treasury Input
        <blockquote>
        only included if milestone contains a receipt
        </blockquote>
        </td>
        <td colspan="2">
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Treasury Input Milestone Hash</td>
                    <td>Array<byte>[32]</td>
                    <td>The hash of the milestone this input references.</td>
                </tr>
                <tr>
                    <td>Treasury Input Amount</td>
                    <td>uint64</td>
                    <td>The amount of this treasury input.</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>Created Outputs Count</td>
        <td>uint64</td>
        <td>The amount of outputs generated with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Created Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td>Consumed Outputs Count</td>
        <td>uint64</td>
        <td>The amount of outputs consumed with this milestone diff.</td>
    </tr>
    <tr>
        <td valign="top">Consumed Outputs <code>anyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="full-snapshot-file-format"><a class="header" href="#full-snapshot-file-format">Full snapshot file format</a></h5>
<p>Defines what a full snapshot file contains.</p>
<table>
    <tr>
        <td><b>Name<b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format.</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 0</b> denotes a full snapshot.</td>
    </tr>
    <tr>
        <td>Timestamp</td>
        <td>uint64</td>
        <td>The UNIX timestamp in seconds of when this snapshot was produced.</td>
    </tr>
    <tr>
        <td>Network ID</td>
        <td>uint64</td>
        <td>The ID of the network to which this snapshot is compatible.</td>
    </tr>
    <tr>
        <td>SEPs milestone index</td>
        <td>uint64</td>
        <td>The milestone index for which the SEPs were generated for.</td>
    </tr>
    <tr>
        <td>Ledger milestone index</td>
        <td>uint64</td>
        <td>The milestone index of which the UTXOs within the snapshot are from.</td>
    </tr>
    <tr>
        <td>SEPs count</td>
        <td>uint64</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Outputs count</td>
        <td>uint64</td>
        <td>The amount of UTXOs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Milestone diffs count</td>
        <td>uint64</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Treasury Output Milestone Hash</td>
        <td>Array<byte>[32]</td>
        <td>The milestone hash of the milestone which generated the treasury output.</td>
    </tr>
    <tr>
        <td>Treasury Output Amount</td>
        <td>uint64</td>
        <td>The amount of funds residing on the treasury output.</td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array<byte>[32]</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Outputs</td>
        <td colspan="2">
            <details>
                <summary>Output</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
</table>
<h5 id="delta-snapshot-file-format"><a class="header" href="#delta-snapshot-file-format">Delta snapshot file format</a></h5>
<p>Defines what a delta snapshot contains.</p>
<table>
    <tr>
        <td><b>Name<b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Version</td>
        <td>byte</td>
        <td>Denotes the version of this file format.</td>
    </tr>
    <tr>
        <td>Type</td>
        <td>byte</td>
        <td>Denotes the type of this file format. <b>Value 1</b> denotes a delta snapshot.</td>
    </tr>
    <tr>
        <td>Timestamp</td>
        <td>uint64</td>
        <td>The UNIX timestamp in seconds of when this snapshot was produced.</td>
    </tr>
    <tr>
        <td>Network ID</td>
        <td>uint64</td>
        <td>The ID of the network to which this snapshot is compatible.</td>
    </tr>
    <tr>
        <td>SEPs milestone index</td>
        <td>uint64</td>
        <td>The milestone index for which the SEPs were generated for.</td>
    </tr>
    <tr>
        <td>Ledger milestone index</td>
        <td>uint64</td>
        <td>The milestone index up on which this delta snapshot builts up from.</td>
    </tr>
    <tr>
        <td>SEPs count</td>
        <td>uint64</td>
        <td>The amount of SEPs contained within this snapshot.</td>
    </tr>
    <tr>
        <td>Milestone diffs count</td>
        <td>uint64</td>
        <td>The amount of milestone diffs contained within this snapshot.</td>
    </tr>
    <tr>
        <td valign="top">SEPs</td>
        <td colspan="2">
            <details>
                <summary>SEP Array<byte>[32]</summary>
            </details>
        </td>
    </tr>
    <tr>
        <td valign="top">Milestone Diffs</td>
        <td colspan="2">
            <details>
                <summary>Milestone Diff</summary>
            </details>
        </td>
    </tr>
</table>
<h1 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h1>
<p>Nodes need to support this new format.</p>
<h1 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h1>
<ul>
<li>In conjunction with a companion full snapshot, a tool or node can &quot;truncate&quot; the data from a delta snapshot back to a single full snapshot. In that case, the <code>ledger_milestone_index</code> and <code>seps_milestone_index</code> would be the same. In the example above, given the full and delta snapshots, one could produce a new full snapshot for milestone 1350.</li>
<li>Since snapshots may include millions of UTXOs, code generating such files needs to stream data directly onto disk instead of keeping the entire representation in memory. In order to facilitate this, the count denotations for SEPs, UTXOs and diffs are at the beginning of the file. This allows code generating snapshot files to only have to seek back once after the actual count of elements is known.</li>
</ul>
<h1 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h1>
<ul>
<li>Is all the information to startup a node from the local snapshot available with the described format?</li>
</ul>
<h1 id="copyright-8"><a class="header" href="#copyright-8">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 10
title: Mnemonic Ternary Seed
description: Represent ternary seed as a mnemonic sentence
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/10
status: Obsolete
type: Standards
layer: IRC
created: 2020-03-11
</pre>
<h1 id="summary-8"><a class="header" href="#summary-8">Summary</a></h1>
<p>The IOTA protocol uses a 81-tryte seed to derive all the private keys for one account. This RFC describes a method to represent that seed as a mnemonic sentence - a group of easily comprehensible words. </p>
<h1 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h1>
<p>The used seed is a 384-bit or 243-trit random string. There are several ways to represent this in a human-readable form, but a mnemonic sentence is superior to raw binary or ternary strings. These sentences can easily be written down or they can even be recorded  over a phone.
Furthermore, having raw strings tempts the user to copy and paste the seed due to convenience over security. This practice opens new attack vectors such as theft or manipulation of the string in the clipboard.</p>
<h1 id="detailed-design-8"><a class="header" href="#detailed-design-8">Detailed design</a></h1>
<p>The <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-0039</a> specification exactly describes an implementation for its use case and how to uniquely represent binary entropy using mnemonic words. However, it is only defined for binary input of 128 - 256 bits. The section(s) below describe the canonical extension of BIP-0039 for longer inputs of 81 trytes or 384 bits.</p>
<p>The 243-trit (81-tryte) seed is used as input for the <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md">Kerl</a> hash function to derive the private keys. Therefore, it is first converted to a 384-bit string to be absorbed by <a href="https://keccak.team/keccak.html">Keccak-384</a>. As the set of all possible 243-trit strings is larger than the set of 384-bit strings, the most significant trit is fixed to zero before converting. This means that the 243rd of the seed is ignored and does not have any impact on the following key derivation and does not need to be considered for the encoding.</p>
<h3 id="generating-the-mnemonic-from-seed"><a class="header" href="#generating-the-mnemonic-from-seed">Generating the mnemonic from seed</a></h3>
<ul>
<li>Interpret the IOTA seed as a little-endian 243-trit balanced ternary integer; assure that its most significant trit is 0 and encode the number as a 384-bit signed integer in big-endian two's complement representation. <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md#trits---bytes-encoding">This exact conversion</a> is also used as part of the current Kerl hash function.</li>
<li>Compute the <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA-256</a> hash of the resulting bit string and use its first 384/32=12 bits as the checksum.</li>
<li>The 12-bit checksum is appended to the end of the initial result, making it a 396-bit string.</li>
<li>These concatenated bits are split into 36 groups of 11 bits, each encoding a number from 0-2047, corresponding to an index into the wordlist.</li>
<li>Finally, convert these numbers into words from any one of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md">BIP-0039 wordlists</a> and use the joined words as a mnemonic sentence.</li>
</ul>
<h3 id="generating-the-seed-from-mnemonic"><a class="header" href="#generating-the-seed-from-mnemonic">Generating the seed from mnemonic</a></h3>
<ul>
<li>Convert the 36-word mnemonic sentence into its corresponding 396-bit string by taking the 11-bit wordlist index for each word and concatenating all the bits.</li>
<li>Split the resulting bit string into 384-bit entropy and 12-bit checksum.</li>
<li>Verify that the checksum corresponds to the first bits of the SHA-256 hash of the entropy.</li>
<li>Convert the 384-bit entropy, interpreted as a signed integer in big-endian two's complement representation, back to a little-endian 243-trit balanced ternary integer. (The most significant trit will always be zero.) This corresponds to the usual 243-trit or 81-tryte IOTA seed.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li>Using the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">English word list</a>:
<ul>
<li>IOTA seed (81-tryte): <code>TLEV9HDTGZOXIIGA9DZG9VAKAIUZKNIMAFUGGARTWPOGDLLVUFZZVAABXRMFPWJAYWBBHOERV9EZBAOJD</code></li>
<li>mnemonic (36-word): <code>forget small borrow baby wing law monkey fiber jealous canyon melt all order lift now fish mind index neither discover divert fit curtain raw wealth arrow frozen plug catalog public winner emerge pulse mixture cry arch</code></li>
</ul>
</li>
<li>Using the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/japanese.txt">Japanese word list</a>:
<ul>
<li>IOTA seed (81-tryte): <code>KMQDKKLGGTPUBRJXYWLMQOIA9WIEWUAAJPASYPVAWOTYYH9JESDKPLVZIWITHDIUMLFEWQUQ9LHAV9GHC</code></li>
<li>mnemonic (36-word): <code>げどく　まもる　してい　ていへん　つめたい　ちつじょ　だいたい　てうち　まいにち　さゆう　よそく　がはく　ねらう　いちおう　くみあわせ　ふいうち　せつでん　きせい　すべて　きひん　しかい　さぎょう　うけたまわる　つとめる　おんしゃ　きかい　なやむ　たいせつ　うんこう　むすめ　いってい　ふめつ　そとづら　つくね　おいこす　ききて</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h1>
<ul>
<li>This RFC describes a way to represent computer-generated randomness in a human-readable transcription. It is in no way meant to process user created sentences into a binary key. This technique is also sometimes called a &quot;brain wallet&quot; and must not be confused with these mnemonics. </li>
<li>The mnemonics only encode 384 bits of entropy which only covers 242 trits. The 243rd trit will <em>not</em> be encoded and always padded with 0. This is fine, when Kerl is used to derive the private keys, since the Kerl hash function only works on the first 242 trits itself. However, other - currently not used - key derivation functions relying on the full 243-trit entropy are <em>not</em> compatible with this RFC.</li>
</ul>
<h1 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h1>
<ul>
<li>BIP-0039 provides an industry standard to present computer generated, secure entropy in a way that can be &quot;processed&quot; by humans in a much less error-prone way. The word lists are chosen in a way to reduce ambiguity, as such, typos can either be autocorrected or corrected with the help of a dictionary. This is in contrast to a raw ternary (or binary) representation, where typos automatically lead to a completely new seed, changing and breaking all successive private keys.</li>
<li>Thanks to the integrated 12-bit checksum, it is even possible to detect whether one or more words have been exchanged completely.</li>
<li>Presenting the user with a tryte or hex string will lead to situations in which the seed is copied into a text file, while human-readable words encourage the user to copy them on a piece of paper.</li>
</ul>
<h1 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h1>
<ul>
<li>This RFC does not cover usability aspects of entering mnemonics. Forcing the user to enter a mnemonic sentence and then discarding the input, due to one easily correctable typo in one word, would almost be as frustrating as typing a tryte string. Therefore, this must be combined with different usability improvements, e.g. only allowing entering characters that lead to valid words or fixing the word as soon as it can be unambiguously identified.</li>
<li>The BIP-0039 specification includes several word lists for different languages. Should these word lists be allowed or is it sufficient to only use the English list? </li>
<li>The BIP-0039 specification only considers entropy between 128 and 256 bits, while this RFC extends it in an analogue way for 384 bits. Is it also relevant for certain use cases to extend this for 512 bits (or even longer)?</li>
</ul>
<h1 id="reference-implementation-2"><a class="header" href="#reference-implementation-2">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Conversion from mnemonic to seed: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/bip39/bip39.go">pkg/bip39/bip39.go</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/mnemseed">examples/mnemseed</a></li>
</ul>
<h1 id="copyright-9"><a class="header" href="#copyright-9">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 11
title: Bech32 Address Format
description: Extendable address format supporting various signature schemes and address types
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/20
status: Active
type: Standards
layer: Interface
created: 2020-07-28
</pre>
<h1 id="summary-9"><a class="header" href="#summary-9">Summary</a></h1>
<p>This document proposes an extendable address format for the IOTA protocol supporting various signature schemes and address types. It relies on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">Bech32</a> format to provide a compact, human-readable encoding with strong error correction guarantees.</p>
<h1 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h1>
<p>With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, IOTA uses Ed25519 to generate digital signatures, in which addresses correspond to a BLAKE2b-256 hash. It is necessary to define a new universal and extendable address format capable of encoding different types of addresses.</p>
<p>The current IOTA protocol relies on Base27 addresses with a truncated Kerl checksum. However, both the character set and the checksum algorithm have limitations: </p>
<ul>
<li>Base27 is designed for ternary and is ill-suited for binary data.</li>
<li>The Kerl hash function also requires ternary input. Further, it is slow and provides no error-detection guarantees.</li>
<li>It does not support the addition of version or type information to distinguish between different kinds of addresses with the same length.</li>
</ul>
<p>All of these points are addressed in the Bech32 format introduced in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>: In addition to the usage of the human-friendly Base32 encoding with an optimized character set, it implements a <a href="https://en.wikipedia.org/wiki/BCH_code">BCH code</a> that <em>guarantees detection</em> of any error affecting at most four characters and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors.</p>
<p>This RFC proposes a simple and extendable binary serialization for addresses of different types that is then Bech32 encoded to provide a unique appearance for human-facing applications such as wallets. </p>
<h1 id="detailed-design-9"><a class="header" href="#detailed-design-9">Detailed design</a></h1>
<h2 id="binary-serialization"><a class="header" href="#binary-serialization">Binary serialization</a></h2>
<p>The address format uses a simple serialization scheme which consists of two parts:</p>
<ul>
<li>The first byte describes the type of the address.</li>
<li>The remaining bytes contain the type-specific raw address bytes.</li>
</ul>
<p>Currently, only one kind of addresses are supported:</p>
<ul>
<li>Ed25519, where the address consists of the BLAKE2b-256 hash of the Ed25519 public key.</li>
</ul>
<p>They are serialized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First byte</th><th>Address bytes</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>0x00</code></td><td>32 bytes: The BLAKE2b-256 hash of the Ed25519 public key.</td></tr>
</tbody></table>
</div>
<h2 id="bech32-for-human-readable-encoding"><a class="header" href="#bech32-for-human-readable-encoding">Bech32 for human-readable encoding</a></h2>
<p>The human-readable encoding of the address is Bech32 (as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>). A Bech32 string is at most 90 characters long and consists of: </p>
<ul>
<li>The <strong>human-readable part</strong> (HRP), which conveys the IOTA protocol and distinguishes between Mainnet (the IOTA token) and Testnet (testing version):
<ul>
<li><code>iota</code> is the human-readable part for Mainnet addresses</li>
<li><code>atoi</code> is the human-readable part for Testnet addresses</li>
</ul>
</li>
<li>The <strong>separator</strong>, which is always <code>1</code>.</li>
<li>The <strong>data part</strong>, which consists of the Base32 encoded serialized address and the 6-character checksum.</li>
</ul>
<p>Hence, Ed25519-based addresses will result in a Bech32 string of 64 characters.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li><strong>Mainnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Testnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>atoi1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8x4r7t</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h1>
<ul>
<li>The new addresses look fundamentally different from the established 81-tryte IOTA addresses. However, since the switch from binary to ternary and Chrysalis in general is a substantial change, this is a very reasonable and desired consequence.</li>
<li>A four character HRP plus one type byte only leaves a maximum of 48 bytes for the actual address. </li>
</ul>
<h1 id="rationale-and-alternatives-9"><a class="header" href="#rationale-and-alternatives-9">Rationale and alternatives</a></h1>
<ul>
<li>There are several ways to convert the binary serialization into a human-readable format, e.g. Base58 or hexadecimal. The Bech32 format, however, offers the best compromise between compactness and error correction guarantees. A more detailed motivation can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#motivation">BIP-0173 Motivation</a>.</li>
<li>The binary serialization itself must be as compact as possible while still allowing you to distinguish between different address types of the same byte length. As such, the introduction of a version byte offers support for up to 256 different kinds of addresses at only the cost of one single byte.</li>
<li>The HRP of the Bech32 string offers a good opportunity to clearly distinguish IOTA addresses from other Bech32 encoded data. Here, any three or four character ASCII strings can be used. However, selecting <code>iota</code> as well as <code>atoi</code> seems like the most recognizable option.</li>
</ul>
<h1 id="reference-implementation-3"><a class="header" href="#reference-implementation-3">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/pkg/bech32">pkg/bech32</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/bech32">examples/bech32</a></li>
</ul>
<h1 id="copyright-10"><a class="header" href="#copyright-10">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 12
title: Message PoW
description: Define message proof-of-work as a means to rate-limit the network
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/24
status: Active
type: Standards
layer: Core
created: 2020-08-25
</pre>
<h1 id="summary-10"><a class="header" href="#summary-10">Summary</a></h1>
<p>The IOTA protocol uses proof-of-work as a means to rate-limit the network. Currently, the Curl-P-81 trinary hash function is used and is required to provide a hash with the matching number of trailing zero trits to issue a transaction to the Tangle. With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, it will be possible to issue binary messages of arbitrary size. This RFC presents a proposal to adapt the existing PoW mechanism to these new requirements. It aims to be less disruptive to the current PoW mechanism as possible.</p>
<h1 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h1>
<p>In the current IOTA Protocol, each transaction has a fixed size of 8019 trits and is hashed using Curl-P-81 to compute its 243-trit transaction hash, where the PoW's difficulty equals the number of trailing zero trits in that hash.<br>
Unfortunately, the performance of Curl-P-81 is slow, achieving only about 2 MB/s on a single core. This would make the PoW validation a bottleneck, especially for high usage scenarios with larger messages. Thus, this RFC proposes a two-stage approach to speed up the validation process: First, the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash function is used to create a short, fixed length digest of the message. Then, this digest, together with the nonce, is hashed using Curl-P-81. Since the digest only needs to be computed once while iterating over different nonce values, this preserves Curl as the PoW-relevant hash. However, the validation is much faster, as BLAKE2b-256 has a performance of about 1 GB/s and Curl then only needs to be executed for one single 243-trit block of input. Since the input of the final Curl computation is always fixed, parallel Curl variants can be used in this stage to further speed up the validation if necessary.<br>
Furthermore, it is important to note that the time required to do the PoW depends on the PoW difficulty and not on the message length. As such, to treat messages with different lengths differently, we need to weight the PoW difficulty by the message length.</p>
<p>It will be easy to adapt existing hardware and software implementations of the current PoW mechanism to work with the proposed design. Only the input and the position of the nonce in the buffer needs to be adapted. This enables existing Curl projects to continue persisting and also the entire PoW landscape should stay almost the same.</p>
<h1 id="detailed-design-10"><a class="header" href="#detailed-design-10">Detailed design</a></h1>
<p>The PoW score is defined as the average number of iterations required to find the number of trailing zero trits in the hash divided by the message size.</p>
<p>The PoW validation is performed in the following way:</p>
<ul>
<li>Compute the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the serialized message (as described in <a href="tips/TIP-0012/../TIP-0006/tip-0006.html">TIP-6</a>) <em>excluding</em> the 8-byte <code>Nonce</code> field and convert the hash into its 192-trit <code>b1t6</code> encoding. (See <a href="tips/TIP-0012/../TIP-0005/tip-0005.html">TIP-5</a> for a description of the encoding.)</li>
<li>Take the 8-byte <code>Nonce</code> in little-endian representation, convert it into its 48-trit <code>b1t6</code> encoding and append it to the hash trits.</li>
<li>Add a padding of three zero trits to create a 243-trit string.</li>
<li>Compute the Curl-P-81 hash.</li>
<li>Count the number of trailing zero trits in the hash.</li>
<li>Then, the PoW score equals 3<sup>#zeros</sup> / size(message).</li>
</ul>
<p>This can also be summarized with the following pseudocode:</p>
<pre><code>pow_digest ← BLAKE2b-256(serialized message excluding nonce field)
pow_hash ← Curl-P-81(b1t6(pow_digest) || b1t6(nonce) || [0, 0, 0])
pow ← 3**trailing_zeros(pow_hash) / size
</code></pre>
<p>where <code>size</code> is the number of bytes of the full serialized message.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<ul>
<li>Message including nonce (21-byte): <code>48656c6c6f2c20576f726c64215ee6aaaaaaaaaaaa</code></li>
<li>PoW digest (32-byte): <code>511bc81dde11180838c562c82bb35f3223f46061ebde4a955c27b3f489cf1e03</code></li>
<li>Nonce (8-byte): <code>5ee6aaaaaaaaaaaa</code> (12297829382473049694)</li>
<li>Curl input (81-tryte): <code>9C9AYYBATZQAXAH9BBVYQDYYPBDXNDWBHAO9ODPDFZTZTCAWKCLADXO9PWEYCAC9MCAZVXVXVXVXVXVX9</code></li>
<li>PoW hash (81-tryte): <code>DJCAGKILZPLXNXWFTNXFLCHRFVUHHMTPFIOFKQXMGIKITSEVWECMQOKCFXDIIHK9YVHGQICAIVEVDJ999</code></li>
<li>Trailing zeros: 9</li>
<li>PoW score: 3<sup>9</sup> / 21 = 937.2857142857143</li>
</ul>
<h1 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h1>
<ul>
<li>Curl is a ternary hash function that is applied on binary data. This makes it necessary to introduce an additional encoding step. However, the proposed <code>b1t6</code> encoding is reasonably performant. Additionally, hash functions usually contain an encoding step to write the input into their internal state. In that sense, the <code>b1t6</code> encoding is not much different.</li>
<li>One additional trailing zero in the PoW hash effectively allows the message size to be tripled. This could potentially incentivize users to add otherwise unnecessary data, when the PoW difficulty stays the same. Using a binary hash function instead of Curl would only slightly improve this situation as the allowed message length remains exponential in the difficulty parameter.</li>
</ul>
<h1 id="rationale-and-alternatives-10"><a class="header" href="#rationale-and-alternatives-10">Rationale and alternatives</a></h1>
<p>The premise of this proposal is that the PoW should remain Curl-based to cause the least amount of disruption to the protocol and its established projects. Therefore, other hash functions or PoW algorithms have not been considered. However, modifications of the described calculation are possible:</p>
<ul>
<li>There are several potential encodings for the nonce: E.g. converting its value directly to balanced ternary (the most compact encoding) or using the <code>b1t8</code> encoding. The chosen <code>b1t6</code> encoding achieves a nice balance between compactness and performance. Since it is possible to fit the PoW digest and the <code>b1t6</code> encoded nonce into one Curl block, the simplicity of having only one encoding (for PoW digest and nonce) was preferred over minimal performance improvements other encodings could bring.</li>
<li>Curl can be computed directly on the <code>b1t6</code> encoded message (after an appropriate padding has been added). However, performance analysis of existing node implementation suggests that the Curl computations during the PoW could become critical, especially since parallel Curl implementations would be much more difficult to deploy because of the dynamic message lengths.</li>
<li>BLAKE2b-256 could be replaced with BLAKE2b-512 or any other binary cryptographic hash function. However, a 256-bit digest fits very nicely into exactly one Curl block and since BLAKE2b-256 is also used for the <em>message ID</em>, it is reasonable to also use it for the PoW digest. This reduces the number of required hashing implementations and even allows reusage of intermediate values between the PoW digest and the message ID computation.</li>
</ul>
<p>The PoW score formula 3<sup>#zeros</sup> / size(message) could be replaced with an alternative function to better match the network usage, e.g. in order to penalize longer message more than linearly.</p>
<h1 id="reference-implementation-4"><a class="header" href="#reference-implementation-4">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>b1t6 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/encoding/b1t6/b1t6.go">pkg/encoding/b1t6</a></li>
<li>PoW computation: <a href="https://github.com/Wollac/iota-crypto-demo/blob/master/pkg/pow/pow.go">pkg/pow</a></li>
</ul>
<h1 id="copyright-11"><a class="header" href="#copyright-11">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 13
title: REST API
description: Node REST API routes and objects in OpenAPI Specification
author: Samuel Rufinatscha (@rufsam) <samuel.rufinatscha@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/26
status: Active
type: Standards
layer: Interface
created: 2020-09-10
</pre>
<h1 id="summary-11"><a class="header" href="#summary-11">Summary</a></h1>
<p>This document proposes the REST API for nodes supporting the IOTA protocol.</p>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<p>The API is described using the OpenAPI Specification:</p>
<p><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0013/rest-api.yaml">Swagger Editor</a></p>
<h1 id="copyright-12"><a class="header" href="#copyright-12">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 14
title: Ed25519 Validation
description: Adopt https://zips.z.cash/zip-0215 to explicitly define Ed25519 validation criteria
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>, Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/28
status: Active
type: Standards
layer: Core
created: 2020-10-30
</pre>
<h1 id="summary-12"><a class="header" href="#summary-12">Summary</a></h1>
<p>The IOTA protocol uses Ed25519 signatures to assure the authenticity of transactions in Chrysalis. However, although Ed25519 is standardized in <a href="https://tools.ietf.org/html/rfc8032">IETF RFC 8032</a>, it does not define strict validation criteria. As a result, compatible implementations do not need to agree on whether a particular signature is valid or not. While this might be acceptable for classical message signing, it is unacceptable in the context of consensus critical applications like IOTA.</p>
<p>This RFC proposes to adopt <a href="https://zips.z.cash/zip-0215">ZIP-215</a> to explicitly define validation criteria. This mainly involves the following sections of the Ed25519 spec:</p>
<ul>
<li>decoding of elliptic curve points as described in <a href="https://tools.ietf.org/html/rfc8032#section-5.1.3">Section 5.1.3</a></li>
<li>validation itself as described in <a href="https://tools.ietf.org/html/rfc8032#section-5.1.7">Section 5.1.7</a></li>
</ul>
<h1 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h1>
<p>Based on <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a> we know that: </p>
<ol>
<li>Not all implementations follow the decoding rules defined in RFC 8032, but instead accept non-canonically encoded inputs.</li>
<li>The RFC 8032 provides two alternative verification equations, whereas one is stronger than the other. Different implementations use different equations and therefore validation results vary even across implementations that follow the RFC 8032. </li>
</ol>
<p>This lack of consistent validation behavior is especially critical for IOTA as they can cause a breach of consensus across node implementations! For example, one node implementation may consider a particular transaction valid and mutate the ledger state accordingly, while a different implementation may discard the same transaction due to invalidity. This would result in a network fork and could only be resolved outside of the protocol. Therefore, an explicit and unambiguous definition of validation criteria, such as ZIP-215, is necessary.</p>
<p>Furthermore, it is important to note that the holder of the secret key can produce more than one valid distinct signature. Such transactions with the same essence but different signatures are considered as double spends by the consensus protocol and handled accordingly. While this does not pose a problem for the core protocol, it may be a problem for 2nd layer solutions, similar to how <a href="https://en.bitcoinwiki.org/wiki/Transaction_Malleability#How_Does_Transaction_Malleability_Affect_The_Lightning_Network.3F">transaction malleability in bitcoin presented an issue for the lightning network</a>.</p>
<h1 id="detailed-design-11"><a class="header" href="#detailed-design-11">Detailed design</a></h1>
<p>In order to have consistent validation of Ed25519 signatures for all edge cases and throughout different implementations, this RFC proposes explicit validation criteria. These three criteria <strong>must</strong> be checked to evaluate whether a signature is valid.</p>
<p>Using the notation and Ed25519 parameters as described in the RFC 8032, the criteria are defined as follows:</p>
<ol>
<li>Accept non-canonical encodings of A and R.</li>
<li>Reject values for S that are greater or equal than L.</li>
<li>Use the equation [8][S]B = [8]R + [8][k]A' for validation.</li>
</ol>
<p>In the following, we will explain each of these in more detail.</p>
<h2 id="decoding"><a class="header" href="#decoding">Decoding</a></h2>
<p>The Curve25519 is defined over the finite field of order p=2<sup>255</sup>−19. A curve point (x,y) is encoded into its compressed 32-byte representation, namely by the 255-bit encoding of the field element y followed by a single sign bit that is 1 for negative x (see <a href="https://tools.ietf.org/html/rfc8032#section-3.1">RFC 8032, Section 3.1</a>) and 0 otherwise. This approach provides a unique encoding for each valid point. However, there are two classes of edge cases representing non-canonical encodings of valid points:</p>
<ul>
<li>encoding a y-coordinate as y + p</li>
<li>encoding a curve point (0,y) with the sign bit set to 1</li>
</ul>
<p>In contrast to RFC 8032, it is <em>not</em> required that the encodings of A and R are canonical. As long as the corresponding (x,y) is a valid curve point, any of such edge cases will be accepted.</p>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>The RFC 8032 mentions two alternative verification equations:</p>
<ol>
<li>[8][S]B = [8]R + [8][k]A'</li>
<li>[S]B = R + [k]A'</li>
</ol>
<p>Each honestly generated signature following RFC 8032 satisfies the second, cofactorless equation and thus, also the first equation. However, the opposite is not true. This is due to the fact that dishonestly generated nonce R and public key A' might have order other than L. Testing whether a point has order L is costly. The first, cofactored equation accepts more nonces and public keys including dishonestly generated ones but lets us skip costly order checks. This has the impact that each secret key has not one but eight corresponding public keys. However all those public keys correspond to different addresses.<br> There are solutions only satisfying the first equation but not the latter. This ambiguity in RFC 8032 has led to the current situation in which different implementations rely on different verification equations.</p>
<p>Ed25519 also supports batch signature verification, which allows verifying several signatures in a single step, much faster than verifying signatures one-by-one. Without going into detail, there are also two alternative verification equations for the batch verification:<br> [8][∑zᵢsᵢ] B = [8]∑[zᵢ]Rᵢ + [8]∑[zᵢhᵢ]Aᵢ and its corresponding cofactorless version. However, only cofactored verifications, single and batch, are compatible with each other. All other combinations are inconsistent and can lead to false positives or false negatives (see <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a>, Section 3.2) for certain edge-cases introduced by an attacker.<br> Thus, in order to allow batch signature verification and its faster performance in IOTA nodes, the cofactored version <em>must</em> be used for validation, i.e. the group equation [8][S]B = [8]R + [8][k]A' for the single verification.</p>
<p>Since non-canonical encodings of A and R are allowed, it is crucial to also specify which representation must be used for the hash functions:</p>
<ul>
<li>The provided binary encodings of A and R must be used as input to the hash function H instead of their canonical – and potentially different – representation.</li>
<li>During transaction validation, when the public key A is checked against the output's address, the provided binary encoding must be used for the BLAKE2b-256 hash instead of its canonical representation.</li>
</ul>
<h2 id="malleability"><a class="header" href="#malleability">Malleability</a></h2>
<p>The non-negative integer S is encoded into 32 bytes as part of the signature. However, a third party could replace S with S' = S + n·L for any natural n with S' &lt; 2<sup>256</sup> and the modified signature R || S' would still pass verification. Requiring a value less than L resolves this malleability issue. Unfortunately, this check is not present in all common Ed25519 implementations.</p>
<p>Analogous to RFC 8032, the encoding of S <em>must</em> represent an integer less than L.</p>
<p>It is not possible for an external party to mutate R and still pass verification. The owner of the secret key, however, can create many different signatures for the same content: While Ed25519 defines a deterministic method of calculating the integer scalar r from the private key and the message, it is impossible to tell during signature verification if the point R = [r]B was created properly or any other scalar has been used.<br> As a result, there is a practically countless amount of different valid signatures corresponding to a certain message and public key.</p>
<p>We allow users to have a zero-scalar secret key and consider eight corresponding public keys valid. However, users should not use it as it is equivalent to publishing one's secret key. This also has the impact that any valid signature produced with a zero-scalar secret key will authenticate any message thus making it &quot;super&quot;-malleable.</p>
<h2 id="test-vectors"><a class="header" href="#test-vectors">Test vectors</a></h2>
<p>The test vectors are taken directly from <a href="https://eprint.iacr.org/2020/1244">Chalkias et al. 2020</a>. Here, <code>pub_key</code> corresponds to the encoding of A and <code>address</code> is a 33-byte <em>Ed25519 Address</em> as described in <a href="tips/TIP-0014/../TIP-0007/tip-0007.html#serialized-layout">TIP-7</a>. The address is computed by hashing A. As mentioned in the paper, for test case #10 the key A is reduced before hashing, while in the others it is not. The key <code>valid</code> denotes whether the corresponding item represents a valid <code>signature</code> for the provided <code>address</code> and <code>message</code> or not.</p>
<ul>
<li><a href="tips/TIP-0014/test.json">JSON tests</a></li>
</ul>
<h1 id="drawbacks-9"><a class="header" href="#drawbacks-9">Drawbacks</a></h1>
<ul>
<li>Allowing non-canonical encodings is a direct contradiction of RFC 8032 and rather unintuitive. Furthermore, it introduces alternative encodings for a handful of points on the curve. Even though such points will, for all practical purposes, never occur in honest signatures, it still theoretically introduces an external party malleability vector.</li>
<li>The cofactored validation is computationally slightly more expensive than the cofactorless version since it requires a multiplication by 8.</li>
</ul>
<h1 id="rationale-and-alternatives-11"><a class="header" href="#rationale-and-alternatives-11">Rationale and alternatives</a></h1>
<p>In the IOTA protocol, the <em>Transaction ID</em> corresponds to the hash over the entire transaction including the actual signature bytes. Therefore, it is absolutely crucial that (valid) signatures are not malleable by a public attacker, i.e. that the used Ed25519 variant is strongly-unforgeable. Allowing non-canonical point encodings does not introduce the same attack vector. As such, both options would lead to valid Ed25519 variants.</p>
<p>Unfortunately, the Ed25519 <code>ref10</code> reference implementation as well as other implementations accept non-canonical points. As such, rejecting those inputs now would introduce a breaking change. While this might be acceptable for the IOTA protocol itself, since no Ed25519 signatures have been added to the ledger prior to this RFC, other consensus-critical applications require this backward compatibility with previously accepted signatures. Due to these considerations, the criterion was included in ZIP-215 to allow a seamless transition for existing consensus-critical contexts. This RFC aims to rather follow the existing ZIP-215 specification for compatibility and maintainability than to create a new standard.</p>
<p>Using the cofactorless validation poses a similar breaking change since signatures accepted by implementations using the cofactored validation would then be rejected. More importantly, however, in order to be able to use the much faster batch verification, the cofactored version is required. </p>
<h1 id="copyright-13"><a class="header" href="#copyright-13">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 15
title: Dust Protection
description: Prevent bloating the ledger size with dust outputs
author: Gal Rogozinski (@GalRogozinski) <gal.rogozinski@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/32
status: Active
type: Standards
layer: Core
created: 2020-12-07
superseded-by: TIP-19
</pre>
<h1 id="summary-13"><a class="header" href="#summary-13">Summary</a></h1>
<p>In the UTXO model, each node in the network needs to keep track of all the currently unspent outputs. When the number of outputs gets too large, this can cause performance and memory issues.
This RFC proposes a new protocol rule regarding the processing of outputs that transfer a very small amount of IOTA, so-called dust outputs: Dust outputs are only allowed when they are backed up by a certain deposit on the receiving address. This limits the amount of dust outputs, thus making it expensive to proliferate dust. Since a receiver must make a deposit, the protocol makes receiving dust an opt-in feature.</p>
<h1 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h1>
<p>An attacker, or even honest users, can proliferate the UTXO ledger with outputs holding a tiny amount of IOTA coins. This can cause the ledger to grow to a prohibitively large size. </p>
<p>In order to protect nodes from such attacks, one possible solution is to make accumulating dust outputs expensive. Since IOTA does not have any fees that might limit the feasibility of issuing many dust transactions, deposits pose a valid alternative to achieve a similar effect.</p>
<p>When an address is supposed to receive micro transactions, it must have an unspent output of a special type as a deposit. This deposit cannot be consumed by any transaction as long as the dust outputs remain unspent.</p>
<p>An additional benefit of this rule is that it makes a mass of privacy violating <a href="https://en.bitcoin.it/wiki/Privacy#Forced_address_reuse">forced address reuse attacks</a> more expensive to carry out.</p>
<h1 id="detailed-design-12"><a class="header" href="#detailed-design-12">Detailed design</a></h1>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<p><em>Dust output</em>: A transaction output that has an amount smaller than 1 Mi</p>
<p><em>SigLockedDustAllowanceOutput</em>: A new output type for deposits that enables an address to receive dust outputs. It can be consumed as an input like a regular <code>SigLockedSingleOutput</code>.</p>
<table>
  <tr>
    <td><b>Name</b></td>
    <td><b>Type</b></td>
    <td><b>Description</b></td>
  </tr>
  <tr>
    <td>Output Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceOutput</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Address <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Ed25519 Address</summary>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Address Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
            </td>
          </tr>
          <tr>
            <td>Address</td>
            <td>ByteArray[32]</td>
            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Amount</td>
    <td>uint64</td>
    <td>The amount of tokens to deposit with this <i>SigLockedDustAllowanceOutput</i> output.</td>
  </tr>
</table>
<h3 id="validation-2"><a class="header" href="#validation-2">Validation</a></h3>
<p>Let A be the address that should hold the dust outputs' balances. Let S be the sum of all the amounts of all unspent <code>SigLockedDustAllowanceOutputs</code> on A. Then, the maximum number of allowed dust outputs on A is S divided by 100,000 and rounded down, i.e. 10 outputs for each 1 Mi deposited.
However, regardless of S, the number of dust outputs must never exceed 100 per address.</p>
<p>The amount of a <code>SigLockedDustAllowanceOutput</code> must be at least 1 Mi. Apart from this, <code>SigLockedDustAllowanceOutputs</code> are processed identical to <code>SigLockedSingleOutput</code>. The transaction validation as defined in the IOTA protocol <a href="tips/TIP-0015/../TIP-0007/tip-0007.html">TIP-7</a>, however, needs to be adapted.</p>
<p><em>Syntactical validation</em> for <code>SigLockedDustAllowanceOutput</code>:</p>
<ul>
<li>The <code>Address</code> must be unique in the set of <code>SigLockedDustAllowanceOutputs</code> in one transaction T. However, there can be one <code>SigLockedSingleOutput</code> and one <code>SigLockedDustAllowanceOutputs</code> T.</li>
<li>The <code>Amount</code> must be ≥ 1,000,000.</li>
</ul>
<p>The <em>semantic validation</em> remains unchanged and are checked for both <code>SigLockedSingleOutputs</code> and <code>SigLockedDustAllowanceOutput</code>, but this RFC introduces one additional criterion:</p>
<p>A transaction T</p>
<ul>
<li>consuming a <code>SigLockedDustAllowanceOutput</code> on address A <strong>or</strong></li>
<li>creating a dust output with address A,</li>
</ul>
<p>is only semantically valid, if, after T is booked, the number of confirmed unspent dust outputs on A does not exceed the allowed threshold of min(S / 100000, 100).</p>
<h1 id="drawbacks-10"><a class="header" href="#drawbacks-10">Drawbacks</a></h1>
<ul>
<li>There can no longer be addresses holding less than 1 Mi.</li>
<li>The actual validity of dust transaction can only be checked during semantic validation.</li>
<li>A service receiving micropayments may fail receiving them, if it did not consolidate dust outputs or raised the deposit for the receiving address.</li>
<li>An attacker can send microtransactions to an address with a <code>SigLockedDustAllowanceOutput</code> in order to fill the allowed threshold and block honest senders of microtransactions. The owner of the address can mitigate this by simply consolidating the attacker's dust and collecting it for profit.</li>
</ul>
<h1 id="rationale-and-alternatives-12"><a class="header" href="#rationale-and-alternatives-12">Rationale and alternatives</a></h1>
<p>The rationale for creating a special <code>SigLockedDustAllowanceOutput</code> rather than rely on the default <code>SigLockedSingleOutputs</code> is to prevent attackers from polluting arbitrary addresses that happen to hold
a large amount of funds with dust.</p>
<p>One may note that an attacker can deposit a dust allowance on 3rd party address outside his control and pollute that address with dust.
From a security perspective this is better than an attacker depositing a dust allowance on addresses under his control.
This is because the receiving party might later choose to consolidate the dust outputs and hence relief UTXO memory consumption.
The receiving party is also unlikely to be displeased from obtaining more funds, small as they may be.</p>
<p>There are potential alternatives to introducing dust allowance deposits:</p>
<ul>
<li><em>Burning dust</em>: Allow dust outputs to exists only for a limited amount of time in the ledger. After this, they are removed completely and the associated funds are invalidated.</li>
<li><em>Sweeping dust into Merkle trees</em>: Instead of burning dust outputs after some time, they are instead compressed into a Merkle tree and only the tree root is kept. In order to spend one of these compressed outputs, the corresponding Merkle audit path needs to be supplied in addition to a regular signature.</li>
</ul>
<p>The first option can cause issues, when dust outputs were burned before users could consolidate them. Also, changing the supply can be controversial.</p>
<p>The second option is much more complicated as it introduces a completely new unlock mechanisms and requires the nodes to store the Merkle tree roots indefinitely.</p>
<h1 id="copyright-14"><a class="header" href="#copyright-14">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 16
title: Event API
description: Node event API definitions in AsyncAPI Specification
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/33
status: Active
type: Standards
layer: Interface
created: 2021-01-06
</pre>
<h1 id="summary-14"><a class="header" href="#summary-14">Summary</a></h1>
<p>This document proposes the Event API for nodes supporting the IOTA protocol.</p>
<h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<p>The API is described using the AsyncAPI Specification:</p>
<p><a href="https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/iotaledger/tips/main/tips/TIP-0016/event-api.yml">AsyncAPI Editor</a></p>
<h1 id="copyright-15"><a class="header" href="#copyright-15">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 17
title: Wotsicide
description: Define migration from legacy WOTS addresses to post-Chrysalis Phase 2 network
author: Luca Moser (@luca-moser) <luca.moser@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/35
status: Active
type: Standards
layer: Core
created: 2021-01-13
</pre>
<h1 id="summary-15"><a class="header" href="#summary-15">Summary</a></h1>
<p>This RFC defines the migration process of funds residing on WOTS addresses in the current legacy network to the post-Chrysalis Phase 2 network.</p>
<h1 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h1>
<p>The IOTA protocol wants to move away from WOTS as it created a number of security, protocol and UX issues:</p>
<ul>
<li>WOTS signatures are big and make up a disproportional amount of data of a transaction.</li>
<li>It is only safe to spend from an address <strong>once</strong>. Spending multiple times from the same address reveals random parts of the private key, making any subsequent transfers (other than the first) susceptible to thefts.</li>
<li>As a prevention mechanism to stop users from spending multiple times from the same address, nodes have to keep an ever growing list of those addresses.</li>
</ul>
<p>In the beginning of the new Chrysalis Phase 2 network, only Ed25519 addresses are supported. The protocol will no longer support WOTS addresses. Therefore, there needs to be a migration process from WOTS addresses to Ed25519 address in the new network.</p>
<p>To make the migration as smooth as possible, the specified mechanism allows for users to migrate their funds at any time with only a small delay until they're available on the new network.</p>
<p>This RFC outlines the detailed architecture of how users will be able to migrate their funds and specifies the underlying components and their purposes.</p>
<h1 id="detailed-design-13"><a class="header" href="#detailed-design-13">Detailed Design</a></h1>
<p>On a high-level the migration process works as follows:</p>
<ul>
<li>Users create migration bundles in the legacy network which target their Ed25519 address in the new network.</li>
<li>The Coordinator then mints those migrated funds in receipts which are placed within milestones on the new network.</li>
<li>Nodes in the new network evaluate receipts and book the corresponding funds by creating new UTXOs in the ledger.</li>
</ul>
<h2 id="migration-timeline"><a class="header" href="#migration-timeline">Migration timeline</a></h2>
<ol>
<li>Users issue migration bundles which effectively burn their funds. During this period, normal value bundles and zero-value transactions are allowed to become part of a milestone cone.</li>
<li>The Coordinator is stopped, and a new global snapshot is created which as its only solid entry point contains the last issued milestone (and put on dbfiles.iota.org). This global snapshot is used to create the genesis snapshot containing the already migrated funds for the new network. The remainder of the total supply which has not been migrated is allocated on the <code>TreasuryOutput</code>. Users are instructed to check the validity of these two snapshots.</li>
<li>A new Hornet version is released which only allows migration bundles to be broadcasted or be part of milestone cones. Users must update their node software as otherwise they will no longer peer.</li>
<li>The legacy network is restarted with the global snapshot, and the new network bootstraps with the genesis snapshot.</li>
<li>Further funds migrated in the legacy network are transferred to the new network using the receipt mechanism.</li>
</ol>
<h2 id="changes-to-the-legacy-network"><a class="header" href="#changes-to-the-legacy-network">Changes to the legacy network</a></h2>
<p>In order to facilitate the migration process, the node software making up the legacy network needs to be updated. This update will be deployed by stopping the Coordinator and forcing all nodes to upgrade to this new version.</p>
<h3 id="migration-bundle"><a class="header" href="#migration-bundle">Migration bundle</a></h3>
<p>The node software will no longer book ledger mutations to non-migration addresses. This means that users are incentivized to migrate their funds as they want to use their tokens. See this document on what <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration addresses</a> are.</p>
<p>A migration bundle is defined as follows:</p>
<ul>
<li>It contains exactly one output transaction of which the destination address is a valid <a href="https://hackmd.io/@iota-protocol/rkO-r1qAv">migration address</a> and is positioned as the tail transaction within the bundle. The output transaction value is at least 1'000'000 tokens.</li>
<li>It does not contain any zero-value transactions which do not hold signature fragments. This means that transactions other than the tail transaction must always be part of an input.</li>
<li>Input transactions must not use migration addresses.</li>
</ul>
<p>The node will only use tail transactions of migration or milestone bundles for the tip-pool. This means that past cones referenced by a milestone will only include such bundles.</p>
<p>The legacy node software is updated with an additional HTTP API command called <code>getWhiteFlagConfirmation</code> which given request data in the following form:</p>
<pre><code class="language-json">{
    &quot;command&quot;: &quot;getWhiteFlagConfirmation&quot;,
    &quot;milestoneIndex&quot;: 1434593
}
</code></pre>
<p>returns data for the given milestone white-flag confirmation:</p>
<pre><code class="language-json">{
    &quot;milestoneBundle&quot;: [
        &quot;SDGKWKJAG...&quot;,
        &quot;WNGHJWIFA...&quot;,
        &quot;DSIEWSDIG...&quot;
    ],
    &quot;includedBundles&quot;: [
        [
            &quot;SKRGI9DFS...&quot;,
            &quot;NBJSKRJGW...&quot;,
            &quot;ITRUQORTZ...&quot;
        ],
        [
            &quot;OTIDFJKSD...&quot;,
            &quot;BNSUGRWER...&quot;,
            &quot;OPRGJSDFJ...&quot;
        ],
        ...
    ]
}
</code></pre>
<p>where <code>milestoneBundle</code> contains the milestone bundle trytes and <code>includedBundles</code> is an array of tryte arrays of included bundles in the same DFS order as the white-flag confirmation. Trytes within a bundle &quot;array&quot; are sorted from <code>currentIndex</code> = 0 ascending to the <code>lastIndex</code>.</p>
<p>This HTTP API command allows interested parties to verify which migration bundles were confirmed by a given milestone.</p>
<h3 id="milestone-inclusion-merkle-proof"><a class="header" href="#milestone-inclusion-merkle-proof">Milestone inclusion Merkle proof</a></h3>
<p>The Coordinator will only include migration bundles (respectively the tails of those bundles) in its inclusion Merkle proof. Nodes which do not run with the updated code will crash once the updated confirmation is in place.</p>
<h3 id="preventing-non-migration-bundles"><a class="header" href="#preventing-non-migration-bundles">Preventing non-migration bundles</a></h3>
<p>As an additional measure to prevent users from submitting never confirming non-migration bundles (which would lead to key-reuse), nodes will no longer accept non-migration bundles in the HTTP API.</p>
<p>HTTP API level checks:</p>
<ul>
<li>The user must submit an entire migration bundle. No more single zero-value transactions, value-spam bundles etc. are allowed.</li>
<li>Input transactions are spending the entirety of the funds residing on the corresponding address. There must be more than 0 tokens on the given address.</li>
</ul>
<p>Wallet software must be updated to no longer support non-migration bundles.</p>
<p>There are no restrictions put in place on the gossip level, as it is too complex to prevent non-migration transactions to be filtered out, however, these transactions will never become part of a milestone cone.</p>
<h2 id="treasury-transaction"><a class="header" href="#treasury-transaction">Treasury Transaction</a></h2>
<p>A <code>TreasuryTransaction</code> is a payload which contains a reference to the current <code>TreasuryOutput</code> (in form of a <code>TreasuryInput</code> object) and an output <code>TreasuryOutput</code> which deposits the remainder.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Type</td>
        <td>uint32</td>
        <td>
            Set to <strong>value 4</strong> to denote a <i>TreasuryTransaction</i>.
        </td>
    </tr>
    <tr>
        <td>Input</td>
        <td colspan="2">
            <summary>TreasuryInput</summary>
            <table>
                <tr>
                    <td><b>Name<b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                </tr>
                <tr>
                    <td>Input Type</td>
                    <td>byte</td>
                    <td>
                        Set to <strong>value 1</strong> to denote an <i>TreasuryInput</i>.
                    </td>
                </tr>
                <tr>
                    <td>Milestone Hash</td>
                    <td>Array<byte>[32]></td>
                    <td>The hash of the milestone which created the referenced <i>TreasuryOutput</i>.</td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>Output</td>
        <td colspan="2">
            <summary>TreasuryOutput</summary>
            <table>
                <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                </tr>
                <tr>
                    <td>Output Type</td>
                    <td>byte</td>
                    <td>
                        Set to <strong>value 2</strong> to denote an <i>TreasuryOutput</i>.
                    </td>
                </tr>
                <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of funds residing in the treasury.</td>
                </tr>
            </table>
        </td>
    </tr>
</table>
<h3 id="treasury-input"><a class="header" href="#treasury-input">Treasury Input</a></h3>
<p>The <code>TreasuryInput</code> is equivalent to a normal <code>UTXOInput</code> but instead of referencing a transaction, it references a milestone. This input can only be used within <code>TreasuryTransaction</code> payloads.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Input Type</td>
        <td>byte</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>TreasuryInput</i>.
        </td>
    </tr>
    <tr>
        <td>Milestone Hash</td>
        <td>Array<byte>[32]></td>
        <td>The hash of the milestone which created the referenced <i>TreasuryOutput</i>.</td>
    </tr>
</table>
<h3 id="treasury-output"><a class="header" href="#treasury-output">Treasury Output</a></h3>
<p>The <code>TreasuryOutput</code> is a special output type which represents the treasury of the network, respectively the non yet migrated funds. At any given moment in time, there is only one <code>TreasuryOutput</code>.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name<b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Output Type</td>
        <td>byte</td>
        <td>
            Set to <strong>value 2</strong> to denote an <i>TreasuryInput</i>.
        </td>
    </tr>
    <tr>
        <td>Amount</td>
        <td>uint64</td>
        <td>The amount of funds residing in the treasury.</td>
    </tr>
</table>
<p>The <code>TreasuryOutput</code> can not be referenced or spent by transactions, it can only be referenced by receipts.</p>
<p>The <code>TreasuryOutput</code> can be queried from the HTTP API and needs to be included within snapshots in order to keep the total supply intact.</p>
<h2 id="receipts"><a class="header" href="#receipts">Receipts</a></h2>
<p>Receipts allow for fast migration of funds from the legacy into the new network by representing entries of funds which were migrated in the old network.</p>
<h3 id="schema-1"><a class="header" href="#schema-1">Schema</a></h3>
<p>Receipts are listings of funds for which nodes must generate UTXOs in the form of <code>SigLockedSingleOutput</code>s targeting the given address. Receipts are embedded within milestone payloads and therefore signed by the Coordinator. A milestone may contain up to one receipt as a payload. The Coordinator chooses whether to embed a receipt payload or not.</p>
<p>Serialized form:</p>
<table>
    <tr>
        <td><b>Name<b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>Set to <strong>value 3</strong> to denote a <i>Receipt</i>.</td>
    </tr>
    <tr>
        <td>Migrated At</td>
        <td>uint32</td>
        <td>The index of the legacy milestone in which the listed funds were migrated at.</td>
    </tr>
    <tr>
        <td>Final</td>
        <td>bool</td>
        <td>Flags whether this receipt is the last receipt for the given <i>Migrated At</i> index.</td>
    </tr>
    <tr>
        <td>Funds Count</td>
        <td>uint16</td>
        <td>Denotes how many migrated fund entries are within the receipt.</td>
    </tr>
    <tr>
        <td>Funds</td>
        <td colspan="2">
        <details open="true">
            <summary>Migrated Funds Entry</summary>
            <table>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>Tail Transaction Hash</td>
                    <td>Array<byte>[49]</td>
                    <td>
                    The tail transaction hash of the bundle in which these funds were migrated.
                    </td>
                </tr>
                <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                        <details open="true">
                            <summary>Ed25519 Address</summary>
                            <table>
                                <tr>
                                    <td><b>Name</b></td>
                                    <td><b>Type</b></td>
                                    <td><b>Description</b></td>
                                </tr>
                                <tr>
                                    <td>Address Type</td>
                                    <td>uint8</td>
                                    <td>
                                        Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                    </td>
                                </tr>
                                <tr>
                                    <td>Address</td>
                                    <td>Array&lt;byte&gt;[32]</td>
                                    <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                </tr>
                            </table>
                        </details>
                    </td>
                </tr>
                <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount which was migrated</td>
                </tr>
            </table>
        </details>
        </td>
    </tr>
    <tr>
        <td>Payload Length</td>
        <td>uint32</td>
        <td>The length in bytes of the payload.</td>
    </tr>
    <tr>
        <td valign="top">Payload</td>
        <td colspan="2">
            <details>
                <summary>TreasuryTransaction Payload</summary>
            </details>
        </td>
    </tr>
</table>
<h3 id="validation-3"><a class="header" href="#validation-3">Validation</a></h3>
<h4 id="syntactical"><a class="header" href="#syntactical">Syntactical</a></h4>
<ul>
<li><code>funds_array_count</code> can be max 127 and must be &gt; 0.</li>
<li><code>funds</code> array must be in lexical sort order (by their serialized form).</li>
<li>any <code>tail_transaction_hash</code> must be unique over the entire receipt.</li>
<li><code>deposit</code> must be ≥ 1'000'000 IOTA tokens.</li>
<li><code>payload_length</code> can not be zero.</li>
<li><code>treasury_transaction</code> must be a <code>Treasury Transaction</code> payload.</li>
</ul>
<h4 id="semantic"><a class="header" href="#semantic">Semantic</a></h4>
<ul>
<li><code>migrated_at</code> can not decrease between subsequent receipts.</li>
<li>There must not be any subsequent receipts with the same <code>migrated_at</code> index after the one with the <code>final</code> flag set to true.</li>
<li>The amount field of the previous <code>TreasuryOutput</code> minus the sum of all the newly migrated funds must equal the amount of the new <code>TreasuryOutput</code> within the <code>TreasuryTransaction</code> payload.</li>
</ul>
<h4 id="legitimacy-of-migrated-funds"><a class="header" href="#legitimacy-of-migrated-funds">Legitimacy of migrated funds</a></h4>
<p>While the syntactical and semantic validation ensures that the receipt's integrity is correct, it doesn't actually tell whether the given funds were really migrated in the legacy network.</p>
<p>In order validate this criteria, the node software performs following operation:</p>
<ol>
<li>The HTTP API of a legacy node is queried for all the <code>tail_transaction_hashes</code>, the addresses and their corresponding migrated funds.</li>
<li>The node checks whether the funds within the receipt matches the response from the legacy node.</li>
<li>Additionally, if the receipt's <code>final</code> flag was set to true, it is validated whether all funds for the given legacy milestone were migrated by looking at all the receipts with the same <code>migrated_at</code> index.</li>
</ol>
<p>If the operation fails, the node software must gracefully terminate with an appropriate error message.</p>
<p>In an optimal setting, node operators choose to only ask <strong>their own</strong> deployed nodes in the legacy network.</p>
<h3 id="booking-receipts"><a class="header" href="#booking-receipts">Booking receipts</a></h3>
<p>After successful receipt validation, the node software generates UTXOs in the following form: A <code>SigLockedSingleOutput</code> is allocated with the given <code>ed25519_address</code> and the funds as the deposit. As there is no actual transaction which generates the UTXO and normally a UTXO ID consists of <code>transaction hash | the output index</code>, the milestone hash of the milestone which included the receipt with the given funds is used as the <code>transaction hash</code>. The <code>output index</code> equals the index of the funds within the receipt (this is also why the receipt is limited to 127 entries). This allows to easily look up in which milestone these funds were generated in.</p>
<p>If one wants to audit the UTXO path of an input, it means that milestones need to be kept forever as they're needed to recognize that a certain output was generated by it. However, this can be offloaded to a 2nd level service.</p>
<p>All the generated <code>SigLockedSingleOutput</code>s from the migrated funds are then booked into the ledger and the new <code>TreasuryOutput</code> is persisted as a UTXO using the milestone hash of the receipt which included the <code>Treasury Transaction</code> payload.</p>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>For transparency reasons, the IF offers software which renders a dashboard showing details throughout the entire migration process:</p>
<ul>
<li>A list of outstanding funds residing on migration addresses to be migrated with the milestone index at which they were created.</li>
<li>Migrated funds.</li>
<li>Generated receipts.</li>
</ul>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<p>At current legacy network ledger size of 261446 entries (addresses with ≥ 1'000'000 tokens), it would take min. ~2058 receipts to migrate all funds. While theoretically the max message size allows for more entries to be within one receipt, it is limited by the fact that the index of the migrated address within the receipt is used to generate the <code>output_index</code> of the generated <code>SigLockedSingleDeposit</code> (further explained below).</p>
<p>Assuming the best case scenario in which all 261446 entries were sent to migration addresses in the legacy network, these funds could therefore be migrated into the new network within ~5.7h (at a 10 second milestone interval). Of course, in practice users will migrate over time and the receipt mechanism will need to be in place as long as the new network runs.</p>
<p>If looked at the receipt validation from a higher-level, it becomes quite apparent that this is analogous to previous global snapshots where users would post comments on a PR on GitHub saying that they computed the same ledger state, just that it is more granular and automatic while still leveraging the same source of truth: the ledger state/database of nodes.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<ul>
<li>The local snapshot file format needs to also include the to be applied receipts and supply information.</li>
</ul>
<h1 id="copyright-16"><a class="header" href="#copyright-16">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 19
title: Dust Protection Based on Byte Costs (Storage Deposit)
description: Prevent bloating the ledger size with dust outputs
author: Max Hase (@muXxer) <maximilian.hase@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/39
status: Draft
type: Standards
layer: Core
created: 2021-11-04
requires: TIP-18, TIP-20, TIP-21 and TIP-22
replaces: TIP-15
</pre>
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<p>The current <code>dust protection</code> in <code>chrysalis-pt2</code> is only an intermediate solution to prevent attacks or misbehavior that could bloat the ledger database. The design has several drawbacks, e.g. it does not scale, relies on a total ordering of the tangle and it is rather complicated to use from a user point of view.</p>
<p>This document describes a new <code>dust protection</code> concept, called <code>storage deposit</code>, which solves the mentioned drawbacks and creates a monetary incentive to keep the ledger state small. It focuses on the underlying problem, the increase in database size, instead of artificially limiting the number of UTXOs. This is achieved by enforcing a minimum IOTA coin deposit in every output based on the actually used disc space of the output itself.</p>
<h2 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h2>
<p>In a distributed ledger network, every participant, a so-called node, needs to keep track of the current ledger state. Since <code>chrysalis-pt2</code>, the IOTA ledger state is based on the UTXO model, where every node keeps track of all the currently unspent outputs. Without <code>dust protection</code>, even outputs containing only one single IOTA coin are valid and therefore stored in the database.</p>
<p>Misusage by honest users or intentionally bad behavior by malicious actors can lead to growing database and snapshot sizes and increasing computational costs (database lookups, balance calculations). Due to these increasing hardware requirements, the entry barrier to participate in the network becomes unaffordable and less nodes would operate the network.</p>
<p>Especially in a fee-less system like IOTA, this is a serious issue, since an attacker can create a lot of damage with low effort. Other DLTs do not yet face this problem, as such an attack would be much more expensive due to the high transaction fees.
However, in order to solve scalability issues more and more transactions need to be handled. Therefore, other DLT projects will also eventually run into the same dust limitations. This document proposes to introduce <code>storage deposit</code> to address this.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>The maximum possible ledger database size must be limited to a reasonable and manageable size.</li>
<li>The <code>dust protection</code> must not depend on a global shared state of the ledger, so that transaction validation can happen in parallel.</li>
<li>The <code>dust protection</code> should work for outputs with arbitrary data and size.</li>
<li>The ledger database size should be fairly allocated to users based on the scarce resource, IOTA coins.</li>
</ul>
<h2 id="detailed-design-14"><a class="header" href="#detailed-design-14">Detailed Design</a></h2>
<p>The current <code>dust protection</code> solution in <code>chrysalis-pt2</code> does not satisfy the mentioned requirements for the following reasons:</p>
<ul>
<li>The enforced maximum limit of disc space is ~6.5 TB.</li>
<li>The dust allowance mechanism depends on the total amount of funds in <code>DustAllowanceOutput</code> per address, which is a global shared state.</li>
<li>It is designed for one fixed output size.</li>
</ul>
<p>Therefore, a new transaction validation rule is introduced which replaces the former <code>dust protection</code> solution completely.</p>
<p>Blocks including payloads, even transaction payloads, are considered to be pruned by the nodes, but unspent transaction outputs must be kept until they are spent. Therefore the <code>dust protection</code> is based on the unspent outputs only.</p>
<p><strong>Every output created by a transaction needs to have at least a minimum amount of IOTA coins deposited in the output itself, otherwise the output is syntactically invalid.</strong></p>
<p>min_deposit_of_output = ⌊v_byte_cost · v_byte⌋
v_byte = ∑(weight<sub>𝑖</sub> · byte_size<sub>𝑖</sub>) + offset</p>
<p>where:</p>
<ul>
<li>v_byte_cost: costs in IOTA coins per virtual byte</li>
<li>weight<sub>𝑖</sub>: factor of field 𝑖 that takes computational and storage costs into account</li>
<li>byte_size<sub>𝑖</sub>: size of field 𝑖 in bytes</li>
<li>offset: additional v_bytes that are caused by additional data that has to be stored in the database but is not part of the output itself</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>:warning: <code>min_deposit_of_output</code> is rounded down</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Starting with the tokenization and smart contracts mainnet upgrade, new <a href="https://github.com/iotaledger/tips/pull/38">output types are introduced by Draft TIP-18</a> that contain mandatory and optional fields with variable length. Each of these fields result in different computational and storage costs, which will be considered by the positive <code>weight_i</code>. The size of the field itself is expressed with <code>byte_size_i</code>. <code>offset</code> is used to take the overhead of the specific output itself into account. </p>
<p>The <code>v_byte_cost</code> is a protocol value, which has to be defined based on reasonable calculations and estimates.</p>
<p><strong>In simple words, the more data you write to the global ledger database, the more IOTA you need to deposit in the output.</strong>
This is not a fee, because the deposited coins can be reclaimed by consuming the output in a new transaction.</p>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<p>The proposed solution has several advantages over the former solution.</p>
<p>First of all, the database size is limited to an absolute maximum size. Since the total supply of IOTA coins stays constant, also the maximum amount of <code>v_bytes</code> that can ever be written to the database remains constant.</p>
<p>Total ordering of the tangle is not necessary because there is no shared global ledger state for transaction validation anymore. The node can determine if the transaction is valid and the dust protection rules are fulfilled, just by looking at the transaction itself. Therefore this solution is also suitable for IOTA 2.0.</p>
<p>By introducing a certain cost for every byte stored in the ledger, it is possible to store arbitrary data in the outputs, as long as enough IOTA coins are deposited in the output itself to keep the information retained. This enables permanent storage of data in a distributed and decentralized way, without the need of a permanode.</p>
<p>Users have an economic incentive to clean up the database. By consuming old unused outputs, users can reclaim their deposited IOTA coins.</p>
<h3 id="drawbacks-11"><a class="header" href="#drawbacks-11">Drawbacks</a></h3>
<p>This solution prevents seamless microtransactions, which are a unique selling point for IOTA, because the issuer of the transaction always needs to deposit <code>min_deposit_of_output</code> IOTA coins in the output created by the transaction. This minimum deposit will have a higher value than the microtransaction itself, which basically makes microtransactions impossible. Two different solutions to circumvent this obstacle are introduced <a href="tips/TIP-0019/tip-0019.html#Microtransactions">here</a>.</p>
<h3 id="how-does-it-affect-other-parts-of-the-protocol"><a class="header" href="#how-does-it-affect-other-parts-of-the-protocol">How does it affect other parts of the protocol?</a></h3>
<p>The <code>dust protection</code> only affects &quot;value-transactions&quot;. Since blocks containing other payloads are not stored in the ledger state and are subject to pruning, they cannot cause permanent &quot;dust&quot; and do not need to be considered for <code>dust protection</code>.
However, all output types like e.g. smart contract requests are affected and must comply with the <code>min_deposit_of_output</code> criteria. Therefore, these requests could get quite expensive for the user, but the same mechanism introduced for <a href="tips/TIP-0019/tip-0019.html#Microtransactions-on-Layer-1">Microtransactions on Layer 1</a> can be utilized for smart contract requests as well.</p>
<h3 id="byte-cost-calculations"><a class="header" href="#byte-cost-calculations">Byte cost calculations</a></h3>
<p>To limit the maximum database size, the total IOTA supply needs to be divided by the target database size in bytes to get the worst case scenario regarding the byte costs.</p>
<p>However, in this scenario no outputs hold more IOTA coins than required for the <code>dust protection</code>. This does not represent the real distribution of funds over the UTXOs. We could assume that these output amounts follow Zipf's law. Unfortunately, fitting a Zipf distribution to the current ledger state will not match the future distribution of the funds for several reasons:</p>
<ul>
<li>There is already another <code>dust protection</code> in place, which distorts the distribution.</li>
<li>With new use cases enabled by the new <code>dust protection</code> (e.g. tokenization, storing arbitrary data in the ledger), the distribution will dramatically change.</li>
<li>Fittings for other DLT projects do not match because there are transaction fees in place, which decrease the amount of dust outputs in the distribution.</li>
</ul>
<p>Another possibility would be to estimate how much percentage of the database will be used for outputs with minimum required deposit (<code>fund sparsitiy percentage</code>) in the future. The remaining IOTA coins can be ignored in that case to simplify the calculation. Since a fund sparsity percentage of less than 20% would already be bad for other upcoming protocol features like the mana calculation, we could take this value for our calculation instead of the worst case.</p>
<h3 id="weights-for-different-outputs"><a class="header" href="#weights-for-different-outputs">Weights for different outputs</a></h3>
<p>The different output types mentioned in the <a href="https://github.com/iotaledger/tips/pull/38">Output Types Draft TIP-18</a> contain several mandatory and optional fields. Every field itself creates individual computational and storage requirements for the node, which is considered by having different weights for every field.</p>
<h5 id="field-types"><a class="header" href="#field-types">Field types</a></h5>
<p>The following table describes different field types in an output:</p>
<table>
    <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Weight</th>
        <th>Reasoning</th>
    </tr>
    <tr>
        <td><code>key</code></td>
        <td>Creates a key lookup in the database.</td>
        <td>10.0</td>
        <td>Keys need to be stored in the LSM tree of the key-value database engine and need to be merged and leveled, which is computational-, memory- and read/write IO-wise a heavy task.</td>
    </tr>
    <tr>
        <td><code>data</code></td>
        <td>Plain binary data on disk.</td>
        <td>1.0</td>
        <td>Data is stored as the value in the key-value database, and therefore only consumes disc space.</td>
    </tr>
</table>
<div class="table-wrapper"><table><thead><tr><th>:warning:  Protocol parameters are not set yet</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Protocol parameters presented in this document are design parameters that will change in the future based on simulation results, benchmarking and security assumptions. The reader should not take these values as definitive.</p>
<p>An example of such parameter for example is the <code>weight</code> assigned to different output field types.</p>
<h4 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h4>
<p>The following tables show the different outputs including the possible fields and their specific weight.</p>
<table>
    <details>
        <summary>Basic Output</summary>
        <blockquote>
            Describes a basic output with optional features.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 3</strong> to denote an <i>Basic Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Storage Deposit Return Unlock Condition</summary>
                                    <blockquote>
                                        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Return Amount</td>
                                            <td><code>data</code></td>
                                            <td>8</td>
                                            <td>8</td>
                                            <td>
                                                Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Timelock Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix timestamp until which the output can not be unlocked.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Expiration Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to 
                                        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Tag Feature</summary>
                                    <blockquote>
                                        Defines an indexation tag to which the output can be indexed by additional node plugins.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag Length</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Length of the following tag field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>255</td>
                                            <td>Binary indexation data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>426</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>13477</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_BasicOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_BasicOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>Alias Output</summary>
        <blockquote>
            Describes an alias account in the ledger that can be controlled by the state and governance controllers.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 4</strong> to denote a <i>Alias Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Alias ID</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>Unique identifier of the alias, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> Alias Address = Alias Address Type || Alias ID</i></td>
                        </tr>
                        <tr>
                            <td>State Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>A counter that must increase by 1 every time the alias is state transitioned.</td>
                        </tr>
                        <tr>
                            <td>State Metadata Length</td>
                            <td><code>data</code></td>
                            <td>2</td>
                            <td>2</td>
                            <td>Length of the following State Metadata field.</td>
                        </tr>
                        <tr>
                            <td>State Metadata</td>
                            <td><code>data</code></td>
                            <td>0</td>
                            <td>8192</td>
                            <td>Metadata that can only be changed by the state controller.</td>
                        </tr>
                        <tr>
                            <td>Foundry Counter</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>A counter that denotes the number of foundries created by this alias account.</td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>State Controller Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 4</strong> to denote an <i>State Controller Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Governor Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 5</strong> to denote an <i>Governor Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Issuer Feature</summary>
                                    <blockquote>
                                        Identifies the validated issuer of the UTXO state machine.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Issuer <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>469</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>29633</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_AliasOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_AliasOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>Foundry Output</summary>
        <blockquote>
            Describes a foundry output that is controlled by an alias.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 5</strong> to denote a <i>Foundry Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of different native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Serial Number</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The serial number of the foundry with respect to the controlling alias.</td>
                        </tr>
                        <tr>
                            <td valign="top">Token Scheme <code>oneOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Simple Token Scheme</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token Scheme Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Simple Token Scheme</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Minted Tokens</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Amount of tokens minted by this foundry.</td>
                                        </tr>
                                        <tr>
                                            <td>Melted Tokens</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Amount of tokens melted by this foundry.</td>
                                        </tr>
                                        <tr>
                                            <td>Maximum Supply</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>Maximum supply of tokens controlled by this foundry.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Immutable Alias Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 6</strong> to denote an <i>Immutable Alias Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>528</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>21398</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_FoundryOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_FoundryOutput_(max_functionality).jpg" alt="" /></p>
<table>
    <details>
        <summary>NFT Output</summary>
        <blockquote>
            Describes an NFT output, a globally unique token with metadata attached.
        </blockquote>
        <table>
            <tr>
                <td>Offset</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Field</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>OutputID</td>
                            <td><code>key</code></td>
                            <td>34</td>
                            <td>34</td>
                            <td>The ID of the output.</td>
                        </tr>
                        <tr>
                            <td>Block ID (included)</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>The ID of the block in which the transaction payload that created this output was included.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Milestone Index</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The index of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                        <tr>
                            <td>Confirmation Unix Timestamp</td>
                            <td><code>data</code></td>
                            <td>4</td>
                            <td>4</td>
                            <td>The unix timestamp of the milestone which confirmed the transaction that created the output.</td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>Fields</td>
                <td>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Field type</b></td>
                            <td><b>Length Minimum</b></td>
                            <td><b>Length Maximum</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Output Type</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>
                                Set to <strong>value 6</strong> to denote a <i>NFT Output</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Amount</td>
                            <td><code>data</code></td>
                            <td>8</td>
                            <td>8</td>
                            <td>The amount of IOTA coins held by the output.</td>
                        </tr>
                        <tr>
                            <td>Native Tokens Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of native tokens held by the output.</td>
                        </tr>
                        <tr>
                            <td valign="top">Native Tokens <code>optAnyOf</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Native Token</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Token ID</td>
                                            <td><code>data</code></td>
                                            <td>38</td>
                                            <td>38</td>
                                            <td>
                                                Identifier of the native token.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Amount</td>
                                            <td><code>data</code></td>
                                            <td>32</td>
                                            <td>32</td>
                                            <td>
                                                Amount of native tokens of the given <i>Token ID</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>NFT ID</td>
                            <td><code>data</code></td>
                            <td>32</td>
                            <td>32</td>
                            <td>Unique identifier of the NFT, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.<i> NFT Address = NFT Address Type || NFT ID</i></td>
                        </tr>
                        <tr>
                            <td>Unlock Conditions Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of unlock conditions following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Address Unlock Condition</summary>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Address</td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Storage Deposit Return Unlock Condition</summary>
                                    <blockquote>
                                        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Return Amount</td>
                                            <td><code>data</code></td>
                                            <td>8</td>
                                            <td>8</td>
                                            <td>
                                                Amount of IOTA coins the consuming transaction should deposit to the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Timelock Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix timestamp until which the output can not be unlocked.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Unix time (seconds since Unix epoch) starting from which the output can be consumed.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Expiration Unlock Condition</summary>
                                    <blockquote>
                                        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
                                        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Unlock Condition Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Return Address <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Unix Time</td>
                                            <td><code>data</code></td>
                                            <td>4</td>
                                            <td>4</td>
                                            <td>
                                                Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td>Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of features following.</td>
                        </tr>
                        <tr>
                            <td valign="top">Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Sender Feature</summary>
                                    <blockquote>
                                        Identifies the validated sender of the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Sender <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Tag Feature</summary>
                                    <blockquote>
                                        Defines an indexation tag to which the output can be indexed by additional node plugins.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag Length</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Length of the following tag field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Tag</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>255</td>
                                            <td>Binary indexation data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        <tr>
                            <td>Immutable Features Count</td>
                            <td><code>data</code></td>
                            <td>1</td>
                            <td>1</td>
                            <td>The number of immutable features following. Immutable features are defined upon deployment of the UTXO state machine and are not allowed to change in any future state transition.</td>
                        </tr>
                        <tr>
                            <td valign="top">Immutable Features <code>atMostOneOfEach</code></td>
                            <td colspan="2">
                                <details>
                                    <summary>Issuer Feature</summary>
                                    <blockquote>
                                        Identifies the validated issuer of the UTXO state machine.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td valign="top">Issuer <code>oneOf</code></td>
                                            <td colspan="2">
                                                <details>
                                                    <summary>Ed25519 Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>PubKeyHash</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>Alias Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>Alias ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                                <details>
                                                    <summary>NFT Address</summary>
                                                    <table>
                                                        <tr>
                                                            <td><b>Name</b></td>
                                                            <td><b>Field type</b></td>
                                                            <td><b>Length Minimum</b></td>
                                                            <td><b>Length Maximum</b></td>
                                                            <td><b>Description</b></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Address Type</td>
                                                            <td><code>data</code></td>
                                                            <td>1</td>
                                                            <td>1</td>
                                                            <td>
                                                                Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>NFT ID</td>
                                                            <td><code>data</code></td>
                                                            <td>32</td>
                                                            <td>32</td>
                                                            <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                                                        </tr>
                                                    </table>
                                                </details>
                                            </td>
                                        </tr>
                                    </table>
                                </details>
                                <details>
                                    <summary>Metadata Feature</summary>
                                    <blockquote>
                                        Defines metadata (arbitrary binary data) that will be stored in the output.
                                    </blockquote>
                                    <table>
                                        <tr>
                                            <td><b>Name</b></td>
                                            <td><b>Field type</b></td>
                                            <td><b>Length Minimum</b></td>
                                            <td><b>Length Maximum</b></td>
                                            <td><b>Description</b></td>
                                        </tr>
                                        <tr>
                                            <td>Feature Type</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>
                                                Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data Length</td>
                                            <td><code>data</code></td>
                                            <td>2</td>
                                            <td>2</td>
                                            <td>
                                                Length of the following data field in bytes.
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Data</td>
                                            <td><code>data</code></td>
                                            <td>1</td>
                                            <td>8192</td>
                                            <td>Binary data.</td>
                                        </tr>
                                    </table>
                                </details>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>v_byte Minimum</td>
                <td>459</td>
            </tr>
            <tr>
                <td>v_byte Maximum</td>
                <td>21739</td>
            </tr>
        </table>
    </details>
</table>
<p><img src="tips/TIP-0019/assets/deposit_miota_NFTOutput_(min_functionality).jpg" alt="" /></p>
<p><img src="tips/TIP-0019/assets/deposit_miota_NFTOutput_(max_functionality).jpg" alt="" /></p>
<h3 id="microtransactions"><a class="header" href="#microtransactions">Microtransactions</a></h3>
<h4 id="microtransactions-on-layer-1"><a class="header" href="#microtransactions-on-layer-1">Microtransactions on Layer 1</a></h4>
<p>To enable microtransactions on Layer 1 and still satisfy the <code>min_deposit_of_output</code> requirement, a new mechanism called <code>conditional sending</code> is introduced with the new <a href="https://github.com/iotaledger/tips/pull/38">Output Types Draft TIP-18</a>.</p>
<p><img src="tips/TIP-0019/assets/microtransactions_pt3_layer1.png" alt="Microtransactions on Layer 1" /></p>
<p>The preceding picture shows the process of the <code>conditional sending</code> mechanism. Alice uses the <code>Basic Output</code> to send a microtransaction of 1 IOTA to Bob's <code>Address</code>. To fulfill the <code>min_deposit_of_output</code> requirement, the <code>Amount</code> is increased by <code>min_deposit_of_output</code> IOTA, which is 1 MIOTA in the above example. To prevent Bob from accessing these additional funds called the <code>storage deposit</code>, Alice adds the optional <code>Storage Deposit Return Unlock Condition</code> and the optional <code>Sender Feature</code> to the <code>Basic Output</code>. Now Bob can only consume the newly created output, if the unlocking transaction deposits the specified <code>Return Amount</code> IOTA coins, in this case 1 MIOTA, to the <code>Sender</code> address defined by Alice. By consuming another UTXO and adding its amount to the received 1 IOTA, Bob takes care to create a valid output according to the dust protection rules.</p>
<p>To prevent Bob from blocking access to the <code>storage deposit</code> forever, Alice specifies the additional <code>Expiration Unlock Condition</code> in the <code>Basic Output</code>. If Bob does not consume the output before the time window defined by Alice expires, Alice regains total control over the output.</p>
<p>This means that there is no risk for Alice to lose the <code>storage deposit</code>, because either Bob needs to return the specified <code>Return Amount</code>, or the ownership of the created output switches back to Alice after the specified time-window has expired.</p>
<p>This mechanism can also be used to transfer native tokens or on-chain requests to ISCP chains without losing control over the required <code>storage deposit</code>.</p>
<h4 id="microtransactions-on-layer-2"><a class="header" href="#microtransactions-on-layer-2">Microtransactions on Layer 2</a></h4>
<p>Another solution is to outsource microtransactions to Layer 2 applications like smart contracts. In Layer 2 there are no restrictions regarding the minimum balance of an output.</p>
<p><img src="tips/TIP-0019/assets/microtransactions_pt3_layer2.png" alt="Microtransactions on Layer 2" /></p>
<p>In this example, Alice sends funds to a smart contract chain on Layer 1 with an output that covers at least <code>min_deposit_of_output</code>. From this point on, Alice can send any number of off-chain requests to the smart contract chain, causing the smart contract to send microtransactions from Alice' on-chain account to Bob's on-chain account. Bob can now request his on-chain account balances to be withdrawn to his Layer 1 address. The last step can also be combined with the formerly introduced <code>conditional sending</code> mechanism, in case Bob wants to withdraw less than <code>min_deposit_of_output</code> IOTA coins or native assets.</p>
<div class="table-wrapper"><table><thead><tr><th>:information_source: Potential additional mechanisms for microtransactions are currently being discussed.</th></tr></thead><tbody>
</tbody></table>
</div>
<h3 id="migration-from-old-to-new-dust-protection"><a class="header" href="#migration-from-old-to-new-dust-protection">Migration from old to new dust protection</a></h3>
<p>All <code>SigLockedSingleOutput</code> below 1 MIOTA and <code>SigLockedDustAllowanceOutput</code> of an address could be collected and migrated to a single new <code>BasicOutput</code> with the smallest <code>Output ID</code> (byte-wise) of all these collected outputs as the new identifier.</p>
<p>This could probably be done in the form of a global snapshot and would represent a hard-fork.</p>
<p>Another solution is to convert all <code>SigLockedDustAllowanceOutput</code> into <code>BasicOutputs</code> and leave the <code>SigLockedSingleOutput</code> below 1 MIOTA untouched.</p>
<h2 id="copyright-17"><a class="header" href="#copyright-17">Copyright</a></h2>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><pre>
tip: 31
title: Bech32 Address Format
description: Extendable address format supporting various signature schemes and address types
author: Wolfgang Welz (@Wollac) <wolfgang.welz@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: https://github.com/iotaledger/tips/pull/20
status: Draft
type: Standards
layer: Interface
created: 2022-04-04
replaces: 11
</pre>
<h1 id="summary-17"><a class="header" href="#summary-17">Summary</a></h1>
<p>This document proposes an extendable address format for the IOTA protocol supporting various signature schemes and address types. It relies on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">Bech32</a> format to provide a compact, human-readable encoding with strong error correction guarantees.</p>
<h1 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h1>
<p>With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, IOTA started using Ed25519 to generate digital signatures, in which addresses correspond to a BLAKE2b-256 hash. It is necessary to define a universal and extendable address format capable of encoding different types of addresses (introduced also in <a href="https://github.com/iotaledger/tips/pull/38">draft TIP-18</a>).</p>
<p>The legacy IOTA protocol (1.0, pre-Chrysalis) relies on Base27 addresses with a truncated Kerl checksum. However, both the character set and the checksum algorithm have limitations:</p>
<ul>
<li>Base27 is designed for ternary and is ill-suited for binary data.</li>
<li>The Kerl hash function also requires ternary input. Further, it is slow and provides no error-detection guarantees.</li>
<li>It does not support the addition of version or type information to distinguish between different kinds of addresses with the same length.</li>
</ul>
<p>All of these points are addressed in the Bech32 format introduced in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>: In addition to the usage of the human-friendly Base32 encoding with an optimized character set, it implements a <a href="https://en.wikipedia.org/wiki/BCH_code">BCH code</a> that <em>guarantees detection</em> of any error affecting at most four characters and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors.</p>
<p>This TIP proposes a simple and extendable binary serialization for addresses of different types that is then Bech32 encoded to provide a unique appearance for human-facing applications such as wallets.</p>
<h1 id="detailed-design-15"><a class="header" href="#detailed-design-15">Detailed design</a></h1>
<h2 id="binary-serialization-1"><a class="header" href="#binary-serialization-1">Binary serialization</a></h2>
<p>The address format uses a simple serialization scheme which consists of two parts:</p>
<ul>
<li>The first byte describes the type of the address.</li>
<li>The remaining bytes contain the type-specific raw address bytes.</li>
</ul>
<p>Currently, only three kind of addresses are supported:</p>
<ul>
<li>Ed25519, where the address consists of the BLAKE2b-256 hash of the Ed25519 public key.</li>
<li>Alias, where the address consists of the BLAKE2b-256 hash of the <i>Output ID</i> (defined in <a href="https://github.com/lzpap/tips/blob/tx-updates/tips/TIP-0020/tip-0020.md#utxo-input">draft TIP-0020</a>) that created the alias.</li>
<li>NFT, where the address consists of the BLAKE2b-256 hash of the <i>Output ID</i> (defined in <a href="https://github.com/lzpap/tips/blob/tx-updates/tips/TIP-0020/tip-0020.md#utxo-input">draft TIP-0020</a>) that created the NFT.</li>
</ul>
<p>They are serialized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First byte</th><th>Address bytes</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>0x00</code></td><td>32 bytes: The BLAKE2b-256 hash of the Ed25519 public key.</td></tr>
<tr><td>Alias</td><td><code>0x08</code></td><td>32 bytes: The BLAKE2b-256 hash of the <i>Output ID</i> that created the alias.</td></tr>
<tr><td>NFT</td><td><code>0x10</code></td><td>32 bytes: The BLAKE2b-256 hash of the <i>Output ID</i> that created the NFT.</td></tr>
</tbody></table>
</div>
<h2 id="bech32-for-human-readable-encoding-1"><a class="header" href="#bech32-for-human-readable-encoding-1">Bech32 for human-readable encoding</a></h2>
<p>The human-readable encoding of the address is Bech32 (as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>). A Bech32 string is at most 90 characters long and consists of:</p>
<ul>
<li>The <strong>human-readable part</strong> (HRP), which conveys the protocol and distinguishes between the different networks. HRPs are registered in <a href="https://github.com/satoshilabs/slips/blob/master/slip-0173.md">SLIP-0173</a>:
<ul>
<li><code>iota</code> is the human-readable part for IOTA Mainnet addresses (IOTA tokens)</li>
<li><code>atoi</code> is the human-readable part for IOTA Testnet/Devnet addresses</li>
<li><code>smr</code> is the human-readable part for Shimmer network addresses (Shimmer tokens)</li>
<li><code>rms</code> is the human-readable part for Shimmer Testnet/Devnet addresses</li>
</ul>
</li>
<li>The <strong>separator</strong>, which is always <code>1</code>.</li>
<li>The <strong>data part</strong>, which consists of the Base32 encoded serialized address and the 6-character checksum.</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<ul>
<li>Ed25519 Address
<ul>
<li>Ed25519 public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code></li>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char):<code>iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8x4r7t</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xhcazjh</code></li>
<li><strong>Shimmer Testnet</strong>: (63-char) <code>rms1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xrlkcfw</code></li>
</ul>
</li>
</ul>
</li>
<li>Alias Address
<ul>
<li><em>Output ID</em> (34-byte): <code>52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c6490000</code></li>
<li><em>Alias ID</em>, BLAKE2b-256 hash (32-byte): <code>fe80c2eb7c736da2f7c98ecf135ee9e34e4e076afe6e1dfebc9ec578b8f56d2f</code></li>
<li>serialized (33-byte): <code>08fe80c2eb7c736da2f7c98ecf135ee9e34e4e076afe6e1dfebc9ec578b8f56d2f</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char): <code>iota1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj76j6rev</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7autzrp</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7dzrr0a</code></li>
<li><strong>Shimmer Testnet</strong> (63-char): <code>rms1prlgpsht03ekmghhex8v7y67a835uns8dtlxu807hj0v279c74kj7e9ge5y</code></li>
</ul>
</li>
</ul>
</li>
<li>NFT Address
<ul>
<li><em>Output ID</em> (34-byte): <code>97b9d84d33419199483daab1f81ddccdeff478b6ee9040cfe026c517f67757880000</code></li>
<li><em>NFT ID</em>, BLAKE2b-256 hash (32-byte): <code>3159b115e27128b6db16db5e61f1aa4c70d84a99be753faa3ee70d9ad9c6a6b7</code></li>
<li>serialized (33-byte): <code>103159b115e27128b6db16db5e61f1aa4c70d84a99be753faa3ee70d9ad9c6a6b7</code></li>
<li>Bech32 string:
<ul>
<li><strong>IOTA</strong> (64-char): <code>iota1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntw0vklm7</code></li>
<li><strong>IOTA Testnet</strong> (64-char): <code>atoi1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwgz87pn</code></li>
<li><strong>Shimmer</strong> (63-char): <code>smr1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwcu0ld0</code></li>
<li><strong>Shimmer Testnet</strong> (63-char): <code>rms1zqc4nvg4ufcj3dkmzmd4uc034fx8pkz2nxl820a28mnsmxkec6ntwvmy9kk</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="drawbacks-12"><a class="header" href="#drawbacks-12">Drawbacks</a></h1>
<ul>
<li>Addresses look fundamentally different from the established 81-tryte legacy IOTA addresses. However, since the switch from binary to ternary and Chrysalis in general was a substantial change, this is a very reasonable and desired consequence.</li>
<li>A four character HRP plus one type byte only leaves a maximum of 48 bytes for the actual address.</li>
</ul>
<h1 id="rationale-and-alternatives-13"><a class="header" href="#rationale-and-alternatives-13">Rationale and alternatives</a></h1>
<ul>
<li>There are several ways to convert the binary serialization into a human-readable format, e.g. Base58 or hexadecimal. The Bech32 format, however, offers the best compromise between compactness and error correction guarantees. A more detailed motivation can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#motivation">BIP-0173 Motivation</a>.</li>
<li>The binary serialization itself must be as compact as possible while still allowing you to distinguish between different address types of the same byte length. As such, the introduction of a version byte offers support for up to 256 different kinds of addresses at only the cost of one single byte.</li>
</ul>
<h1 id="reference-implementation-5"><a class="header" href="#reference-implementation-5">Reference implementation</a></h1>
<p>Example Go implementation in <a href="https://github.com/Wollac/iota-crypto-demo">wollac/iota-crypto-demo</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/pkg/bech32">pkg/bech32</a></li>
<li>Example: <a href="https://github.com/Wollac/iota-crypto-demo/tree/master/examples/bech32">examples/bech32</a></li>
</ul>
<p>Example Go implementation in <a href="https://github.com/iotaledger/iota.go/tree/v3">iotaledger/iota.go/v3</a>:</p>
<ul>
<li>Bech32 encoding: <a href="https://github.com/iotaledger/iota.go/tree/v3/bech32">bech32</a></li>
<li>Address implementations: <a href="https://github.com/iotaledger/iota.go/blob/v3/address_ed25519.go">Ed25519</a>, <a href="https://github.com/iotaledger/iota.go/blob/v3/address_alias.go">Alias</a>, <a href="https://github.com/iotaledger/iota.go/blob/v3/address_nft.go">NFT</a></li>
</ul>
<h1 id="copyright-18"><a class="header" href="#copyright-18">Copyright</a></h1>
<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
