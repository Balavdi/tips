---
tip: 38
title: Building Blocks for IOTA 2.0 Output Types
description: Support for extended unlock conditions, native tokens and features
author:
  Philipp Gackstatter (@PhilippGackstatter) <philipp.gackstatter@iota.org>, Levente Pap (@lzpap) <levente.pap@iota.org>
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-03
requires: TIP-21, TIP-22, TIP-41, TIP-42, TIP-43, TIP-44, TIP-45 and TIP-47
replaces: TIP-18
---

# Table of Contents

1. [Summary](#summary)
2. [Motivation](#motivation)
3. [Introduction to ledger programmability](#ledger-programmability)
4. [Building Blocks](#building-blocks)
5. [Output Design Primitives](#output-design-primitives)
   - [Native tokens](#native-tokens-in-outputs)
   - [Chain constraint](#chain-constraint-in-utxo)
   - [Functionality in Outputs](#functionality-in-outputs)
     - [Unlock Conditions](#unlock-conditions)
       - [Address Unlock Condition](#address-unlock-condition)
       - [Storage Deposit Return Unlock Condition](#storage-deposit-return-unlock-condition)
       - [Timelock Unlock Condition](#timelock-unlock-condition)
       - [Expiration Unlock Condition](#expiration-unlock-condition)
     - [Features](#features)
       - [Sender Feature](#sender-feature)
       - [Issuer Feature](#issuer-feature)
       - [Metadata Feature](#metadata-feature)
6. [Copyright](#copyright)

# Summary

This document defines the common building blocks used across multiple output types and transaction validation rules for
the IOTA protocol. These were originally introduced in [TIP-18](../TIP-0018/tip-0018.md) and the functionality defined
in this document is an extension of the primitives defined in TIP-18.

## Summary of changes compared to TIP-18

- Rename "Alias" to "Account".
- The `Unix Time` field of the Timelock Unlock Condition is replaced by `Slot Index`.
- The `Unix Time` field of the Expiration Unlock Condition is replaced by `Slot Index`.

# Motivation

The aim of this TIP is to define the common building blocks for output types that support for the use cases of the
Native Tokenization Framework and seamless interoperability between layer 1 and layer 2 tokenization concepts.

The UTXO model becomes even more powerful when unlocking criteria (validation) of outputs are extended as demonstrated
by the [EUTXO model (Chakravarty et al., 2020)](https://fc20.ifca.ai/wtsc/WTSC2020/WTSC20_paper_25.pdf): instead of
requiring only a valid signature for the output's address to unlock it, additional unlock conditions can be programmed
into outputs. This programmability of outputs is the main idea behind the building blocks presented in this document.

In combination with the other layer 1 output types that build on top of the primitives defined here, users will be able
to interact with layer 2 smart contracts by posting requests through the Tangle. Requests can carry commands to smart
contracts and can additionally also transfer native tokens and NFTs.

With the Native Tokens defined in this TIP, users will be able to mint their own tokens directly in the base ledger,
which can then be transferred without any fees just like regular IOTA coins. Each native token has its own supply
control policy enforced by the protocol. These policies are transparent to all network participants. Issuers will be
able to store metadata about their tokens on-ledger, accessible to anyone.

# Building Blocks

## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Global Protocol Parameters

Global protocol parameters used throughout this TIP are defined in [TIP-22 (IOTA)](../TIP-0022/tip-0022.md) and
[TIP-32 (Shimmer)](../TIP-0032/tip-0032.md).

## Transaction Payload

[TIP-45](../TIP-0045/tip-0045.md) is the basis for output validation in this TIP.

# Output Design Primitives

New output types add new features to the protocol and hence new transaction validation rules. While some of these new
features are specifically tied to one output type, some are general, LEGO like building blocks that may be put in
several types of outputs.

The following defines various primitives and the validation rules they introduce.

## Native Tokens in Outputs

Outputs are records in the UTXO ledger that track ownership of funds. Thus, each output must be able to specify which
funds it holds. With the addition of the Native Tokenization Framework, outputs may also carry user defined native
tokens, that is, tokens that are not IOTA coins but were minted by foundries and are tracked in the very same ledger.
Therefore, **every output must be able to hold not only IOTA coins, but also native tokens**.

Dust protection applies to all outputs, therefore it is not possible for outputs to hold only native tokens, the storage
deposit requirements must be covered via IOTA coins.

User defined tokens are called <i>Native Tokens</i> on protocol level. The maximum supply of a particular native token
is defined by the representation chosen on protocol level for defining their amounts in outputs. Since native tokens are
also a vehicle to wrap layer 2 tokens into layer 1 tokens, the chosen representation must take into account the maximum
possible supply of layer 2 tokens. Solidity, the most popular smart contract language defines the maximum supply of an
ERC-20 token as `MaxUint256`, therefore it should be possible to represent such huge amount of assets on layer 1.

Outputs must have the following fields to define the balance of native tokens they hold:

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Native Tokens Count</td>
        <td>uint8</td>
        <td>The number of native tokens present in the output.</td>
    </tr>
    <tr>
        <td valign="top">Native Tokens <code>optAnyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Native Token</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Token ID</td>
                        <td>ByteArray[38]</td>
                        <td>
                            Identifier of the native token. Derivation defined <a href='../TIP-0044/tip-0044.md'>here</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint256</td>
                        <td>
                            Amount of tokens.
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

### Additional syntactic output validation rules:

- `Native Tokens` must be lexicographically sorted based on `Token ID`.
- Each <i>Native Token</i> must be unique in the set of `Native Tokens` based on its `Token ID`. No duplicates are
  allowed.
- `Amount` of any <i>Native Token</i> must not be `0`.

### Additional semantic transaction validation rules:

- The transaction is balanced in terms of native tokens, that is, the sum of native token balances in consumed outputs
  equals that of the created outputs.
- When the transaction is **imbalanced** and there is a surplus of native tokens on the:
  - **output side of the transaction:** the foundry outputs controlling outstanding native token balances must be
    present in the transaction. The validation of the foundry output(s) determines if the minting operations are valid.
  - **input side of the transaction:** the transaction destroys tokens. The presence and validation of the foundry
    outputs of the native tokens determines whether the tokens are burned (removed from the ledger) or melted in the
    foundry.

## Chain Constraint in UTXO

Previously created transaction outputs are destroyed when they are consumed in a subsequent transaction as an input. The
chain constraint makes it possible to **carry the UTXO state machine state encoded in outputs across transactions.**
When an output with chain constraint is consumed, that transaction has to create a single subsequent output that carries
the state forward. The **state can be updated according to the transition rules defined for the given type of output and
its current state**. As a consequence, each such output has a unique successor, and together they form a path or _chain_
in the graph induced by the UTXO spends. Each chain is identified by its globally unique identifier.

![](chain-constraint.png)

Account outputs, foundry outputs and NFT outputs all use this chain constraint concept and define their own unique
identifiers.

### Unlocking Chain Script Locked Outputs

Outputs with a chain constraint receive their unique identifiers upon creation, generated by the protocol, and carry it
forward with them through transactions until they are destroyed. These unique identifiers also function as global
addresses for the state machines, but unlike <i>Ed25519 Addresses</i>, they are not backed by private keys that could be
used for signing. The rightful owners who can unlock these addresses are defined in the outputs themselves.

Since such addresses are accounts in the ledger, it is possible to send funds to these addresses. The unlock mechanism
of such funds is designed in a way that **proving ownership of the address is reduced to the ability to unlock the
corresponding output that defines the address.**

## Functionality in Outputs

The programmability of outputs opens the door for implementing new functionalities for the base protocol. While some
outputs were specifically designed for such new features, some are optional additions that may be used with any outputs
that support them.

These new functionalities are grouped into two categories:

- **Unlock Conditions** and
- simple **Features**.

Each output type defines its list of supported <i>Unlock Conditions</i> and <i>Features</i>.

### Unlock Conditions

New output features that introduce unlocking conditions, that is, they define constraints on how the output can be
unlocked and spent, are grouped under the field <i>Unlock Conditions</i>.

Each output **must not contain more than one unlock condition of each type** and not all unlock condition types are
supported for each output type.

#### Address Unlock Condition

It is merely a layout change that the previously defined `Address` field of outputs ([TIP-7](../TIP-0007/tip-0007.md))
is represented as an <i>Address Unlock Condition</i>. Unlocking an <i>Ed25519 Address</i> doesn't change, it has to be
performed via a <i>Signature Unlock</i> in a transaction by signing the hash of the transaction essence. Transaction
validation rules are detailed in [TIP-20](../TIP-0020/tip-0020.md).

New additions are the <i>Account Address</i> and <i>NFT Address</i> types, which have to be unlocked with their
corresponding unlocks, as defined in [Unlocking Chain Script Locked Outputs](#unlocking-chain-script-locked-outputs) and
the [Account Output](../TIP-0042/tip-0042.md) and [NFT Output](../TIP-0043/tip-0043.md) TIPs.

<details>
    <summary>Address Unlock</summary>
    <blockquote>
        Defines the Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Account Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Account ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

| :information_source: Good to know about address format |
| ------------------------------------------------------ |

The <i>Address Type</i> byte of a raw address has an effect on the starting character of the bech32 encoded address,
which is the recommended address format for user facing applications.

A usual bech32 encoded mainnet address starts with `iota1`, and continues with the bech32 encoded bytes of the address.
By choosing <i>Address Type</i> as a multiple of 8 for different address types, the first character after the `1`
separator in the bech32 address will always be different.

| Address | Type Byte as `uint8` | Bech32 Encoded |
| ------- | -------------------- | -------------- |
| Ed25519 | 0                    | iota1**q**...  |
| Account | 8                    | iota1**p**...  |
| NFT     | 16                   | iota1**z**...  |

A user can identify by looking at the address whether it is a signature backed address, a smart contract chain account
or an NFT address.

#### Storage Deposit Return Unlock Condition

This unlock condition is employed to achieve conditional sending. An output that has <i>Storage Deposit Return Unlock
Condition</i> specified can only be consumed in a transaction that deposits `Return Amount` IOTA coins into
`Return Address`. When several of such outputs are consumed, their return amounts per `Return Addresses` are summed up
and the output side must deposit this total sum per `Return Address`.

##### Additional syntactic transaction validation rule:

- `Minimum Storage Deposit` is the storage deposit in the base currency required for a
  [<i>Basic Output</i>](../TIP-0041/tip-0041.md) that only has an <i>Address Unlock Condition</i>, no additional unlock
  conditions, no features and no native tokens.
- It must hold true, that `Minimum Storage Deposit` ≤ `Return Amount` ≤ `Amount`.

##### Additional semantic transaction validation rule:

- An output that has <i>Storage Deposit Return Unlock Condition</i> specified must only be consumed and unlocked in a
  transaction that deposits `Return Amount` IOTA coins to `Return Address` via one or more outputs that:
  - are of type <i>Basic Output</i>,
  - have only an [<i>Address Unlock Condition</i>](#address-unlock-condition) defined,
  - have no [<i>Native Tokens</i>](#native-tokens-in-outputs), and
  - have no [<i>Features</i>](#features).
- When several outputs with <i>Storage Deposit Return Unlock Condition</i> and the same `Return Address` are consumed,
  their return amounts per `Return Addresses` are summed up and the output side of the transaction must deposit _at
  least_ this total sum per `Return Address` via output(s) that satisfy the previous condition.

<details>
    <summary>Storage Deposit Return Unlock Condition</summary>
    <blockquote>
        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address<code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Account Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Account ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Return Amount</td>
        <td>uint64</td>
        <td>
            Amount of IOTA coins the consuming transaction should deposit to <i>Return Address</i>.
        </td>
    </tr>
</table>

This unlock condition makes it possible to send small amounts of IOTA coins or native tokens to addresses without having
to lose control of the required storage deposit. It is also a vehicle to send on-chain requests to ISCP chains that do
not require fees. To prevent the receiving party from blocking access to the storage deposit, it is advised to be used
together with the [Expiration Unlock Conditions](#expiration-unlock-conditions). The receiving party then has a
sender-defined time window to agree to the transfer by consuming the output, or the sender regains total control after
expiration.

#### Timelock Unlock Condition

Slot indices in the Tangle are introduced via slot commitments and represent a notion of time. Each such commitment
carries an index. The slot index of a transaction can be calculated based on its timestamp. TODO: Link to final location
of formula currently defined in
https://github.com/iotaledger/iota-core/blob/develop/documentation/APIs/core-models.md#slot-index.

An output that contains a <i>Timelock Unlock Condition</i> can not be unlocked before the specified lock has expired.
The lock is expired when the index of the slot to which the transaction belongs is equal or past the slot index defined
in the <i>Timelock Unlock Condition</i>.

##### Additional syntactic transaction validation rules:

- `Slot Index` field of a <i>Timelock Unlock Condition</i> must be > `0`.

##### Additional semantic transaction validation rules:

- An output that has <i>Timelock Unlock Condition</i> specified must only be consumed and unlocked in a transaction, if
  the creation time of the transaction is equal or past the `Slot Index` specified in the unlock condition.

<details>
    <summary>Timelock Unlock Condition</summary>
    <blockquote>
        Defines a slot index until which the output can not be unlocked.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Slot Index</td>
        <td>uint64</td>
        <td>
            Slot index starting from which the output can be consumed.
        </td>
    </tr>
</table>

#### Expiration Unlock Condition

The expiration feature of outputs makes it possible for the return address to reclaim an output after a given expiration
slot index has passed.

The expiration feature can be viewed as an opt-in receive feature, because the recipient loses access to the received
funds after the output expires, while the return address specified by the sender regains control over them. This feature
is a big help for on-chain smart contract requests. Those that have expiration set and are sent to dormant smart
contract chains can be recovered by their senders. Not to mention the possibility to time requests by specifying both a
timelock and an expiration unlock condition.

##### Additional syntactic transaction validation rules:

- `Slot Index` field of a <i>Expiration Unlock Condition</i> must be > `0`.

##### Additional semantic transaction validation rules:

- An output that has an <i>Expiration Unlock Condition</i> set must only be consumed and unlocked by the target
  `Address` (defined in <i>Address Unlock Condition</i>) in a transaction whose slot index is less than the `Slot Index`
  defined in the unlock condition.
- An output that has an <i>Expiration Unlock Condition</i> set must only be consumed and unlocked by the
  `Return Address` in a transaction whose slot index is greater or equal to the `Slot Index` defined in the unlock
  condition.
- Semantic validation of an output that has an <i>Expiration Unlock Condition</i> set and is unlocked by the
  `Return Address` must ignore:
  - [Semantic validation of <i>Storage Deposit Return Unlock Condition</i>](#storage-deposit-return-unlock-condition) if
    present.

The following table summarizes the outcome of the syntactic and semantic validation rules with respect to which address
is allowed to unlock the output containing the <i>Expiration Unlock Condition</i>:

| Transaction Slot Index Condition        | Outcome                                       |
| --------------------------------------- | --------------------------------------------- |
| `Slot Index` = `0`                      | Output and containing transaction is invalid. |
| `Slot Index` > `Transaction Slot Index` | Unlockable by `Address`                       |
| `Slot Index` ≤ `Transaction Slot Index` | Unlockable by `Return Address`                |

<details>
    <summary>Expiration Unlock Condition</summary>
    <blockquote>
        Defines a slot index until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
        unlock the output. After the slot index is reached/passed, only <i>Return Address</i> can unlock it.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote an <i>Expiration Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Account Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Account ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Slot Index</td>
        <td>uint64</td>
        <td>
            Before this slot index, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
        </td>
    </tr>
</table>

### Features

New output features that do not introduce unlocking conditions, but rather add new functionality and add constraints on
output creation are grouped under <i>Features</i>.

Each output **must not contain more than one feature of each type** and not all feature types are supported for each
output type.

#### Sender Feature

Every transaction consumes several elements from the UTXO set and creates new outputs. However, certain applications
(smart contracts) require to associate each output with exactly one sender address. Here, the sender feature is used to
specify the validated sender of an output.

Outputs that support the <i>Sender Feature</i> may specify a `Sender` address which is validated by the protocol during
transaction validation.

##### Additional semantic transaction validation rule:

- The <i>Sender Feature</i>, and hence the output and transaction that contain it, is valid, if and only if `Sender`
  address is unlocked in the transaction. Based on the `Address Type`, an address is unlocked in the transaction, if and
  only if:
  - <i>Ed25519 Address</i>:
    - The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature
      Unlock</i> with respect to the address.
  - <i>Account Address</i>:
    - The <i>Account Output</i> that defines the address is **state transitioned** in the transaction. A governance
      transition does not unlock the address.
  - <i>NFT Address</i>:
    - The <i>NFT Output</i> that defines the address is consumed as input in the transaction.

<details>
    <summary>Sender Feature</summary>
    <blockquote>
        Identifies the validated sender of the output.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Sender <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Account Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Account ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

#### Issuer Feature

The issuer feature is a special case of the sender feature that is only supported by outputs that implement a UTXO state
machine with [chain constraint](#chain-constraint-in-utxo) (account, NFT). Only when the state machine is created (e.g.
minted) it is checked during transaction validation that an output corresponding to the `Issuer` address is consumed. In
every future transition of the state machine, it is instead checked that the issuer feature is still present and
unchanged.

##### Additional semantic transaction validation rule:

- When an <i>Issuer Feature</i> is present in an output representing the initial state of an UTXO state machine, the
  transaction that contains this output is valid, if and only if `Issuer` address is unlocked in the transaction. Based
  on the `Address Type`, an address is unlocked in the transaction, if and only if:
  - <i>Ed25519 Address</i>:
    - The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature
      Unlock</i> with respect to the address.
  - <i>Account Address</i>:
    - The <i>Account Output</i> that defines the address is **state transitioned** in the transaction. A governance
      transition does not unlock the address.
  - <i>NFT Address</i>:
    - The <i>NFT Output</i> that defines the address is consumed as input in the transaction.

The main use case is proving authenticity of NFTs. Whenever an NFT is minted as an NFT output, the creator (issuer) can
fill the <i>Issuer Feature</i> with their address that they have to unlock in the transaction. Issuers then can publicly
disclose their addresses to prove the authenticity of the NFT once it is in circulation.

<details>
    <summary>Issuer Feature</summary>
    <blockquote>
        Identifies the validated issuer of the UTXO state machine.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Issuer <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Account Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Account ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

Whenever a chain account mints an NFT on layer 1 on behalf of some user, the `Issuer` field can only contain the chain's
address, since user does not sign the layer 1 transaction. As a consequence, artist would have to mint NFTs themselves
on layer 1 and then deposit it to chains if they want to place their own address in the `Issuer` field.

#### Metadata Feature

Outputs may carry additional data with them that is interpreted by higher layer applications built on the Tangle. The
protocol treats this metadata as pure binary data, it has no effect on the validity of an output except that it
increases the required storage deposit. ISC is a great example of a higher layer protocol that makes use of <i>Metadata
Feature</i>: smart contract request parameters are encoded in the metadata field of outputs.

##### Additional syntactic transaction validation rules:

- An output with <i>Metadata Feature</i> is valid, if and only if 0 < `length(Data)` ≤ `Max Metadata Length`.

<details>
    <summary>Metadata Feature</summary>
    <blockquote>
        Defines metadata (arbitrary binary data) that will be stored in the output.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Data</td>
        <td>(uint16)ByteArray</td>
        <td>Binary data. A leading uint16 denotes its length.</td>
    </tr>
</table>

#### Tag Feature

A <i>Tag Feature</i> makes it possible to tag outputs with an index, so they can be retrieved through an indexer API not
only by their address, but also based on the `Tag`. **The combination of a <i>Tag Feature</i>, a <i>Metadata Feature</i>
and a <i>Sender Feature</i> makes it possible to retrieve data associated to an address and stored in outputs that were
created by a specific party (`Sender`) for a specific purpose (`Tag`).**

An example use case is voting on the Tangle via the
[participation](https://github.com/iota-community/treasury/blob/main/specifications/hornet-participation-plugin.md)
plugin.

##### Additional syntactic transaction validation rules:

- An output with <i>Tag Feature</i> is valid, if and only if 0 < `length(Tag)` ≤ `Max Tag Length`.

<details>
    <summary>Tag Feature</summary>
    <blockquote>
        Defines an indexation tag to which the output can be indexed by additional node plugins.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Tag</td>
        <td>(uint8)ByteArray</td>
        <td>Binary indexation tag. A leading uint8 denotes its length.</td>
    </tr>
</table>

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
