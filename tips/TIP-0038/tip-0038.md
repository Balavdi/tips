---
tip: TODO
title: TODO
description: TODO
author: TODO
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-03
requires: TIP-19, TIP-20, TIP-21 and TIP-22
---

# Table of Contents

1. [Summary](#summary)
2. [Motivation](#motivation)
3. [Introduction to ledger programmability](#ledger-programmability)
4. [Building Blocks](#building-blocks)
5. [New concepts of output design](#new-concepts)
    - [Native tokens](#native-tokens-in-outputs)
    - [Chain constraint](#chain-constraint-in-utxo)
    - [Unlock Conditions](#unlock-conditions)
    - [Features](#features)
6. [Discussion](#drawbacks)
7. [Rationale and alternatives](#rationale-and-alternatives)
8. [Unresolved questions](#unresolved-questions)
9. [Copyright](#copyright)

# Summary

TODO: Adapt from TIP-18 summary.

# Motivation

TODO: Adapt from TIP-18 motivation.

# Ledger Programmability

The current UTXO model only provides support to transfer IOTA coins. However, the UTXO model presents a unique
opportunity to extend the range of possible applications by programming outputs.

Programming the base ledger of a DLT is not a new concept. Bitcoin uses the UTXO model and attaches small executables
(scripts) that need to be executed during transaction validation. The bitcoin script language is however not
[Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) as it can only support a small set of instructions
that are executed in a stack based environment. As each validator has to execute the same scripts and arrive at the
same conclusion, such scripts must terminate very quickly. Also, as transaction validation happens in the context of
the transaction and block, the scripts have no access to the global shared state of the system (all unspent transaction
outputs).

The novelty of Ethereum was to achieve quasi Turing-completeness by employing an account based model and gas to limit
resource usage during program execution. As the amount of gas used per block is limited, only quasi Turing-completeness
can be achieved. The account based model of Ethereum makes it possible for transactions to have access to the global
shared state of the system, furthermore, transactions are executed one-after-the-other. These two properties make
Ethereum less scalable and susceptible to high transaction fees.

Cardano achieves UTXO programmability by using the EUTXO model. This makes it possible to represent smart contracts in
a UTXO model as state machines. In EUTXO, states of the machine are encoded in outputs, while state transition rules
are governed by scripts. Just like in bitcoin, these scripts may only use a limited set of instructions.

It would be quite straightforward to support EUTXO in IOTA too, except that IOTA transactions are feeless. There is no
reward to be paid out to validators for validating transactions, as all nodes in the network validate all transactions.
Due to the unique data structure of the Tangle, there is no need for miners to explicitly choose which transactions are
included in the ledger, but there still has to be a notion of objective validity of transactions. Since it is not
possible without fees to penalize scripts that consume excessive network resources (node CPU cycles) during transaction
validation, IOTA has to be overly restrictive about what instructions are supported on layer 1.

It must also be noted that UTXO scripts are finite state machines with the state space restricted by the output and
transaction validation rules. It makes expressiveness of UTXO scripts inherently limited. In the context of complicated
application logic required by use cases such as modern DeFi, this leads to unconventional and complicated architectures
of the application, consisting of many interacting finite state machines. Apart from complexity and UX costs, it also
has performance and scalability penalties.

For the reason mentioned above, **IOTA chooses to support configurable yet hard-coded scripts for output and
transaction validation on layer 1.** The general full-scale quasi Turing-complete programmability of the IOTA ledger is
achieved by extending the ledger state transition function with layer 2 smart contract chains. This not only makes it
possible to keep layer 1 scalable and feeless, but also allows to support any type of virtual machine on layer 2 to
program advanced business logic and features.

Below, several new output types are discussed that implement their own configurable script logic. They can be viewed as
UTXO state machines in which the state of the machine is encoded as data inside the output. The state transition rules
are defined by the output type and by the parameters chosen upon deployment.

# Building Blocks

## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Global Protocol Parameters

Global protocol parameters used throughout this TIP are defined in [TIP-22 (IOTA)](../TIP-0022/tip-0022.md) and [TIP-32 (Shimmer)](../TIP-0032/tip-0032.md).

## Transaction Payload

[TIP-20](../TIP-0020/tip-0020.md) is the basis for output validation in this TIP.

## New Concepts

New output types add new features to the protocol and hence new transaction validation rules. While some of these new
features are specifically tied to one output type, some are general, LEGO like building blocks that may be put in
several types of outputs.

Below is a summary of such new features and the validation rules they introduce.

### Native Tokens in Outputs

Outputs are records in the UTXO ledger that track ownership of funds. Thus, each output must be able to specify which
funds it holds. With the addition of the Native Tokenization Framework, outputs may also carry user defined native
tokens, that is, tokens that are not IOTA coins but were minted by foundries and are tracked in the very same ledger.
Therefore, **every output must be able to hold not only IOTA coins, but also native tokens**.

Dust protection applies to all outputs, therefore it is not possible for outputs to hold only native tokens, the
storage deposit requirements must be covered via IOTA coins.

User defined tokens are called <i>Native Tokens</i> on protocol level. The maximum supply of a particular native token
is defined by the representation chosen on protocol level for defining their amounts in outputs. Since native tokens
are also a vehicle to wrap layer 2 tokens into layer 1 tokens, the chosen representation must take into account the
maximum possible supply of layer 2 tokens. Solidity, the most popular smart contract language defines the
maximum supply of an ERC-20 token as `MaxUint256`, therefore it should be possible to represent such huge amount of
assets on layer 1.

Outputs must have the following fields to define the balance of native tokens they hold:

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Native Tokens Count</td>
        <td>uint8</td>
        <td>The number of native tokens present in the output.</td>
    </tr>
    <tr>
        <td valign="top">Native Tokens <code>optAnyOf</code></td>
        <td colspan="2">
            <details>
                <summary>Native Token</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Token ID</td>
                        <td>ByteArray[38]</td>
                        <td>
                            Identifier of the native token. Derivation defined <a href='https://github.com/iotaledger/tips/blob/main/tips/TIP-0018/tip-0018.md#foundry-output'>here</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Amount</td>
                        <td>uint256</td>
                        <td>
                            Amount of tokens.
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

#### Additional syntactic output validation rules:

- `Native Tokens` must be lexicographically sorted based on `Token ID`.
- Each <i>Native Token</i> must be unique in the set of `Native Tokens` based on its `Token ID`. No duplicates are
  allowed.
- `Amount` of any <i>Native Token</i> must not be `0`.

#### Additional semantic transaction validation rules:

- The transaction is balanced in terms of native tokens, that is, the sum of native token balances in consumed outputs
  equals that of the created outputs.
- When the transaction is **imbalanced** and there is a surplus of native tokens on the:
  - **output side of the transaction:** the foundry outputs controlling outstanding native token balances must be present in the transaction. The validation of the foundry output(s) determines if the minting operations are valid.
  - **input side of the transaction:** the transaction destroys tokens. The presence and validation of the foundry outputs of the native tokens determines whether the tokens are burned (removed from the ledger) or melted in the foundry.

### Chain Constraint in UTXO

Previously created transaction outputs are destroyed when they are consumed in a subsequent transaction as an input.
The chain constraint makes it possible to **carry the UTXO state machine state encoded in outputs across transactions.**
When an output with chain constraint is consumed, that transaction has to create a single subsequent output that
carries the state forward. The **state can be updated according to the transition rules defined for the given type of
output and its current state**. As a consequence, each such output has a unique successor, and together they form a path
or *chain* in the graph induced by the UTXO spends. Each chain is identified by its globally unique identifier.

![](chain-constraint.png)

Alias outputs, foundry outputs and NFT outputs all use this chain constraint concept and define their own unique
identifiers.

### New Functionality in Outputs

The programmability of outputs opens the door for implementing new functionalities for the base protocol. While some outputs
were specifically designed for such new features, some are optional additions that may be used with any outputs that
support them.

These new functionalities are grouped into two categories:
 - **Unlock Conditions** and
 - simple **Features**.

The [Output Design](#output-design) section lists all supported <i>Unlock Conditions</i> and <i>Features</i> for
each output type.


#### Unlock Conditions

New output features that introduce unlocking conditions, that is, they define constraints on how the output can
be unlocked and spent, are grouped under the field <i>Unlock Conditions</i>.

Each output **must not contain more than one unlock condition of each type** and not all unlock condition types are
supported for each output type.

##### Address Unlock Condition

It is merely a layout change that the previously defined `Address` field of outputs ([TIP-7](../TIP-0007/tip-0007.md))
is represented as an <i>Address Unlock Condition</i>. Unlocking an <i>Ed25519 Address</i> doesn't change, it has to
be performed via a <i>Signature Unlock</i> in a transaction by signing the hash of the transaction essence.
Transaction validation rules are detailed in [TIP-20](../TIP-0020/tip-0020.md).

New additions are the <i>Alias Address</i> and <i>NFT Address</i> types, which have to be unlocked with their
corresponding unlocks, as defined in [Unlocking Chain Script Locked Outputs](#unlocking-chain-script-locked-outputs).

<details>
    <summary>Address Unlock</summary>
    <blockquote>
        Defines the Address that owns this output, that is, it can unlock it with the proper <i>Unlock</i> in a
        transaction.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Address</td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

| :information_source:  Good to know about address format |
|---------------------------------------------------------|

The <i>Address Type</i> byte of a raw address has an effect on the starting character of the bech32 encoded address,
which is the recommended address format for user facing applications.

A usual bech32 encoded mainnet address starts with `iota1`, and continues with the bech32 encoded bytes of the address.
By choosing <i>Address Type</i> as a multiple of 8 for different address types, the first character after the `1`
separator in the bech32 address will always be different.

| Address | Type Byte as `uint8` | Bech32 Encoded |
|---------|----------------------|----------------|
| Ed25519 | 0                    | iota1**q**...  |
| Alias   | 8                    | iota1**p**...  |
| NFT     | 16                   | iota1**z**...  |

A user can identify by looking at the address whether it is a signature backed address, a smart contract chain account
or an NFT address.

##### Storage Deposit Return Unlock Condition

This unlock condition is employed to achieve conditional sending. An output that has
<i>Storage Deposit Return Unlock Condition</i> specified can only be consumed in a transaction that deposits
`Return Amount` IOTA coins into `Return Address`. When several of such outputs are consumed, their return amounts per
`Return Addresses` are summed up and the output side must deposit this total sum per `Return Address`.

###### Additional syntactic transaction validation rule:

- `Minimum Storage Deposit` is the storage deposit in the base currency required for a <i>Basic Output</i> that only
  has an <i>Address Unlock Condition</i>, no additional unlock conditions, no features and
  no native tokens.
- It must hold true, that `Minimum Storage Deposit` ≤ `Return Amount` ≤ `Amount`.

###### Additional semantic transaction validation rule:

- An output that has <i>Storage Deposit Return Unlock Condition</i> specified must only be consumed and unlocked in a
  transaction that deposits `Return Amount` IOTA coins to `Return Address` via one or more outputs that:
   - are of type [<i>Basic Output</i>](#basic-output),
   - have only an [<i>Address Unlock Condition</i>](#address-unlock-condition) defined,
   - have no [<i>Native Tokens</i>](#native-tokens-in-outputs), and
   - have no [<i>Features</i>](#features).
- When several outputs with <i>Storage Deposit Return Unlock Condition</i> and the same `Return Address` are consumed,
  their return amounts per `Return Addresses` are summed up and the output side of the transaction must deposit
  _at least_ this total sum per `Return Address` via output(s) that satisfy the previous condition.

<details>
    <summary>Storage Deposit Return Unlock Condition</summary>
    <blockquote>
        Defines the amount of IOTAs used as storage deposit that have to be returned to <i>Return Address</i>.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote a <i>Storage Deposit Return Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address<code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Return Amount</td>
        <td>uint64</td>
        <td>
            Amount of IOTA coins the consuming transaction should deposit to <i>Return Address</i>.
        </td>
    </tr>
</table>

This unlock condition makes it possible to send small amounts of IOTA coins or native tokens to addresses without having
to lose control of the required storage deposit. It is also a vehicle to send on-chain requests to ISCP chains that do not
require fees. To prevent the receiving party from blocking access to the storage deposit, it is advised to be used
together with the [Expiration Unlock Conditions](#expiration-unlock-conditions). The receiving party then has a sender-defined
time window to agree to the transfer by consuming the output, or the sender regains total control after expiration.

##### Timelock Unlock Condition

The notion of time in the Tangle is introduced via milestones. Each milestone
[carries the current unix timestamp](../TIP-0008/tip-0008.md#structure)
corresponding to that milestone index. Whenever a new milestone appears, nodes perform the white-flag ordering and transaction
validation on its past cone. The timestamp of the confirming milestone provide the time as an input parameter to
transaction validation.

An output that contains a <i>Timelock Unlock Condition</i> can not be unlocked before the specified timelock has
expired. The timelock is expired when the timestamp of the confirming milestone is equal or past the timestamp defined
in the <i>Timelock Unlock Condition</i>.

###### Additional syntactic transaction validation rules:
- `Unix Time` field of a <i>Timelock Unlock Condition</i> must be > `0`.
###### Additional semantic transaction validation rules:
- An output that has <i>Timelock Unlock Condition</i> specified must only be consumed and unlocked in a
  transaction, if the timestamp of the confirming milestone is equal or past the `Unix Time` specified in the unlock
  condition.

<details>
    <summary>Timelock Unlock Condition</summary>
    <blockquote>
        Defines a unix timestamp until which the output can not be unlocked.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Timelock Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Unix time (seconds since Unix epoch) starting from which the output can be consumed.
        </td>
    </tr>
</table>

##### Expiration Unlock Condition

The expiration feature of outputs makes it possible for the return address to reclaim an output after a given expiration
time has been passed. The expiration can be specified as a unix timestamp.

The expiration feature can be viewed as an opt-in receive feature, because the recipient loses access to the received
funds after the output expires, while the return address specified by the sender regains control over them. This feature
is a big help for on-chain smart contract requests. Those that have expiration set and are sent to dormant smart contract
chains can be recovered by their senders. Not to mention the possibility to time requests by specifying both a
timelock and an expiration unlock condition.

###### Additional syntactic transaction validation rules:
- `Unix Time` field of an <i>Expiration Unlock Condition</i> must be > `0`.

###### Additional semantic transaction validation rules:
- An output that has <i>Expiration Unlock Condition</i> set must only be consumed and
  unlocked by the target `Address` (defined in <i>Address Unlock Condition</i>) in a transaction that has a confirming
  milestone timestamp earlier than the `Unix Time` defined in the unlock condition.
- An output that has <i>Expiration Unlock Condition</i> set must only be consumed and unlocked by the `Return Address`
  in a transaction that has a confirming milestone timestamp same or later than the `Unix Time` defined in the unlock
  condition.
- Semantic validation of an output that has <i>Expiration Unlock Condition</i> set and is unlocked by the
  `Return Address` must ignore:
  - [Semantic validation of <i>Storage Deposit Return Unlock Condition</i>](#storage-deposit-return-unlock-condition) if present.

The following table summarizes the outcome of syntactic and semantic validation rules with respect to which account
is allowed to unlock the output containing the <i>Expiration Unlock Condition</i>:

| Milestone Unix Timestamp Condition                  | Outcome                                       |
|-----------------------------------------------------|-----------------------------------------------|
| `Unix Time` = `0`                                   | Output and containing transaction is invalid. |
| `Unix Time` > `Confirming Milestone Unix Timestamp` | Unlockable by `Address`                       |
| `Unix Time` ≤ `Confirming Milestone Unix Timestamp` | Unlockable by `Return Address`                |

<details>
    <summary>Expiration Unlock Condition</summary>
    <blockquote>
        Defines a unix time until which only <i>Address</i>, defined in <i>Address Unlock Condition</i>, is allowed to
        unlock the output. After the unix time is reached/passed, only <i>Return Address</i> can unlock it.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Expiration Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Return Address <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Unix Time</td>
        <td>uint32</td>
        <td>
            Before this unix time, <i>Address Unlock Condition</i> is allowed to unlock the output, after that only the address defined in <i>Return Address</i>.
        </td>
    </tr>
</table>

## Manalock Unlock Condition

Slot indices in the Tangle are introduced via slot commitments. Each such commitment carries an index. The slot index of a transaction can be calculated based on its timestamp. TODO: Link to final location of formula currently defined in https://github.com/iotaledger/iota-core/blob/develop/documentation/APIs/core-models.md#slot-index.

An output that contains a <i>Manalock Unlock Condition</i> can not be unlocked before the specified lock has
expired. The lock is expired when the index of the slot in which the transaction belongs to is equal or past the slot index defined in the <i>Manalock Unlock Condition</i>.

### Additional syntactic transaction validation rules:

- `Slot Index` field of a <i>Manalock Unlock Condition</i> must be > `0`.

### Additional semantic transaction validation rules:

- An output that has a <i>Manalock Unlock Condition</i> specified can only be created in a transaction if it also contains an <i>Address Unlock Condition</i> with an `Account Address`.
- An output that has a <i>Manalock Unlock Condition</i> specified must only be consumed and unlocked in a transaction, if both of the following conditions hold:
    - the index of the slot to which the transaction belongs is equal or past the `Slot Index` specified in the unlock condition.
    - the specified `Account Address` of the <i>Address Unlock Condition</i> has a non-negative BIC balance.

<details>
    <summary>Manalock Unlock Condition</summary>
    <blockquote>
        Defines a slot index until which the output can not be unlocked.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Unlock Condition Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 7</strong> to denote a <i>Manalock Unlock Condition</i>.
        </td>
    </tr>
    <tr>
        <td>Slot Index</td>
        <td>uint64</td>
        <td>
            Slot index starting from which the output can be consumed.
        </td>
    </tr>
</table>

### Features

New output features that do not introduce unlocking conditions, but rather add new functionality and add constraints on
output creation are grouped under <i>Features</i>.

Each output **must not contain more than one feature of each type** and not all feature types are supported for each output
type.

##### Sender Feature

Every transaction consumes several elements from the UTXO set and creates new outputs. However, certain applications
(smart contracts) require to associate each output with exactly one sender address. Here, the sender feature is used to
specify the validated sender of an output.

Outputs that support the <i>Sender Feature</i> may specify a `Sender` address which is validated by the protocol during
transaction validation.

###### Additional semantic transaction validation rule:
- The <i>Sender Feature</i>, and hence the output and transaction that contain it, is valid, if and only if `Sender` address is unlocked in the transaction. Based on the `Address Type`, an address is unlocked in the transaction, if and only if:
  - <i>Ed25519 Address</i>:
    - The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.
  - <i>Alias Address</i>:
    - The <i>Alias Output</i> that defines the address is **state transitioned** in the transaction. A governance transition does not unlock the address.
  - <i>NFT Address</i>:
    - The <i>NFT Output</i> that defines the address is consumed as input in the transaction.

<details>
    <summary>Sender Feature</summary>
    <blockquote>
        Identifies the validated sender of the output.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote a <i>Sender Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Sender <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

##### Issuer Feature

The issuer feature is a special case of the sender feature that is only supported by outputs that implement a UTXO state
machine with [chain constraint](#chain-constraint-in-utxo) (alias, NFT).
Only when the state machine is created (e.g. minted) it is checked during transaction validation that an output
corresponding to the `Issuer` address is consumed. In every future transition of the state machine, it is instead
checked that the issuer feature is still present and unchanged.

###### Additional semantic transaction validation rule:
- When an <i>Issuer Feature</i> is present in an output representing the initial state of an UTXO state machine, the
  transaction that contains this output is valid, if and only if `Issuer` address is unlocked in the transaction. Based on the `Address Type`, an address is unlocked in the transaction, if and only if:
  - <i>Ed25519 Address</i>:
    - The <i>Unlock</i> of the first output in the transaction that contains the address is a valid <i>Signature Unlock</i> with respect to the address.
  - <i>Alias Address</i>:
    - The <i>Alias Output</i> that defines the address is **state transitioned** in the transaction. A governance transition does not unlock the address.
  - <i>NFT Address</i>:
    - The <i>NFT Output</i> that defines the address is consumed as input in the transaction.

The main use case is proving authenticity of NFTs. Whenever an NFT is minted as an NFT output, the creator (issuer) can
fill the <i>Issuer Feature</i> with their address that they have to unlock in the transaction. Issuers then can publicly
disclose their addresses to prove the authenticity of the NFT once it is in circulation.

<details>
    <summary>Issuer Feature</summary>
    <blockquote>
        Identifies the validated issuer of the UTXO state machine.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Issuer Feature</i>.
        </td>
    </tr>
    <tr>
        <td valign="top">Issuer <code>oneOf</code></td>
        <td colspan="2">
            <details>
                <summary>Ed25519 Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>PubKeyHash</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>Alias Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 8</strong> to denote an <i>Alias Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Alias ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>Alias ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
            <details>
                <summary>NFT Address</summary>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Address Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>NFT ID</td>
                        <td>ByteArray[32]</td>
                        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>

Whenever a chain account mints an NFT on layer 1 on behalf of some user, the `Issuer` field can only contain the
chain's address, since user does not sign the layer 1 transaction. As a consequence, artist would have to mint NFTs
themselves on layer 1 and then deposit it to chains if they want to place their own address in the `Issuer` field.

##### Metadata Feature

Outputs may carry additional data with them that is interpreted by higher layer applications built on the Tangle. The
protocol treats this metadata as pure binary data, it has no effect on the validity of an output except that it
increases the required storage deposit. ISC is a great example of a higher layer protocol that makes use of
<i>Metadata Feature</i>: smart contract request parameters are encoded in the metadata field of outputs.

###### Additional syntactic transaction validation rules:
- An output with <i>Metadata Feature</i> is valid, if and only if 0 < `length(Data)` ≤ `Max Metadata Length`.

<details>
    <summary>Metadata Feature</summary>
    <blockquote>
        Defines metadata (arbitrary binary data) that will be stored in the output.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 2</strong> to denote a <i>Metadata Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Data</td>
        <td>(uint16)ByteArray</td>
        <td>Binary data. A leading uint16 denotes its length.</td>
    </tr>
</table>

#### Tag Feature

A <i>Tag Feature</i> makes it possible to tag outputs with an index, so they can be retrieved through an indexer API not
only by their address, but also based on the `Tag`. **The combination of a <i>Tag Feature</i>, a
<i>Metadata Feature</i> and a <i>Sender Feature</i> makes it possible to retrieve data associated to an address and stored
in outputs that were created by a specific party (`Sender`) for a specific purpose (`Tag`).**

An example use case is voting on the Tangle via the [participation](https://github.com/iota-community/treasury/blob/main/specifications/hornet-participation-plugin.md) plugin.

##### Additional syntactic transaction validation rules:
- An output with <i>Tag Feature</i> is valid, if and only if 0 < `length(Tag)` ≤
  `Max Tag Length`.

<details>
    <summary>Tag Feature</summary>
    <blockquote>
        Defines an indexation tag to which the output can be indexed by additional node plugins.
    </blockquote>
</details>

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Feature Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 3</strong> to denote a <i>Tag Feature</i>.
        </td>
    </tr>
    <tr>
        <td>Tag</td>
        <td>(uint8)ByteArray</td>
        <td>Binary indexation tag. A leading uint8 denotes its length.</td>
    </tr>
</table>

# Drawbacks
- New output types increase transaction validation complexity, however it is still bounded.
- Outputs take up more space in the ledger, UTXO database size might increase.
- It is possible to intentionally deadlock aliases and NFTs, however client side software can notify users when they
  perform such action. Deadlocked aliases and NFTs can not be unlocked, but this is true for any funds locked into
  unspendable addresses.
- Time based output locking conditions can only be evaluated after attachment to the Tangle, during milestone
  confirmation.
- IOTA ledger can only support hard-coded scripts. Users can not write their own scripts because there is no way
  currently to charge them based on resource usage, all IOTA transactions are feeless by nature.
- Aliases can be destroyed even if there are foundries alive that they control. Since only the controlling alias can
  unlock the foundry, such foundries and the supply of the tokens remain forever locked in the Tangle.
- Token schemes and needed supply control rules are unclear.

# Rationale and alternatives

The feeless nature of IOTA makes it inherently impossible to implement smart contracts on layer 1. A smart contract
platform shall not only be capable of executing smart contracts, but also to limit their resource usage and make users
pay validators for the used resources. IOTA has no concept of validators, neither fees. While it would technically be
possible to run EUTXO smart contracts on the layer 1 Tangle, it is not possible to properly charge users for executing
them.

The current design aims to combine the best of both worlds: Scalable and feeless layer 1 and Turing-complete smart
contracts on layer 2. Layer 1 remains scalable because of parallel transaction validation, feeless because the bounded
hard-coded script execution time, and layer 2 can offer support for all kinds of virtual machines, smart contracts and
advanced tokenization use cases.

# Unresolved questions

- List of supported <i>Token Schemes</i> is not complete.
    - Deflationary token scheme
    - Inflationary token scheme with scheduled minting
    - etc.
- Adapt the current congestion control, i.e. *Block PoW*, to better match the validation complexity of the different
  outputs and types.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
