---
tip: 45
title: IOTA 2.0 Transaction Payload
description: Defines the Transaction with the corresponding IOTA 2.0 output types
author:
  Philipp Gackstatter (@PhilippGackstatter) <philipp.gackstatter@iota.org>, Daria Dziuba≈Çtowska (@daria305)
  <daria.dziubaltowska@iota.org>
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-08
requires: TIP-39, TIP-41, TIP-42, TIP-43 and TIP-44
replaces: TIP-20
---

# Summary

This TIP proposes a new UTXO-based transaction structure consisting of all the inputs and outputs of a transfer.
Specifically, this TIP defines a transaction payload for _blocks_ described in [TIP-46](../TIP-0046/tip-0046.md) and
extends the transaction payload described in [TIP-20](../TIP-0007/tip-0020.md).

# Motivation

[TIP-20](../TIP-0020/tip-0020.md) introduced a new extended transaction model for the Stardust update. This TIP extends
this model to be aligned with all new Mana and account features:

- accommodate for the new output types introduced in [TIP-41](../TIP-0041/tip-0041.md),
  [TIP-42](../TIP-0042/tip-0042.md), [TIP-43](../TIP-0043/tip-0043.md), [TIP-44](../TIP-0044/tip-0044.md);
- add the _Allotments_ field in the transaction for adding Mana to an Account's Block Issuance Credits;
- add the _Context Inputs_ field in the transaction for non-UTXO inputs that provide contextual information for the
  transaction;
- add the _Creation Slot_ field that is the index of the slot in which the transaction was created;
- updates the syntactic validation rules to ensure the correctness of input and output Mana balances according to IOTA
  2.0 Mana requirements, defined in [TIP-39](../TIP-0039/tip-0039.md).

The motivation of these changes is to adjust the transaction and its validation rules with the protocol upgrade to IOTA
2.0. Validation rules must now consider the Mana decay factor and the possibility of Mana allotment in the transaction
to a Block Issuance Credits account.

# Building Blocks

## Merkle Tree

A [merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) is a tree data structure that allows for efficient proofs of
inclusion. The serialization schemes defined here are only for a merkle proof of a value in the tree or for the tree's
merkle root. As the tree itself can be represented as the array of its leaves, it does not have its own serialization
scheme.

### Merkle Proof

A merkle tree proof is serialized as one of two possible schemas: A tree node or the hash of the value for which the
proof is computed. A `Leaf Hash` schema is additionally used in tree nodes, but cannot be at the top-level of a proof.

#### Node

<details>
  <summary>Node</summary>
  <blockquote>A merkle tree node that contains two child components.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Merkle Tree Component Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 0</strong> to denote a <i>Node</i>.</td>
  </tr>
  <tr>
    <td valign="top">Left <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Node</summary>
        <blockquote>A merkle tree node that contains two child components. Defined in <a href='../TIP-0045/tip-0045.md#node'>TIP-45 (Node)</a>.</blockquote>
      </details>
      <details>
        <summary>Leaf Hash</summary>
        <blockquote>Contains the hash of a leaf in the tree. Defined in <a href='../TIP-0045/tip-0045.md#leaf-hash'>TIP-45 (Leaf Hash)</a>.</blockquote>
      </details>
      <details>
        <summary>Value Hash</summary>
        <blockquote>Contains the hash of the value for which the proof is being computed. Defined in <a href='../TIP-0045/tip-0045.md#value-hash'>TIP-45 (Value Hash)</a>.</blockquote>
      </details>
    </td>
  </tr>
  <tr>
    <td valign="top">Right <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Node</summary>
        <blockquote>A merkle tree node that contains two child components. Defined in <a href='../TIP-0045/tip-0045.md#node'>TIP-45 (Node)</a>.</blockquote>
      </details>
      <details>
        <summary>Leaf Hash</summary>
        <blockquote>Contains the hash of a leaf in the tree. Defined in <a href='../TIP-0045/tip-0045.md#leaf-hash'>TIP-45 (Leaf Hash)</a>.</blockquote>
      </details>
      <details>
        <summary>Value Hash</summary>
        <blockquote>Contains the hash of the value for which the proof is being computed. Defined in <a href='../TIP-0045/tip-0045.md#value-hash'>TIP-45 (Value Hash)</a>.</blockquote>
      </details>
    </td>
  </tr>
</table>

#### Leaf Hash

<details>
  <summary>Leaf Hash</summary>
  <blockquote>Contains the hash of a leaf in the tree.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Merkle Tree Component Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Leaf Hash</i>.</td>
  </tr>
  <tr>
    <td>Hash</td>
    <td>(uint8)ByteArray</td>
    <td>The hash of the leaf.</td>
  </tr>
</table>

#### Value Hash

<details>
  <summary>Value Hash</summary>
  <blockquote>Contains the hash of the value for which the proof is being computed.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Merkle Tree Component Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 2</strong> to denote a <i>Value Hash</i>.</td>
  </tr>
  <tr>
    <td>Hash</td>
    <td>(uint8)ByteArray</td>
    <td>The hash of the value.</td>
  </tr>
</table>

#### Proof Computation

A **merkle proof** is computed as follows:

- Preliminary Definitions:
  - Let `Leaves` be an array of serialized values, representing the leaves of the tree and `Leaves Len` the length of
    that array.
  - Let `Leaves[i]` denote the `i`-th element in the `Leaves` array.
  - Let `Leaves[Start:End]` denote the subslice of `Leaves` from `Start` (inclusive) to `End` (exclusive).
  - Let `Largest Power Of Two(n)` be a procedure that returns the largest power of two less than `n`.
  - BLAKE2b-256 is used as the hash function.
- Let `Hash Leaf(Bytes)` be a procedure that produces the hash of the given byte array consisting of these values in
  their displayed order:
  - the leaf domain-separation prefix with value `0` of type `uint8`,
  - and `Bytes`.
- Let `Hash Node(Left Bytes, Right Bytes)` be a procedure that produces the hash of the given byte arrays consisting of
  these values in their displayed order:
  - the node domain-separation prefix with value `1` of type `uint8`,
  - and `Left Bytes`,
  - and `Right Bytes`.
- Let `Hash Subtree(Leaves)` be a procedure that produces the hash of a sub-tree in the following way:
  - If `Leaves Len == 0` return the hash of the empty string.
  - If `Leaves Len == 1` return a `Value Hash` with its `Hash` field set to `Hash Leaf(Leaves[0])`.
  - Otherwise, compute `Split` as `Largest Power Of Two(Leaves Len)`:
    - Let `Left` be the result of `Hash Subtree(Leaves[0:Split])`.
    - Let `Right` be the result of `Hash Subtree(Leaves[Split:Leaves Len])`.
    - Return `Hash Node(Left, Right)`
- Let `Compute Proof(Leaves, Index)` be the procedure that computes the proof for the leaf at index `Index`, defined as
  follows:
  - If `Leaves Len == 0` return an error, since at least one item is required to compute a proof.
  - If `Leaves Len == 1` return a `Value Hash` with its `Hash` field set to `Hash Leaf(Leaves[0])`.
  - If `Leaves Len == 2`:
    - If `Index == 0` return a `Node` with:
      - `Left` set to a `Value Hash` with its `Hash` field set to `Hash Leaf(Leaves[0])`.
      - `Right` set to a `Leaf Hash` with its `Hash` field set to `Hash Leaf(Leaves[1])`.
    - If `Index == 1` return a `Node` with:
      - `Left` set to a `Leaf Hash` with its `Hash` field set to `Hash Leaf(Leaves[0])`.
      - `Right` set to a `Value Hash` with its `Hash` field set to `Hash Leaf(Leaves[1])`.
  - Otherwise, compute `Split` as `Largest Power Of Two(Leaves Len)`:
    - If `Index < Split` return a `Node` with:
      - `Left` set to the result of `Compute Proof(Leaves[0:Split], Index)`.
      - `Right` set to a `Leaf Hash` with its `Hash` field set to `Hash Subtree(Leaves[Split:Leaves Len])`.
    - Otherwise return a `Node` with:
      - `Left` set to a `Leaf Hash` with its `Hash` field set to `Hash Subtree(Leaves[0:Split])`.
      - `Right` set to the result of `Compute Proof(Leaves[Split:Leaves Len], Index)`.

### Merkle Root

The **merkle root** is a `ByteArray[32]` and can be computed from two different inputs:

- From a merkle tree with its array of `Leaves` by executing `Hash Subtree(Leaves)`.
- From a merkle proof by executing `Hash Component` on the top-level component of the proof, where
  `Hash Component(Merkle Tree Component)` is a procedure defined as:
  - If the component is a `Leaf Hash`, return its field `Hash`.
  - If the component is a `Value Hash`, return its field `Hash`.
  - If the component is a `Node` return `Hash Node(Hash Component(Left), Hash Component(Right))`.

# Detailed design

## UTXO

The _unspent transaction output_ (UTXO) model defines a ledger state where balances are not directly associated to
addresses but to the outputs of transactions. In this model, transactions reference outputs of previous transactions as
inputs, which are consumed (removed) to create new outputs. A transaction must consume all the funds of the referenced
inputs.

Using a UTXO-based model provides several benefits:

- Parallel validation of transactions.
- Easier double-spend detection since conflicting transactions would reference the same UTXO.
- Replay-protection, which is important when having reusable addresses. Replaying the same transaction would manifest
  itself as already being applied or existent, and thus, not have any impact.
- Balances are no longer strictly associated to addresses. This allows a higher level of abstraction, and thus, enables
  other types of outputs with particular unlock criteria.

Within a transaction using UTXOs, inputs and outputs make up the to-be-signed data of the transaction. The section
unlocking the inputs is called the _unlock_. An unlock may contain a signature proving ownership of a given input's
address and/or other unlock criteria.

The following image depicts the flow of funds using UTXO:

![UTXO flow](utxo.png)

## Transaction Structure

### Serialized Layout

A _Signed Transaction_ Payload is made up of two parts:

1. The _Transaction_ part which contains the inputs, outputs, and an optional embedded payload.
2. The _Unlocks_ which unlock, or _sign_, the inputs of the _Transaction_.

The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same
serialized byte sequence. The inputs and outputs are considered as lists. They can contain duplicates and their
serialization order matches the order of the list; they do not need to be sorted.

The following table describes the entirety of a _Signed Transaction_ in its serialized form following the notation from
[TIP-21](../TIP-0021/tip-0021.md):

<details>
  <summary>Signed Transaction</summary>
  <blockquote>A transaction with its unlocks.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Signed Transaction</i>.</td>
  </tr>
  <tr>
    <td valign="top">Transaction</td>
    <td colspan="2">
      <details open="true">
        <summary>Transaction</summary>
        <blockquote>A transaction without its unlocks.</blockquote>
        <table>
          <tr>
            <td>
              <b>Name</b>
            </td>
            <td>
              <b>Type</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr>
            <td>Network ID</td>
            <td>uint64</td>
            <td>The ID of the network for which this essence is valid for. It consists of the first 8 bytes of the BLAKE2b-256 hash of the <code>Network Name</code>.</td>
          </tr>
          <tr>
            <td>Creation Slot</td>
            <td>uint32</td>
            <td>The slot index in which the transaction was created.</td>
          </tr>
          <tr>
            <td>Context Inputs Count</td>
            <td>uint16</td>
            <td>The number of Context Inputs following.</td>
          </tr>
          <tr>
            <td valign="top">Context Inputs <code>optAnyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Commitment Input</summary>
                <blockquote>A Commitment Input allows referencing a commitment to a certain slot and is used to provide a notion of time for transaction execution that is linked to the containing Block's <code>Issuing Time</code>. Defined in <a href='../TIP-0045/tip-0045.md#commitment-input'>TIP-45 (Commitment Input)</a>.</blockquote>
                <table>
                  <tr>
                    <td>
                      <b>Name</b>
                    </td>
                    <td>
                      <b>Type</b>
                    </td>
                    <td>
                      <b>Description</b>
                    </td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>Set to <strong>value 1</strong> to denote a <i>Commitment Input</i>.</td>
                  </tr>
                  <tr>
                    <td>Commitment ID</td>
                    <td>ByteArray[36]</td>
                    <td>The commitment identifier to reference to.</td>
                  </tr>
                </table>
              </details>
              <details>
                <summary>Block Issuance Credit Input</summary>
                <blockquote>A Block Issuance Credit Input provides the BIC balance of a specific account as context to transaction execution. Defined in <a href='../TIP-0045/tip-0045.md#block-issuance-credit-input'>TIP-45 (Block Issuance Credit Input)</a>.</blockquote>
                <table>
                  <tr>
                    <td>
                      <b>Name</b>
                    </td>
                    <td>
                      <b>Type</b>
                    </td>
                    <td>
                      <b>Description</b>
                    </td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>Set to <strong>value 2</strong> to denote a <i>Block Issuance Credit Input</i>.</td>
                  </tr>
                  <tr>
                    <td>Account ID</td>
                    <td>ByteArray[32]</td>
                    <td>The ID of the Account for which this input provides the BIC.</td>
                  </tr>
                </table>
              </details>
              <details>
                <summary>Reward Input</summary>
                <blockquote>A Reward Input indicates which transaction Input is claiming Mana rewards. Defined in <a href='../TIP-0045/tip-0045.md#reward-input'>TIP-45 (Reward Input)</a>.</blockquote>
                <table>
                  <tr>
                    <td>
                      <b>Name</b>
                    </td>
                    <td>
                      <b>Type</b>
                    </td>
                    <td>
                      <b>Description</b>
                    </td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>Set to <strong>value 3</strong> to denote a <i>Reward Input</i>.</td>
                  </tr>
                  <tr>
                    <td>Index</td>
                    <td>uint16</td>
                    <td>The index of the transaction input for which to claim rewards.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inputs Count</td>
            <td>uint16</td>
            <td>The number of Inputs following.</td>
          </tr>
          <tr>
            <td valign="top">Inputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>UTXO Input</summary>
                <blockquote>Describes an input which references an unspent transaction output to consume. Defined in <a href='../TIP-0045/tip-0045.md#utxo-input'>TIP-45 (UTXO Input)</a>.</blockquote>
                <table>
                  <tr>
                    <td>
                      <b>Name</b>
                    </td>
                    <td>
                      <b>Type</b>
                    </td>
                    <td>
                      <b>Description</b>
                    </td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>Set to <strong>value 0</strong> to denote a <i>UTXO Input</i>.</td>
                  </tr>
                  <tr>
                    <td>Transaction ID</td>
                    <td>ByteArray[36]</td>
                    <td>The identifier of the transaction that created the referenced output.</td>
                  </tr>
                  <tr>
                    <td>Transaction Output Index</td>
                    <td>uint16</td>
                    <td>The output index of the referenced output.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Allotments Count</td>
            <td>uint16</td>
            <td>The number of Allotments following.</td>
          </tr>
          <tr>
            <td valign="top">Allotments <code>optAnyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Allotment</summary>
                <blockquote>Allots Mana to the account identified by the contained Account ID. Defined in <a href='../TIP-0045/tip-0045.md#allotment'>TIP-45 (Allotment)</a>.</blockquote>
                <table>
                  <tr>
                    <td>
                      <b>Name</b>
                    </td>
                    <td>
                      <b>Type</b>
                    </td>
                    <td>
                      <b>Description</b>
                    </td>
                  </tr>
                  <tr>
                    <td>Account ID</td>
                    <td>ByteArray[32]</td>
                    <td>The ID of the Account to which the Mana is allotted.</td>
                  </tr>
                  <tr>
                    <td>Mana</td>
                    <td>uint64</td>
                    <td>The amount of Mana to allot.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Capabilities</td>
            <td>(uint8)ByteArray</td>
            <td>The capabilities of the transaction.</td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Tagged Data</summary>
                <blockquote>Data with optional tag. Defined in <a href='../TIP-0023/tip-0023.md#specification'>TIP-23 (Specification)</a>.</blockquote>
              </details>
            </td>
          </tr>
          <tr>
            <td>Outputs Count</td>
            <td>uint16</td>
            <td>The number of Outputs following,</td>
          </tr>
          <tr>
            <td valign="top">Outputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Basic Output</summary>
                <blockquote>Describes a basic output with optional features. Defined in <a href='../TIP-0041/tip-0041.md#basic-output'>TIP-41 (Basic Output)</a>.</blockquote>
              </details>
              <details>
                <summary>Foundry Output</summary>
                <blockquote>Describes a foundry output that is controlled by an account. Defined in <a href='../TIP-0044/tip-0044.md#foundry-output'>TIP-44 (Foundry Output)</a>.</blockquote>
              </details>
              <details>
                <summary>Account Output</summary>
                <blockquote>Describes an account in the ledger that can be controlled by the state and governance controllers. Defined in <a href='../TIP-0042/tip-0042.md#account-output'>TIP-42 (Account Output)</a>.</blockquote>
              </details>
              <details>
                <summary>NFT Output</summary>
                <blockquote>Describes an NFT output, a globally unique token with metadata attached. Defined in <a href='../TIP-0043/tip-0043.md#nft-output'>TIP-43 (NFT Output)</a>.</blockquote>
              </details>
              <details>
                <summary>Delegation Output</summary>
                <blockquote>Describes a Delegation Output, which delegates its contained IOTA coins to a validator. Defined in <a href='../TIP-0040/tip-0040.md#delegation-output'>TIP-40 (Delegation Output)</a>.</blockquote>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Unlocks Count</td>
    <td>uint16</td>
    <td>The number of unlocks following.</td>
  </tr>
  <tr>
    <td valign="top">Unlocks <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Signature Unlock</summary>
        <blockquote>Unlocks the address derived from the contained Public Key in the transaction in which it is contained in. Defined in <a href='../TIP-0045/tip-0045.md#signature-unlock'>TIP-45 (Signature Unlock)</a>.</blockquote>
      </details>
      <details>
        <summary>Reference Unlock</summary>
        <blockquote>References a previous unlock to support unlocking multiple inputs owned by the same address. Defined in <a href='../TIP-0045/tip-0045.md#reference-unlock'>TIP-45 (Reference Unlock)</a>.</blockquote>
      </details>
      <details>
        <summary>Account Unlock</summary>
        <blockquote>Points to the unlock of a consumed Account Output. Defined in <a href='../TIP-0042/tip-0042.md#account-unlock'>TIP-42 (Account Unlock)</a>.</blockquote>
      </details>
      <details>
        <summary>NFT Unlock</summary>
        <blockquote>Points to the unlock of a consumed NFT Output. Defined in <a href='../TIP-0043/tip-0043.md#nft-unlock'>TIP-43 (NFT Unlock)</a>.</blockquote>
      </details>
      <details>
        <summary>Multi Unlock</summary>
        <blockquote>Unlocks a Multi Address with a list of other unlocks. Defined in <a href='../TIP-0052/tip-0052.md#multi-unlock'>TIP-52 (Multi Unlock)</a>.</blockquote>
      </details>
    </td>
  </tr>
</table>

### Output ID Proof

TIP-20 introduced an Inputs Commitment in the transaction to prevent
[an attack vector](https://github.com/iotaledger/tips/discussions/51) on the client. Consider a client requesting Output
IDs from a node which it wants to use as inputs to a transaction. The client has no way to check whether the received
Outputs correspond to the Output IDs it requested. While the Output ID technically depends on the content of the actual
output, a client has no way of validating this without access to the original transaction. A client will only include
the Output ID in a transaction as an input, not the entire output. Hence, if a client receives fake outputs from a
malicious node, it might end up producing a transaction that consumes an output it did not intend to consume. For that
reason the Inputs Commitment was introduced, which provides a cryptographic commitment to the _content_ of all used
inputs. This enables the protocol to detect such attacks, since the transaction would be invalid if the client used a
(e.g. fake) output for their transaction that does not match the one stored by the nodes in the ledger.

This TIP removes the Inputs Commitment and introduces an Output Commitment through which the Transaction ID becomes
dependent on the outputs it creates. This is used to create proofs which a client can use to verify that an Output ID
indeed belongs to a certain Output. This means that instead of the protocol checking the Inputs Commitment to prevent
the above-mentioned attack, this responsibility now falls to the client, which, when fetching an Output for a certain
Output ID, receives the output as well as the corresponding proof for its Output ID. The client can trustlessly verify
that the output and its ID match which in turn renders the Inputs Commitment unnecessary.

More generally, this setup is also useful to prove that a given transaction produced an output with a certain state.

Such an Output ID Proof is a [merkle proof](#merkle-proof), with the array of the serialized `Outputs` as the `Leaves`
of the tree.

A proof is serialized as follows:

<details>
  <summary>Output ID Proof</summary>
  <blockquote>A merkle proof that allows for cryptographic verification that an Output ID belongs to a given Output.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Slot</td>
    <td>uint32</td>
    <td>The slot in which the Output was created.</td>
  </tr>
  <tr>
    <td>Output Index</td>
    <td>uint16</td>
    <td>The index of the output in the transaction.</td>
  </tr>
  <tr>
    <td>Transaction Commitment</td>
    <td>ByteArray[32]</td>
    <td>The commitment to the transaction.</td>
  </tr>
  <tr>
    <td valign="top">Output Commitment Proof <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Node</summary>
        <blockquote>A merkle tree node that contains two child components. Defined in <a href='../TIP-0045/tip-0045.md#node'>TIP-45 (Node)</a>.</blockquote>
        <table>
          <tr>
            <td>
              <b>Name</b>
            </td>
            <td>
              <b>Type</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr>
            <td>Merkle Tree Component Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 0</strong> to denote a <i>Node</i>.</td>
          </tr>
          <tr>
            <td valign="top">Left <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Node</summary>
                <blockquote>A merkle tree node that contains two child components. Defined in <a href='../TIP-0045/tip-0045.md#node'>TIP-45 (Node)</a>.</blockquote>
              </details>
              <details>
                <summary>Leaf Hash</summary>
                <blockquote>Contains the hash of a leaf in the tree. Defined in <a href='../TIP-0045/tip-0045.md#leaf-hash'>TIP-45 (Leaf Hash)</a>.</blockquote>
              </details>
              <details>
                <summary>Value Hash</summary>
                <blockquote>Contains the hash of the value for which the proof is being computed. Defined in <a href='../TIP-0045/tip-0045.md#value-hash'>TIP-45 (Value Hash)</a>.</blockquote>
              </details>
            </td>
          </tr>
          <tr>
            <td valign="top">Right <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Node</summary>
                <blockquote>A merkle tree node that contains two child components. Defined in <a href='../TIP-0045/tip-0045.md#node'>TIP-45 (Node)</a>.</blockquote>
              </details>
              <details>
                <summary>Leaf Hash</summary>
                <blockquote>Contains the hash of a leaf in the tree. Defined in <a href='../TIP-0045/tip-0045.md#leaf-hash'>TIP-45 (Leaf Hash)</a>.</blockquote>
              </details>
              <details>
                <summary>Value Hash</summary>
                <blockquote>Contains the hash of the value for which the proof is being computed. Defined in <a href='../TIP-0045/tip-0045.md#value-hash'>TIP-45 (Value Hash)</a>.</blockquote>
              </details>
            </td>
          </tr>
        </table>
      </details>
      <details>
        <summary>Value Hash</summary>
        <blockquote>Contains the hash of the value for which the proof is being computed. Defined in <a href='../TIP-0045/tip-0045.md#value-hash'>TIP-45 (Value Hash)</a>.</blockquote>
        <table>
          <tr>
            <td>
              <b>Name</b>
            </td>
            <td>
              <b>Type</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr>
            <td>Merkle Tree Component Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 2</strong> to denote a <i>Value Hash</i>.</td>
          </tr>
          <tr>
            <td>Hash</td>
            <td>(uint8)ByteArray</td>
            <td>The hash of the value.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>

By computing the [merkle root](#merkle-root) from the `Output Commitment Proof` the [Transaction ID](#transaction-id)
and Output ID can be reconstructed, using the other fields of the proof. The `Output ID Proof` can thus be used to prove
that a given Output ID was derived from a given Output.

### Transaction ID

A Transaction ID consists of two commitments, the _Transaction Commitment_ and the _Ouptut Commitment_. It is a
`ByteArray[36]` which is computed as follows:

- Let `Transaction Bytes` be the concatenated serialization of the fields from `Network ID` to `Payload`.
- Let `Transaction Commitment` be the BLAKE2b-256 hash of `Transaction Bytes`.
- Let `Output Commitment` be the [merkle root](#merkle-root) over the merkle tree with the serialized `Outputs` as its
  `Leaves`.
- Let `ID` be the BLAKE2b-256 of the concatenation of `Transaction Commitment` and `Output Commitment`.
- Construct the `Transaction ID` as the concatenation of the `ID` and the little-endian encoded `Creation Slot`.

### Network ID

The `Network ID` field of the transaction serves as a
[replay protection mechanism](https://github.com/iotaledger/tips/discussions/56). It is a unique value denoting whether
the transaction was meant for the IOTA mainnet, shimmer, testnet-1, or a private network. It consists of the first 8
bytes of the BLAKE2b-256 hash of the `Network Name` protocol parameter, interpreted as an unsigned integer number.

| Network Name        | Resulting `Network ID` | Network Name defined in                             |
| ------------------- | ---------------------- | --------------------------------------------------- |
| `iota-mainnet`      | `9374574019616453254`  | [TIP-22](../TIP-0022/tip-0022.md#detailed-design)   |
| `shimmer`           | `14364762045254553490` | [TIP-32](../TIP-0032/tip-0032.md#global-parameters) |
| `testnet-1`         | `1856588631910923207`  | -                                                   |
| `example-mynetwork` | `1967754805504104511`  | -                                                   |

### Creation Slot

The transaction timestamp is expressed as a `Slot Index`, as there is no need for finer granularity. The validity of the
transaction timestamp is checked in comparison with the `Block` timestamp. Therefore, it is performed at the level of
semantic validation of a block, described in [TIP-0046](../TIP-0046/tip-0046.md).

### Inputs

The `Inputs` field holds the inputs to consume in order to fund the outputs of the <i>Transaction Payload</i>.
Currently, there is one type of input:

- _UTXO Input_.

Each input must be accompanied by a corresponding <i>Unlock</i> at the same index in the <i>Unlocks</i> part of the
<i>Transaction Payload</i>.

#### UTXO Input

A <i>UTXO Input</i> is an input which references an unspent output of a previous transaction. This UTXO is uniquely
identified by its _Output ID_, defined by the _Transaction ID_ of the creating transaction together with corresponding
output index. Each <i>UTXO Input</i> must be accompanied by an <i>Unlock</i> that is allowed to unlock the referenced
output.

<details>
  <summary>UTXO Input</summary>
  <blockquote>Describes an input which references an unspent transaction output to consume.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Input Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 0</strong> to denote a <i>UTXO Input</i>.</td>
  </tr>
  <tr>
    <td>Transaction ID</td>
    <td>ByteArray[36]</td>
    <td>The identifier of the transaction that created the referenced output.</td>
  </tr>
  <tr>
    <td>Transaction Output Index</td>
    <td>uint16</td>
    <td>The output index of the referenced output.</td>
  </tr>
</table>

### Context Inputs

The `Context Inputs` field holds inputs that provide additional contextual information for the execution of a
transaction, such as for different functionality related to accounts, commitments, or Mana rewards. Context inputs do
not need to be unlocked. This TIP defines 3 types of context inputs:

- _Commitment Input_.
- _Block Issuance Credit Input_.
- _Reward Input_.

#### Commitment Input

A _Commitment Input_ allows referencing a commitment to a certain slot. It is used to provide a notion of time for
transaction execution that is linked to the containing _Block_'s _Issuing Time_. It proves that the time at the
transaction execution is past a certain slot in the past, as the slot has already been committed. The slot reference is
expressed as the _Commitment ID_ and can be resolved to the _Commitment_ value before executing the transaction. The
_Commitment_ itself provides the `Slot Index` which serves as the time reference. A Block that contains a transaction
with a Commitment input has additional validation rules as defined in [TIP-0046](../TIP-0046/tip-0046.md). Only one
_Commitment Input_ may be present in a transaction.

It is serialized as follows:

<details>
  <summary>Commitment Input</summary>
  <blockquote>A Commitment Input allows referencing a commitment to a certain slot and is used to provide a notion of time for transaction execution that is linked to the containing Block's <code>Issuing Time</code>.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Input Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Commitment Input</i>.</td>
  </tr>
  <tr>
    <td>Commitment ID</td>
    <td>ByteArray[36]</td>
    <td>The commitment identifier to reference to.</td>
  </tr>
</table>

#### Block Issuance Credit Input

A _Block Issuance Credit Input_ provides the BIC balance of a specific account as context to transaction execution of a
specific slot. It is required for any _Account_ transition and destruction if the account contains a _Block Issuer
Feature_, as any operation on the _Account_ can only be allowed if the BIC balance is non-negative at a specific point
in time. A _Block Issuance Credit Input_ always requires a _Commitment Input_. The input will be resolved to the BIC
value of the account identified by `Account ID` at the `Slot Index` given by the _Commitment Input_. Multiple _Block
Issuance Credit Inputs_ can be present in a single transaction to provide the BIC for different accounts; however, no
two _Block Issuance Credits Inputs_ can reference the same account.

It is serialized as follows:

<details>
  <summary>Block Issuance Credit Input</summary>
  <blockquote>A Block Issuance Credit Input provides the BIC balance of a specific account as context to transaction execution.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Input Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 2</strong> to denote a <i>Block Issuance Credit Input</i>.</td>
  </tr>
  <tr>
    <td>Account ID</td>
    <td>ByteArray[32]</td>
    <td>The ID of the Account for which this input provides the BIC.</td>
  </tr>
</table>

#### Reward Input

A _Reward Input_ indicates which transaction `Input` is claiming Mana rewards. It can reference an _Account Output_ with
a _Staking Feature_ or a _Delegation Output_. The input is resolved by calculating the total amount of rewards the
respective output can claim which is provided as context for transaction execution. The amount of rewards that can be
claimed is added to the total sum of Mana on the input side of the transaction. Multiple such inputs can be present in a
single transaction to claim rewards for different outputs; however, no two _Reward Inputs_ can reference the same index.

It is serialized as follows:

<details>
  <summary>Reward Input</summary>
  <blockquote>A Reward Input indicates which transaction Input is claiming Mana rewards.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Input Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 3</strong> to denote a <i>Reward Input</i>.</td>
  </tr>
  <tr>
    <td>Index</td>
    <td>uint16</td>
    <td>The index of the transaction input for which to claim rewards.</td>
  </tr>
</table>

### Outputs

The `Outputs` field holds the outputs that are created by the <i>Transaction Payload</i>. There are different output
types, but they must all have an `Amount` field denoting the number of IOTA coins to deposit.

### Allotments

The `Allotments` field contains the list of all Mana allotments, the `Account ID`, and corresponding values that
converts Mana provided by the inputs in the form of stored Mana in inputs or potential Mana derived from the inputs'
IOTA coins. Mana listed in this field will be added upon commitment of the slot in which the transaction was issued, in
form of _Block Issuance Credits_ to the account's BIC value.

Note that _Block Issuance Credits_ are used to pay for the block issuance, they are burned on the slot commitment of the
issuance slot. The good practice would be to always allot enough Mana to cover for the block issuance.

### Payload

The _Transaction_ itself can contain another payload as described in general in [TIP-46](../TIP-0046/tip-0046.md). The
[semantic validity](#semantic-validation) of the encapsulating _Transaction Payload_ is unaffected by the possibly
contained payload.

### Transaction Capabilities

Transaction Capabilities are represented as a `ByteArray` with a length prefix. For the transaction that contains them
to be valid, the following conditions must hold:

- The length prefix must be `0` or `1`.
  - This condition may be relaxed in the future and implementations should already allow for greater lengths.
- Bit indices start at `0`. For each byte, they are counted starting from the least-significant bit. If there was a
  previous byte, the indices continue where the previous byte's indices left off.
  - For example: In a list of two bytes with the bit patterns `0001 0000` and `0000 0100`, bits with indices `4` and
    `10` are set.

#### Capability Flags

The following table shows the mapping from the bit pattern to the capability flags, where the `Flag Index` is the index
of the bit.

This list is an Allowlist: If the bit is `1` (**set**) the transaction has the capability, if the bit is `0` (**unset**)
it does not have it.

| Flag Index | Capability (if flag is set)  |
| ---------- | ---------------------------- |
| 0          | Can burn Native Tokens.      |
| 1          | Can burn Mana.               |
| 2          | Can destroy Account Outputs. |
| 3          | Can destroy Anchor Outputs.  |
| 4          | Can destroy Foundry Outputs. |
| 5          | Can destroy NFT Outputs.     |

The transaction validation rules for each flag are defined where the respective asset to which it applies is defined.

### Unlocks

The `Unlocks` field holds the unlocks which unlock the inputs in a _Transaction_.

#### Signature Unlock

The <i>Signature Unlock</i> holds a signature signing the BLAKE2b-256 hash of the serialized `Transaction` field. It is
serialized as follows:

<details>
  <summary>Signature Unlock</summary>
  <blockquote>Unlocks the address derived from the contained Public Key in the transaction in which it is contained in.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Unlock Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 0</strong> to denote a <i>Signature Unlock</i>.</td>
  </tr>
  <tr>
    <td valign="top">Signature <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Ed25519 Signature</summary>
        <blockquote>An Ed25519 Signature with the public key that verifies it. Defined in <a href='../TIP-0038/tip-0038.md#ed25519-signature'>TIP-38 (Ed25519 Signature)</a>.</blockquote>
        <table>
          <tr>
            <td>
              <b>Name</b>
            </td>
            <td>
              <b>Type</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr>
            <td>Signature Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.</td>
          </tr>
          <tr>
            <td>Public Key</td>
            <td>ByteArray[32]</td>
            <td>The Ed25519 public key that verifies the signature.</td>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature that must be verified according to <a href='../TIP-0014/tip-0014.md'>TIP-14</a>.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>

##### Signature Unlock Syntactic Validation

- `Signature` must contain an _Ed25519 Signature_.
- The _Signature Unlock_ must be unique, i.e., there must not be any other _Signature Unlocks_ in the `Unlocks` field of
  the transaction payload with the same signature.

##### Signature Unlock Semantic Validation

- The `Signature Type` must match the `Address Type` of the UTXO.
- The BLAKE2b-256 hash of `Public Key` must match the `Address` of the UTXO.
- The `Signature` field must contain a signature, signing the BLAKE2b-256 hash of the serialized `Transaction` field
  which is validated by the `Public Key`.

#### Reference Unlock

The <i>Reference Unlock</i> references a previous <i>Unlock</i> (which must not be another <i>Reference Unlock</i>). It
**must** be used if multiple inputs can be unlocked via the same <i>Unlock</i>. It is serialized as follows:

<details>
  <summary>Reference Unlock</summary>
  <blockquote>References a previous unlock to support unlocking multiple inputs owned by the same address.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Unlock Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Reference Unlock</i>.</td>
  </tr>
  <tr>
    <td>Reference</td>
    <td>uint16</td>
    <td>Represents the index of a previous unlock.</td>
  </tr>
</table>

##### Reference Unlock Syntactic Validation

- The _Reference Unlock_ at index `i` must have `Reference < i` and the unlock at index `Reference` must be a _Signature
  Unlock_.

Example: Consider a <i>Transaction</i> containing the <i>UTXO Inputs</i> 0, 1 and 2, where 0 and 2 are both spending
outputs belonging to the same Ed25519 address `A` and 1 is spending from a different address `B`. This results in the
following structure of the <i>Unlocks</i> part:

| Index | Unlock                                                                               |
| ----- | ------------------------------------------------------------------------------------ |
| 0     | A _Signature Unlock_ holding the Ed25519 signature for address `A`.                  |
| 1     | A _Signature Unlock_ holding the Ed25519 signature for address `B`.                  |
| 2     | A _Reference Unlock_ which references 0, as both require the same signature for `A`. |

##### Reference Unlock Semantic Validation

- The _Signature Unlock_ at index `Reference`, to which the _Reference Unlock_ at index `i` points, must be a
  [semantically valid signature unlock](#signature-unlock-semantic-validation) for the input at index `i`.

### Work Score

Let the work score of a transaction be defined as follows.

- Let `Size Score` be `Work Score Parameters::DataByte * Transaction Size` where `Transaction Size` is the size of the
  serialized _Transaction_.
- Let `Input Score` be `Inputs Count * Work Score Parameters::Input`.
- Let `Context Input Score` be `Context Inputs Count * Work Score Parameters::Context Input`.
- Let `Output Score` be the sum of work scores of each output `Output` in `Outputs`:
  - Let `Native Token Score` be `Work Score Parameters::Native Token * Native Tokens Count` if `Output` contains
    `Native Tokens`, `0` otherwise.
  - Let `Token Scheme Score` be `Work Score Parameters::Native Token` if `Output` contains a _Simple Token Scheme_, `0`
    otherwise.
  - Let `Staking Score` be `Work Score Parameters::Staking` if `Output` contains a _Staking Feature_, `0` otherwise.
  - Let `Block Issuer Score` be `Work Score Parameters::Block Issuer` if `Output` contains a _Block Issuer Feature_, `0`
    otherwise.
  - Return
    `Work Score Parameters::Output + Native Token Score + Token Scheme Score + Staking Score + Block Issuer Score`.
- Let `Allotment Score` be `Work Score Parameters::Allotment * Allotments Count`.
- Let `Signature Score` be the sum of work scores of the signatures contained in _Signature Unlocks_ within `Unlocks`.
  - Signature work scores are defined in TIP-46.
- Return `Size Score + Input Score + Context Input Score + Output Score + Allotment Score + Signature Score`.

## Validation

A <i>Transaction Payload</i> has different validation stages since some validation steps can only be executed when
certain information has (or has not) been received. We therefore distinguish between syntactic and semantic validation.

The different output types and optional output features introduced by [TIP-38](../TIP-0038/tip-0038.md),
[TIP-1](../TIP-0042/tip-0041.md),[TIP-42](../TIP-0042/tip-0042.md), [TIP-43](../TIP-0043/tip-0043.md) and
[TIP-44](../TIP-0044/tip-0044.md) add additional constraints to the transaction validation rules, but since these are
specific to the given outputs and features, they are discussed for each
[output type](../TIP-0038/tip-0038.md#output-design) and [feature type](../TIP-0038/tip-0038.md#features) separately.

### Syntactic validation

Syntactic validation is checked as soon as the transaction has been received. It validates the structure but not the
signatures of the transaction. If the transaction does not pass this stage, it must not be broadcast further and can be
discarded right away.

The following criteria defines whether a payload passes the syntactical validation:

- Transaction:
  - `Network ID` must match the value of the current network.
  - `CreationTime` must be a valid `Slot index` timestamp.
  - Inputs:
    - `Inputs Count` must be `0 < x ‚â§ Max Inputs Count`.
    - For each input the following must be true:
      - `Input Type` must denote an allowed input type, listed in section [Inputs](#inputs).
      - `Transaction Output Index` must be `0 ‚â§ x < Max Outputs Count`.
    - Each pair of `Transaction ID` and `Transaction Output Index` must be unique in the list of inputs.
  - Context Inputs:
    - `Context Inputs Count` must be `0 ‚â§ x ‚â§ Max Inputs Count`.
    - `Context Input Type` must denote an allowed input type, listed in section [Context Inputs](#context-inputs).
    - There must be zero or one _Commitment Input_.
    - All _Rewards Inputs_ must reference a different `Index` and it must hold that: `Index <= Max Inputs Count`.
    - All _Block Issuance Credit Inputs_ must reference a different `Account ID`.
  - Outputs:
    - `Outputs Count` must be `0 < x ‚â§ Max Outputs Count`.
    - For each output the following must be true:
      - `Output Type` must match one of the values described under [Outputs](#outputs).
      - The output itself must pass syntactic validation.
    - The sum of all `Amount` fields must not exceed `Max IOTA Supply`.
    - The sum of all `Mana` fields must not exceed <code>2<sup>Mana Bits Count</sup> - 1</code>.
    - The count of all distinct native tokens present in outputs must not be larger than `Max Native Token Count`.
  - Allotments:
    - `Allotments Count` must be `0 ‚â§ x ‚â§ 128`.
    - The sum of all `Mana` fields must not exceed <code>2<sup>Mana Bits Count</sup> - 1</code>.
    - Every `Mana` field in an Allotment must be `> 0`.
    - There must be no duplicated `AccountID`s in the list of allotments.
    - Each entry in `Allotments` must be lexicographically ordered based on its `Account ID`.
  - Payload (if present):
    - `Payload Type` must match one of the values described under [Payload](#payload).
    - Payload fields must be correctly parsable in the context of the `Payload Type`.
    - The payload itself must pass syntactic validation.
- Unlocks:
  - `Unlocks Count` must match `Inputs Count` of the _Transaction_.
  - For each unlock the following must be true:
    - Each `Unlock Type` must match one of the values described under [Unlocks](#unlocks).
    - The unlock itself must pass syntactic validation.
- Given the type and length information, the _Transaction Payload_ must consume the entire byte array of the `Payload`
  field of the encapsulating object.

### Semantic validation

The Semantic validation of a _Transaction Payload_ is performed when its encapsulating block is confirmed. The semantic
validity of transactions depends on the partial order in which they are processed. The solidification mechanism of the
protocol ensures that all inputs will be processed only when all inputs are known valid, and not conflicting.

Processing transactions according to its partial-ordering enables users to spend UTXOs which are created at similar
point in time, but the input transaction has not yet been confirmed by the network, as they will be processed by
preserving their input-output order relations. In this case, it is recommended that users include the _Block ID_ of the
funding transaction as a parent of the block containing the spending transaction.

#### Transaction Semantic Validation

- Each input must reference a valid UTXO, i.e., the output referenced by the input's `Transaction ID` and
  `Transaction Output Index` is known (booked) and unspent.
- All _Reward Inputs_ must reference a Delegation Output or an Account Output which contains a Staking Feature.
- The transaction must spend the entire coin balance, i.e., the sum of the `Amount` fields of all the UTXOs referenced
  by inputs must match the sum of the `Amount` fields of all outputs.
- Each unlock must be valid with respect to the UTXO referenced by the input of the same index, according to their
  respective semantic unlock validation rules.
- If a _Transaction Payload_ passes the semantic validation, its referenced UTXOs must be marked as spent and its new
  outputs must be created/booked in the ledger.
- Transactions that do not pass semantic validation are ignored. Their UTXOs are not marked as spent and their outputs
  are not booked in the ledger.

**Mana specific semantic validation rules** (for description of Mana dynamics and the Mana decay, see
[TIP-39](../TIP-0039/tip-0039.md)):

- The transaction must not spend more Mana than allowed, briefly it must given following definitions:

* `potentialMana` sum of values for each UTXO in inputs based on their creation times, transaction creation slot, and
  decay function
* `allottedMana` as sum of all block issuance credits listed in `Allotments` transaction field.
* `inputStoredMana` sum of stored Mana from inputs decayed by `Decayfactor`
* `outputStoredMana` sum of stored Mana from outputs comply that:
  `potentialMana + inputStoredMana ‚â• allottedMana + outputStoredMana` The less or equal sign in the formula above
  implies that it is possible for a user not to allot all the Mana he/she has rights to. This requirement is needed in
  the case, because of any particularity, a user does not want to own Mana at all. Then, the user must be able to refuse
  to allot or store their potential Mana. More specifically, for a transaction consuming a set of unspent outputs, we
  have the following validation rule for Mana:

<code>Potential Mana Generated + Decayed Stored Mana ‚â• Mana<sub>o</sub> + Mana<sub>a</sub></code>,

where:

- `Potential Mana Generated` is the sum of all potential Mana values generated by consuming inputs (unspent outputs). To
  calculate each summand of the sum, the algorithm and lookup table defined in [TIP-39](../TIP-0039/tip-0039.md) must be
  used.
- `Decayed Stored Mana` is the sum of all stored Mana values on the consuming inputs (unspent outputs) with applied
  decay. To calculate each summand of the sum, the algorithm and lookup table defined in
  [TIP-39](../TIP-0039/tip-0039.md) must be used.
- <code>Mana<sub>o</sub></code> is the sum of all Mana values transferred to the outputs as stored Mana.
- <code>Mana<sub>a</sub></code> is the amount of all Mana values transferred to the accounts as block issuance credit.

## Miscellaneous

### Address reuse

While, in contrast to Winternitz one-time signatures (W-OTS), producing multiple Ed25519 signatures for the same private
key and address does not decrease its security, it still drastically reduces the privacy of users. It is thus considered
best practice that applications and services create a new address per deposit to circumvent these privacy issues.

In essence, Ed25519 support allows for smaller transaction sizes and to safely spend funds which were sent to an already
used deposit address. Ed25519 addresses are not meant to be used like email addresses. See this
[Bitcoin wiki article](https://en.bitcoin.it/wiki/Address_reuse) for further information.

# Drawbacks

- The new transaction format is the core data type within the IOTA ecosystem. Changing it means that all projects need
  to accommodate it, including wallets, web services, client libraries, and applications using IOTA in general. It is
  not possible to keep these changes backwards compatible, meaning that all nodes must upgrade to further participate in
  the network.
- It is not possible to produce a valid transaction without having access to the content of the consumed outputs.

# Rationale and Alternatives

- _Network ID_ is an explicit field in the transaction while it could be made a configuration parameter for the
  signature generating process. In this scenario, the signature would be invalid if the parameter on client and network
  side mismatch. While this would reduce the size of a transaction, it would make it impossible to debug the reason for
  having an invalid signature and transaction. With the current solution we intend to optimize for ease of development.
- Uniqueness of all inputs is kept as it prevents introducing double spends in the same transaction.

# Test Vectors

## Transaction ID

The following shows a transaction and its computed Transaction ID.

Transaction (json-encoded):

```json
{
  "type": 1,
  "transaction": {
    "networkId": "14147312347886322761",
    "creationSlot": 1048576,
    "contextInputs": [
      {
        "type": 1,
        "commitmentId": "0x760702593b59500420722f3a1634005f11360b133a030f46282c0f690a55084855000000"
      },
      {
        "type": 2,
        "accountId": "0x3407603d0f725b7e7214205f254305743d5362512f36153236435e796b6a1c2e"
      },
      {
        "type": 3,
        "index": 0
      }
    ],
    "inputs": [
      {
        "type": 0,
        "transactionId": "0x3ca1f23b83708ee7c59d6d7fe71453106bb0a0abc1c9cc4b340c755238ae6daa00000000",
        "transactionOutputIndex": 0
      },
      {
        "type": 0,
        "transactionId": "0xecb673f194640b2067b8da136b5f5437c2c723e7f3fdaa53984d7588ed21071a00000000",
        "transactionOutputIndex": 0
      }
    ],
    "allotments": [
      {
        "accountID": "0x0e0f253479566103415e29060f79772445531564733e214b54084358413f7c70",
        "value": "6648"
      },
      {
        "accountID": "0x445e204c1f747503106b5663664c43591e63235804057c445d073a5f10597e2d",
        "value": "9988"
      }
    ],
    "capabilities": "0x01",
    "outputs": [
      {
        "type": 0,
        "amount": "100000",
        "mana": "0",
        "unlockConditions": [
          {
            "type": 0,
            "address": {
              "type": 0,
              "pubKeyHash": "0x7f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e"
            }
          }
        ],
        "features": [
          {
            "type": 4,
            "id": "0x082a1c2429352945216e3f547a03226b2f014d3d2e185a2459473a362c4d124d511a6c2d6000",
            "amount": "0xd54f92ae8c34fbb4"
          }
        ]
      },
      {
        "type": 1,
        "amount": "100000",
        "mana": "5000",
        "accountId": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "stateIndex": 0,
        "foundryCounter": 0,
        "unlockConditions": [
          {
            "type": 4,
            "address": {
              "type": 0,
              "pubKeyHash": "0x7f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e"
            }
          },
          {
            "type": 5,
            "address": {
              "type": 0,
              "pubKeyHash": "0x7f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e"
            }
          }
        ],
        "features": [
          {
            "type": 2,
            "data": "0x1e69562e763b1125080c1a7161390e42"
          }
        ]
      }
    ]
  },
  "unlocks": [
    {
      "type": 0,
      "signature": {
        "type": 0,
        "publicKey": "0xa6bbccb2380a3a941a7bfdd5f2afcb8a6f5236bbe12ae8b931b593efd76864b6",
        "signature": "0x98a18fd0083c7d9b6b05e218c7f764bb915148762ce342d795f7acac4083b40dbfc01f5fd23f6d1e652eee0e5951b87dd6307adf1389f8f16c08ade12be01c0a"
      }
    },
    {
      "type": 1,
      "reference": 0
    }
  ]
}
```

Transaction (binary-encoded):

```
0x01490443ee9f5955c400001000030001760702593b59500420722f3a1634005f11360b133a030f46282c0f690a55084855000000023407603d0f725b7e7214205f254305743d5362512f36153236435e796b6a1c2e0300000200003ca1f23b83708ee7c59d6d7fe71453106bb0a0abc1c9cc4b340c755238ae6daa00000000000000ecb673f194640b2067b8da136b5f5437c2c723e7f3fdaa53984d7588ed21071a00000000000002000e0f253479566103415e29060f79772445531564733e214b54084358413f7c70f819000000000000445e204c1f747503106b5663664c43591e63235804057c445d073a5f10597e2d0427000000000000010100000000020000a08601000000000000000000000000000100007f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e0104082a1c2429352945216e3f547a03226b2f014d3d2e185a2459473a362c4d124d511a6c2d6000b4fb348cae924fd500000000000000000000000000000000000000000000000001a08601000000000088130000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000204007f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e05007f34f61bd0ecd2654a1ec3c9bf3fbc0de91abcbd7397e09faaaffc89d17a8f6e010210001e69562e763b1125080c1a7161390e420002000000a6bbccb2380a3a941a7bfdd5f2afcb8a6f5236bbe12ae8b931b593efd76864b698a18fd0083c7d9b6b05e218c7f764bb915148762ce342d795f7acac4083b40dbfc01f5fd23f6d1e652eee0e5951b87dd6307adf1389f8f16c08ade12be01c0a010000
```

Transaction ID:

```
0x4125a5129ece49933dc24a38df82ecf62dd107bd07403648cb935478f394fc5a00001000
```

## Output ID Proof

### Single Output

An Output ID Proof for a transaction with a single output.

Transaction (1 Output) (binary-encoded):

```
0x490443ee9f5955c4cf1fe14d00000100002aa135e8d314aed6c1576616e2d38b73589a221f914e2036938ff3294a1a04760000000001000000000000000001000040420f00000000000000000000000000010000150e514b09393e50122d27267510724c036743754277443079355c07152f222500
```

Output ID Proof (Output Index 0) (json-encoded):

```json
{
  "slot": 1306599375,
  "outputIndex": 0,
  "transactionCommitment": "0xf19781740f56e40014579adb74ca05c0d41d7395458e0c28f85204b4c3831a41",
  "outputCommitmentProof": {
    "type": 2,
    "hash": "0x399c949535c72bb4b696dd1569f63915b5dd26822e7138349dde74a619ebe46a"
  }
}
```

Output ID Proof (Output Index 0) (binary-encoded):

```
0xcf1fe14d0000f19781740f56e40014579adb74ca05c0d41d7395458e0c28f85204b4c3831a410220399c949535c72bb4b696dd1569f63915b5dd26822e7138349dde74a619ebe46a
```

### Five Outputs

An Output ID Proof for a transaction with five outputs (not a power of two number of outputs).

Transaction (5 Outputs) (binary-encoded):

```
0x490443ee9f5955c42a69480400000100002aa135e8d314aed6c1576616e2d38b73589a221f914e2036938ff3294a1a04760000000001000000000000000020000040420f000000000000000000000000000100004e6614257d0f11460315281e11274b272d465c0c06087778294b6e3e505f3200000040420f00000000000000000000000000010000424f1f695e16503f76476f7d541d051c016b130d502e4f3b502249152c5b7c54000040420f000000000000000000000000000100002d1a401d1470606f21733a184f3f4a713010651a2211033a690b3c6f21015c52000040420f00000000000000000000000000010000150c0d09214a7e6f4d11645f6d24406f6c3950090f782b37440d2719134f070d000040420f00000000000000000000000000010000652e08620a3b4c436d4a120b5d2f20723374403754232166792e4a29000e0f13000040420f00000000000000000000000000010000587b322e037420120c51576b2e2e4d205c3d46080c1d2971055c1a2069794838000040420f000000000000000000000000000100001f6311134d4736093340793d363459186943670103561f2d20436a090e3e451d000040420f00000000000000000000000000010000680113416907254311613a111a2b5b735f6e436c11220a372f0e5d28507c454a000040420f0000000000000000000000000001000034492d4f734b011f4878120053534c5f424066517b652f3609171a1e0c190709000040420f000000000000000000000000000100003b02352954251034220943153c631f6473595f6e5a2c157351606850621a1a5b000040420f000000000000000000000000000100005171045931294f265b675b1c3d557e0a5f56072e4a630b597b32742f65572e1e000040420f000000000000000000000000000100003c713b3d2d5e1f4b0348711b714c2b5e657e1968061c4e372e3d4b6921062331000040420f000000000000000000000000000100002c6f2a4741107c412f39593d4742457171630541721f6c4b7a3a04190e0a721c000040420f000000000000000000000000000100000f38217d311079404a0a7a762b0f125972795f22561577776a31415b531e173c000040420f000000000000000000000000000100007d1d1f5a7a2d492123187721446527791f5d172454495c0146683b6417567448000040420f0000000000000000000000000001000026586b714d20651e7d05032d7c2f431e2311174910237d725065502062195934000040420f0000000000000000000000000001000065287565632a66420063022f253f4564447624704f503b102a37610028246a7e000040420f00000000000000000000000000010000024a04246574032502172a36640d1935462714311f78120127581d47714f6d49000040420f00000000000000000000000000010000383d6958267d415462515d70590d160e09262c103e6a5b27334a2c0b3b644f79000040420f0000000000000000000000000001000065552c286513794c4769340f6d492f627337411b2a3f0f6558256d0d3c593b0c000040420f000000000000000000000000000100000f7573063d626b1163490a4362262a3a3044366d2d7d6a5e470a03675c121c26000040420f000000000000000000000000000100006e05524732705e325f651b3c0f1f045e1a6f23610e1b2066795e5a05116d3f24000040420f0000000000000000000000000001000034471553696a0031045b666d7a0b2c761260023a376a101e057556147d551c70000040420f00000000000000000000000000010000615e0716310e0326304a45552b4e6a1d7c4403704b240f1430643c5b513a4961000040420f00000000000000000000000000010000157c721907161a173e780d4e09285f4467422b790715335964765d3c4d205a0f000040420f000000000000000000000000000100003109614f3a1c511b442a2b1b5032393b3811216757577960745b4b623c447d2e000040420f00000000000000000000000000010000536133335c0867403f7a2a300e453d57205d595a66775e4634575e4803526709000040420f000000000000000000000000000100007424116251541033114a6277472b5017013b0f02225d363c493915647d107602000040420f00000000000000000000000000010000477862677e1a3b4a352f657355421a433a172a045c22306c406a594e65653d56000040420f00000000000000000000000000010000555d6964565e082a7248670537242266503c5e2f37735e3a2f14413163703978000040420f000000000000000000000000000100000c767a111356470e0f553f1b3e1a45431b6d745036505d23121f4d7e03594d27000040420f000000000000000000000000000100003c51753a1e207b4c4b6f4e6419161a393807104316584d0b1d7955766825521b00
```

Output ID Proof (Output Index 2) (json-encoded):

```json
{
  "slot": 1688515374,
  "outputIndex": 2,
  "transactionCommitment": "0x136e4de73da82ea76984d400a4d71fd827f54d05a411519870e6b12dfd6f715c",
  "outputCommitmentProof": {
    "type": 0,
    "l": {
      "type": 0,
      "l": {
        "type": 1,
        "hash": "0x246e927334aa19300bd2e329e9b89f2a6cc317c14e26eef1974a70532df4e8d3"
      },
      "r": {
        "type": 0,
        "l": {
          "type": 2,
          "hash": "0x2acb2638e5245e2a6e8fbf6ed3fce77d51dbd64d12d04663f3634f43edc62b71"
        },
        "r": {
          "type": 1,
          "hash": "0xf6487a13fb0700732b6933f0ddbacb01ee5d282dd730fc08160fee2825be9f45"
        }
      }
    },
    "r": {
      "type": 1,
      "hash": "0xa7226628c1173a6b8fef343b51fddcd140f283b8736838759183b179fad5e396"
    }
  }
}
```

Output ID Proof (Output Index 2) (binary-encoded):

```
0x2eb3a4640200136e4de73da82ea76984d400a4d71fd827f54d05a411519870e6b12dfd6f715c00000120246e927334aa19300bd2e329e9b89f2a6cc317c14e26eef1974a70532df4e8d30002202acb2638e5245e2a6e8fbf6ed3fce77d51dbd64d12d04663f3634f43edc62b710120f6487a13fb0700732b6933f0ddbacb01ee5d282dd730fc08160fee2825be9f450120a7226628c1173a6b8fef343b51fddcd140f283b8736838759183b179fad5e396
```

### 32 Outputs

An Output ID Proof for a transaction with 32 outputs.

Transaction (32 Outputs) (binary-encoded):

```
0x490443ee9f5955c42a69480400000100002aa135e8d314aed6c1576616e2d38b73589a221f914e2036938ff3294a1a04760000000001000000000000000020000040420f000000000000000000000000000100004e6614257d0f11460315281e11274b272d465c0c06087778294b6e3e505f3200000040420f00000000000000000000000000010000424f1f695e16503f76476f7d541d051c016b130d502e4f3b502249152c5b7c54000040420f000000000000000000000000000100002d1a401d1470606f21733a184f3f4a713010651a2211033a690b3c6f21015c52000040420f00000000000000000000000000010000150c0d09214a7e6f4d11645f6d24406f6c3950090f782b37440d2719134f070d000040420f00000000000000000000000000010000652e08620a3b4c436d4a120b5d2f20723374403754232166792e4a29000e0f13000040420f00000000000000000000000000010000587b322e037420120c51576b2e2e4d205c3d46080c1d2971055c1a2069794838000040420f000000000000000000000000000100001f6311134d4736093340793d363459186943670103561f2d20436a090e3e451d000040420f00000000000000000000000000010000680113416907254311613a111a2b5b735f6e436c11220a372f0e5d28507c454a000040420f0000000000000000000000000001000034492d4f734b011f4878120053534c5f424066517b652f3609171a1e0c190709000040420f000000000000000000000000000100003b02352954251034220943153c631f6473595f6e5a2c157351606850621a1a5b000040420f000000000000000000000000000100005171045931294f265b675b1c3d557e0a5f56072e4a630b597b32742f65572e1e000040420f000000000000000000000000000100003c713b3d2d5e1f4b0348711b714c2b5e657e1968061c4e372e3d4b6921062331000040420f000000000000000000000000000100002c6f2a4741107c412f39593d4742457171630541721f6c4b7a3a04190e0a721c000040420f000000000000000000000000000100000f38217d311079404a0a7a762b0f125972795f22561577776a31415b531e173c000040420f000000000000000000000000000100007d1d1f5a7a2d492123187721446527791f5d172454495c0146683b6417567448000040420f0000000000000000000000000001000026586b714d20651e7d05032d7c2f431e2311174910237d725065502062195934000040420f0000000000000000000000000001000065287565632a66420063022f253f4564447624704f503b102a37610028246a7e000040420f00000000000000000000000000010000024a04246574032502172a36640d1935462714311f78120127581d47714f6d49000040420f00000000000000000000000000010000383d6958267d415462515d70590d160e09262c103e6a5b27334a2c0b3b644f79000040420f0000000000000000000000000001000065552c286513794c4769340f6d492f627337411b2a3f0f6558256d0d3c593b0c000040420f000000000000000000000000000100000f7573063d626b1163490a4362262a3a3044366d2d7d6a5e470a03675c121c26000040420f000000000000000000000000000100006e05524732705e325f651b3c0f1f045e1a6f23610e1b2066795e5a05116d3f24000040420f0000000000000000000000000001000034471553696a0031045b666d7a0b2c761260023a376a101e057556147d551c70000040420f00000000000000000000000000010000615e0716310e0326304a45552b4e6a1d7c4403704b240f1430643c5b513a4961000040420f00000000000000000000000000010000157c721907161a173e780d4e09285f4467422b790715335964765d3c4d205a0f000040420f000000000000000000000000000100003109614f3a1c511b442a2b1b5032393b3811216757577960745b4b623c447d2e000040420f00000000000000000000000000010000536133335c0867403f7a2a300e453d57205d595a66775e4634575e4803526709000040420f000000000000000000000000000100007424116251541033114a6277472b5017013b0f02225d363c493915647d107602000040420f00000000000000000000000000010000477862677e1a3b4a352f657355421a433a172a045c22306c406a594e65653d56000040420f00000000000000000000000000010000555d6964565e082a7248670537242266503c5e2f37735e3a2f14413163703978000040420f000000000000000000000000000100000c767a111356470e0f553f1b3e1a45431b6d745036505d23121f4d7e03594d27000040420f000000000000000000000000000100003c51753a1e207b4c4b6f4e6419161a393807104316584d0b1d7955766825521b00
```

Output ID Proof (Output Index 0) (json-encoded):

```json
{
  "slot": 71854378,
  "outputIndex": 0,
  "transactionCommitment": "0x904d514becc987a2950297476ee07fec838d780f60e6a67cc655cddc4c5333e4",
  "outputCommitmentProof": {
    "type": 0,
    "l": {
      "type": 0,
      "l": {
        "type": 0,
        "l": {
          "type": 0,
          "l": {
            "type": 0,
            "l": {
              "type": 2,
              "hash": "0x94406e58a06ee2dd1a99472caed7bed6d82b1ea3d692195bcfec18cabdb16674"
            },
            "r": {
              "type": 1,
              "hash": "0x52d24e8cbbe5a92dc800e48a0135a5bb0f2d151c3345fbe122f63ad58f379cd8"
            }
          },
          "r": {
            "type": 1,
            "hash": "0x08de9a5e8b92bafd57fef8bc3d2f4a3dbcf7eaed3efc59bd966891f6df836d1b"
          }
        },
        "r": {
          "type": 1,
          "hash": "0xbc4ef7e28be5b72785eb1d00bb98cf190aad0a91d3bc1176b091c3bc5d5d5d53"
        }
      },
      "r": {
        "type": 1,
        "hash": "0x0571ab27a77432a693bc717c325402b79121a7bd718fb8adefa7f4e9bbec09a8"
      }
    },
    "r": {
      "type": 1,
      "hash": "0xa300087aefa3f2b42818c9edb5135ae5708dc2a3617daf9e654f09a96e4859d9"
    }
  }
}
```

Output ID Proof (Output Index 0) (binary-encoded):

```
0x2a6948040000904d514becc987a2950297476ee07fec838d780f60e6a67cc655cddc4c5333e40000000000022094406e58a06ee2dd1a99472caed7bed6d82b1ea3d692195bcfec18cabdb16674012052d24e8cbbe5a92dc800e48a0135a5bb0f2d151c3345fbe122f63ad58f379cd8012008de9a5e8b92bafd57fef8bc3d2f4a3dbcf7eaed3efc59bd966891f6df836d1b0120bc4ef7e28be5b72785eb1d00bb98cf190aad0a91d3bc1176b091c3bc5d5d5d5301200571ab27a77432a693bc717c325402b79121a7bd718fb8adefa7f4e9bbec09a80120a300087aefa3f2b42818c9edb5135ae5708dc2a3617daf9e654f09a96e4859d9
```

Output ID Proof (Output Index 28) (json-encoded):

```json
{
  "slot": 71854378,
  "outputIndex": 28,
  "transactionCommitment": "0x904d514becc987a2950297476ee07fec838d780f60e6a67cc655cddc4c5333e4",
  "outputCommitmentProof": {
    "type": 0,
    "l": {
      "type": 1,
      "hash": "0x24c6ff8772cb21ecc443f6f12a4db2e624c4e5710793575c4c74242c38f641cc"
    },
    "r": {
      "type": 0,
      "l": {
        "type": 1,
        "hash": "0xa058d1f3196d12febcd561cc60fb31ec4afaa935cb9781028e08a6b0df1bb5a2"
      },
      "r": {
        "type": 0,
        "l": {
          "type": 1,
          "hash": "0xd3b68289625ab76aba41ce4254731a94cd047efbe449973bbde5fa74c11d9f8e"
        },
        "r": {
          "type": 0,
          "l": {
            "type": 0,
            "l": {
              "type": 2,
              "hash": "0xcf02568a886a5c7c91c730d710d1b65b36a7656129817f408e1780905716ece9"
            },
            "r": {
              "type": 1,
              "hash": "0x0045ac64f5fdea88388b16737c273d3326437d67fd802e32b6364a2bf32b9325"
            }
          },
          "r": {
            "type": 1,
            "hash": "0x93ae83d3031afb93c7e1eb0ef050d4b66c67fcd4f3cea280ffa5ea5deceb9223"
          }
        }
      }
    }
  }
}
```

Output ID Proof (Output Index 28) (binary-encoded):

```
0x2a6948041c00904d514becc987a2950297476ee07fec838d780f60e6a67cc655cddc4c5333e400012024c6ff8772cb21ecc443f6f12a4db2e624c4e5710793575c4c74242c38f641cc000120a058d1f3196d12febcd561cc60fb31ec4afaa935cb9781028e08a6b0df1bb5a2000120d3b68289625ab76aba41ce4254731a94cd047efbe449973bbde5fa74c11d9f8e00000220cf02568a886a5c7c91c730d710d1b65b36a7656129817f408e1780905716ece901200045ac64f5fdea88388b16737c273d3326437d67fd802e32b6364a2bf32b9325012093ae83d3031afb93c7e1eb0ef050d4b66c67fcd4f3cea280ffa5ea5deceb9223
```

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
