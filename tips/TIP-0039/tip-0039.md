---
tip: 39
title: Mana for IOTA 2.0
description: Define Mana, Mana dynamics, and other Mana-related concepts in the IOTA 2.0 protocol
author: TODO
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-03
requires: TIP-42
---

# Table of Contents

- [Table of Contents](#table-of-contents)
- [Summary](#summary)
- [Motivation](#motivation)
- [Building Blocks](#building-blocks)
  - [Mana design](#mana-design)
  - [Mana burn](#mana-burn)
    - [Reference Mana Cost](#reference-mana-cost)
  - [Mana decay](#mana-decay)
  - [Mana and fixed point arithmetics](#mana-and-fixed-point-arithmetics)
    - [How to use the lookup table](#how-to-use-the-lookup-table)
  - [Potential Mana](#potential-mana)
    - [Potential Mana Semantic Validation](#potential-mana-semantic-validation)
  - [Stored Mana](#stored-mana)
    - [Stored Mana Semantic Validation](#stored-mana-semantic-validation)
  - [Block Issuance Credit](#block-issuance-credit)
    - [Block Issuance Credit Semantic Validation](#block-issuance-credit-semantic-validation)
  - [Mana rewards](#mana-rewards)
    - [Mana Rewards Semantic Validation](#mana-rewards-semantic-validation)
  - [Data Types \& Subschema Notation](#data-types--subschema-notation)
  - [Global Protocol Parameters](#global-protocol-parameters)
  - [Transaction Payload](#transaction-payload)
- [Copyright](#copyright)

# Summary
This document defines the Mana-related concepts and the Mana dynamics in the IOTA 2.0 protocol.
The TIP defines the two types of Mana, namely **Potential Mana** and **Stored Mana,** as well as the **Block Issuance Credit (BIC)** that Mana can be allotted to.

# Motivation
Mana is a resource used to determine the allowed throughput of a user and as a payment form for block issuance in the Mana burn mechanism.
Mana can be obtained by helpful and profitable actions for the network, like token holding or engagement in securing the network. Additionally, owning Mana is necessary to use the network by issuing blocks, so it plays the core role in the IOTA tokenomics. The following document gives a high-level overview of Mana types and dynamics. Mana is a key point of all changes introduced in the IOTA 2.0 protocol, such as staking, delegation, and congestion control changes. This document works with the Congestion Control Algorithm with Mana Credits (IOTA 2.0 version of the Congestion Control mechanism), in which a certain amount of Mana is burned in each block, which is deducted from the issuing account's Block Issuance Credit (BIC). A block issuer must allot Mana to their account to increase their BIC and ensure it does not go negative. In order to issue blocks, allot Mana, and fully use all the Mana functionalities, the user is required to have an account, which is introduced in [TIP-42](../TIP-0042/tip-0042.md).

# Building Blocks

## Mana design
Mana is a core element of the IOTA inactivation scheme. It is a resource that can be obtained through:
 * generating by holding IOTA tokens;
 * as a reward for staking IOTA tokens;
 * as a reward for delegating IOTA tokens;
 * or simply received from other IOTA users.

It is an essential element of the IOTA protocol, as it is used to:
 * determine the allowed throughput of an account;
 * as a payment form for the block issuance.

The following solutions are designed around the newest IOTA Congestion Control Algorithm (ICCA) with Mana Credits.
Additionally, Mana implementation is strictly connected to the accounts introduced in [TIP-42](../TIP-0042/tip-0042.md) and is the core point of the IOTA incentivization scheme.

**Mana** can have different forms, each of which is described in the following sections.

* [**Stored Mana**](#stored-mana) is the main form of Mana. It is the UTXO-based form of Mana that can be moved within certain rules between the different owners, which allows for Mana market development.
* [**Potential Mana**](#potential-mana) is the second form of Mana, which is generated by holding IOTA tokens.
It represents the newly generated Mana amounts from the IOTA holdings and is implicitly connected to the UTXO that holds the IOTA tokens.
* When the user spends the IOTA tokens, he is obliged to transition accumulated potential Mana to its more explicit form,
mentioned before stored Mana, and store the resource directly in the UTXO ledger, or the user can convert Mana to [**Block Issuance Credit**](#block-issuance-credit) (BIC).
* [**Mana rewards**](#mana-rewards) is another form of Mana used to reward for participation in staking for validation and delegating IOTA tokens.

The **Mana holdings** are referred to as the sum of all the potential Mana and stored Mana that the user owns. 

## Mana burn
According to the congestion control mechanism, during each block issuance, the block issuer needs to burn a certain amount of Mana dictated by the size of the block and the Reference Mana Cost (RMC). The Mana burned by the block is subtracted from the block issuer's BIC balance. Therefore, in order to prevent being locked out of their account, the block issuer must ensure that sufficient Mana is also allotted to their account to ensure their BIC balance remains non-negative.

### Reference Mana Cost
*Reference Mana Cost (RMC)* is used to decide upon commitment how much Mana is burned from BIC by each block in that slot.
RMC is computed according to an algorithm based on recent traffic activity: the algorithm counts the number of blocks in slots that are *Maximum Committable Age (MCA)* slots in the past
so that all nodes agree on that value of RMC.

From a high-level perspective, the RMC algorithm works as follows:
- If the number of blocks in slot `i - MCA` is larger than a given threshold, then the RMC increases.
- Otherwise, if the activity is low, the RMC decreases.
- The rate at which the RMC decreases is higher than its increase to tackle situations where the price suddenly becomes too large for the majority of users, and activity drops.

The RMC update only takes into account the blocks issued by accounts having non-negative BIC balances to avoid price manipulations by malicious actors.
Note that blocks from issuers with negative BIC balances are excluded with respect to the RMC calculation, but they do make part of the slot commitment.
To limit fluctuations in the RMC, it is proposed to update its value every MCA slot at least.

## Mana decay
Mana decay is introduced as a control mechanism of the Mana dynamics, altogether with the rate for the Mana generation both from IOTA tokens and the staking mechanism, which will be discussed in detail in the next sections. To guarantee non-gameability (any certain behavior, e.g.,
splitting accounts, cannot be profitable for the user) and the fairness of Mana, the same global decay factor needs to be applied to all forms of Mana:

- newly generated Mana ([Potential Mana](#potential-mana));
- Mana stored in UTXOs ([Stored Mana](#stored-mana));
- Mana bound to accounts for block issuance ([Block Issuance Credit](#block-issuance-credit));
- Mana rewarded for staking and delegation ([Mana rewards](#mana-rewards)).

As the form in which the decay factor will be applied might differ between the Mana types, it is essential to point out that all of them are based on the same exponential decay with the same parameter `β`. The Incentives Whitepaper provides the specific formula for the decay function in Appendix A.

Applying decay for the generation of new Mana and staking rewards is straightforward since it is done at the time of storing this Mana. Similarly, applying the decay on the already stored Mana happens during the UTXO spending. In any of those cases, the node must calculate the decay based on decay indices, not local times. Every`8192` slots, the decay index changes, meaning that every set of consecutive `2^(13)` slots will have the same decay index.

The decay parameter `β` (together with the Mana generation parameter) were set so the maximum theoretical Mana in the system is `2^53-1`. This means that, even though Mana is stored as a int64, it effectively uses 54 bits (53 for the value and one for the sign). Notice that this value of `2^53-1` will almost certainly never be achieved, since for the Mana supply to get to this value, nobody can spend their Mana for years. In practice, we expect to work with values way smaller than `2^53-1`, however, we must count on what would be an unreasonably large value in practice to avoid overflowing of the variables, even if with a really small probability.

## Mana and fixed point arithmetics

Floating point operations might lead to inconsistencies among results in different nodes due to the different rounding behavior in different architectures. The results of the operations involving floating point variables might differ by amounts that are considered negligible for the modules that deal with local decisions (as the congestion control module, for example); however, differences that would be considered negligible by those modules can be fatal for the transaction validation and slot commitments, leading to forks and other undesirable behaviors in the system. For that reason, fixed point arithmetics (which does not expose the nodes to these rounding divergencies) must be used in all the modules that require exact consensus over values. In particular, all the Mana and rewards calculations have to be done with fixed point arithmetics.  

We introduce in this section a lookup table that will be used in the rest of this TIP (and possibly other TIPs), as a tool to perform calculations that would otherwise be done with floating point operations. Specifically, the lookup Table introduced is an integer approximation of `2^12 * exp(-β * Decay Index Duration * n)`, where `β` and `Decay Index Duration` are protocol parameters, for different values of `n`:


<table> <caption>Lookup Table: Decays for Mana in slot granularity</caption>
    <tr>
        <td><b>n</b></td>
        <td><b>Type</b></td>
        <td><b>decay(n)</b></td>   
    </tr>
    <tr>
        <td>1 (2^0)</td>
        <td>uint32</td>
        <td>4294966388</td>
    </tr>
    <tr>
        <td>2 (2^1)</td>
        <td>uint32</td>
        <td>4294965480</td>
    </tr>
    <tr>
        <td>4 (2^2)</td>
        <td>uint32</td>
        <td>4294963664</td>
    </tr>
    <tr>
        <td>8 (2^3)</td>
        <td>uint32</td>
        <td>4294960032</td>
    </tr>
    <tr>
        <td>16 (2^4)</td>
        <td>uint32</td>
        <td>4294952769</td>
    </tr>
    <tr>
        <td>32 (2^5)</td>
        <td>uint32</td>
        <td>4294938242</td>
    </tr>
    <tr>
        <td>64 (2^6)</td>
        <td>uint32</td>
        <td>4294909188</td>
    </tr>
    <tr>
        <td>128 (2^7)</td>
        <td>uint32</td>
        <td>4294851080</td>
    </tr>
    <tr>
        <td>256 (2^8)</td>
        <td>uint32</td>
        <td>4294734867</td>
    </tr>
    <tr>
        <td>512 (2^9)</td>
        <td>uint32</td>
        <td>4294502451</td>
    </tr>
    <tr>
        <td>1024 (2^10)</td>
        <td>uint32</td>
        <td>4294037656</td>
    </tr>    
    <tr>
        <td>2048 (2^11)</td>
        <td>uint32</td>
        <td>4293108217</td>
    </tr>
    <tr>
        <td>4096 (2^12)</td>
        <td>uint32</td>
        <td>4291249942</td>
    </tr>
    <tr>
        <td>8192 (2^13)</td>
        <td>uint32</td>
        <td>4287535805</td>
    </tr>
    <tr>
        <td>16384 (2^14)</td>
        <td>uint32</td>
        <td>4280117173</td>
    </tr>
    <tr>
        <td>32768 (2^15)</td>
        <td>uint32</td>
        <td>4265318395</td>
    </tr>
    <tr>
        <td>65536 (2^16)</td>
        <td>uint32</td>
        <td>4235874166</td>
    </tr>
    <tr>
        <td>131072 (2^17)</td>
        <td>uint32</td>
        <td>4177594080</td>
    </tr>
    <tr>
        <td>262144 (2^18)</td>
        <td>uint32</td>
        <td>4063428449</td>
    </tr>
    <tr>
        <td>524288 (2^19)</td>
        <td>uint32</td>
        <td>3844371709</td>
    </tr>
    <tr>
        <td>1048576 (2^20)</td>
        <td>uint32</td>
        <td>3441049213</td>
    </tr>
    <tr>
        <td>2097152 (2^21)</td>
        <td>uint32</td>
        <td>2756905669</td>
    </tr>
    <tr>
        <td>4194304 (2^22)</td>
        <td>uint32</td>
        <td>1769636029</td>
    </tr>    
</table> 

### How to use the lookup table

==TO DO: decide to max decay index in the table==

The table defined above only gives the values of `decay(n)` for some values of `n` up to 365. To calculate `decay(n)` for larger values of `n`, we combine values of given `n` using the following algorithm:

- If `n > 365`: Let `n/365` be an integer division (e.g., `367/365 = 1`) and `n mod 365` be the module operation (e.g., `367 mod 365 = 2`).
  
```
value = uint32(2^12)
for i = 1,...,n/365:
  value = [value * decay(365)] >> 12
value = [value * decay(n mod 365)] >> 12
```

Notice that since the values in the table smaller than `2^12`, the multiplications in the algorithm have to be done using a `uint32` variable to avoid overflowing. The final result can be stored as a `uint16` value (if needed), since after the final shift operation the result will be smaller than `2^12` again.

- If `n = 0`, `exp(-β * Decay Index Duration * n) = 1`. Thus, in this case, the decay (and the lookup table) should not be applied.

Other implementations of the function are possible; however, one must be careful with the order of operations, which must be done as defined above. Having a well-defined order is crucial since sequences of divisions and multiplications with integers might lead to different results when the order is altered. 
Example: suppose one needs to calculate `1002*99/100*21/100`. Following the left-to-right order, this would result in `1002*99/100*21/100 = 99198/100*21/100 = 991*21/100 = 20811/100 = 208`. If someone did this operation in a different order, let's say `1002*21/100*99/100`, the result would be `1002*21/100*99/100 = 21042/100*99/100 = 210*99/100 = 20790/100 = 207`.



## Potential Mana
*Potential Mana* is a raw form of Mana that is generated over time from the IOTA tokens.
Every IOTA token, whether storage deposit or not, generates potential Mana.
The view on the potential Mana value can be deterministically derived from the UTXO ledger,
based on the UTXO IOTA token value and the time it was created stored in the UTXO metadata (the creation time is the slot index of the transaction).

### Rationale behind the Potential Mana formulas

We model the potential Mana generated by an output holding `amount` IOTA tokens as the combination of a fixed generation per slot `generation_per_slot * amount` and a decay equivalent to a multiplication by `2^(-12)*decay(1)` everytime a decay index ends.
    
![](https://hackmd.io/_uploads/Bkzz3PiD2.png)


Let `i` be the decay index of the creation slot and `j` be the decay index of the consumption slot. Let `n = j - i` and for the sake of the explanation, assume `n > 1`. All the Mana generated in decay index `i` "crosses" `n` decay boundaries, thus, it must be decayed `n` times.  The Mana generated in decay index `i + 1` "crosses" `n - 1` decay boundaries, so it must be decayed `n- 1` times, and so on, until the Mana generated in decay index `j`, which is not decayed at all. Adding these values, we find the following formulas:

- If `n > 1`: 
    `Potential_Mana = amount * generation_per_slot (d1*decay(n)*2^(-12) +  d2 + slots_per_decay_index * decay(1)*(1-decay(n-1)*2^(-12))/(2^(12)-decay(1)))`
- If `n = 1`: 
    `Potential_Mana = amount * generation_per_slot (d1*decay(1)*2^(-12) +  d2)`
- If `n = 0`: 
    `Potential_Mana = amount * generation_per_slot * (d1+d2)`

    where
    - `slots_per_decay_index` is the number of slot in an epoch  , i.e., `8192`  
    - `d1 = slot_after_decay_index_i - creation_slot`   
    - `slot_after_decay_index_i` is the first slot of the decay index `i + 1`   ; 
    - `d2 = consumption_slot - first_slot_decay_index_j` 
    - `first_slot_decay_index_j` is the first slot of decay index `j` ;  
    - `generation_per_slot = 2^(-3)` is the Mana generated by holding 1 IOTA for 1 slot.
    
    
The exact order of the operations that must be done are defined in the next section.
    
    
### Potential Mana Semantic Validation
- Potential Mana must and can only be consumed when the corresponding output is consumed.
- When the UTXO is spent, the potential Mana is lost; therefore, the user must specify what should happen to the accumulated potential Mana value. There are three options:
    - transition to stored Mana: the amount of potential Mana transitioned to the stored Mana form needs to be placed in the newly created output on the output side of the transaction;
    - transition to BIC: the amount of potential Mana that should be allotted to the account's Block Issuance Credit (BIC) should be specified in the `Allotment` field of the transaction;
    - ignored: generated Mana can be ignored so that it will be destroyed during the transaction.
- The exact algorithm to calculate the Potential Mana generated by an output created at slot `creation_slot` (which has a decay index `creation_decay_index`) and consumed at slot `consumption_slot` (which has a decay index `consumption_decay_index`), holding `Amount` IOTA tokens, is given by (again, in the pseudocode below, `slot_after_creation_decay_index` is the first slot of the decay index after the creation decay index  and `first_slot_consumption_decay_index` is the first slot of the consumption decay index):
    ==to do: fix the operations below so it does not overflow==
    
```
if creation_decay_index == consumption_decay_index:
    maxAmountValueToScale = uint64(2^51-1)
	bitsDecreased := 0
	while amount > uint64(maxAmountValueToScale) {
		amount = amount >> 1
		bitsDecreased++
	}
    
    potential_mana = amount * (consumption_slot - creation_slot) 
    potential_mana = potential_mana >> 3 - bitsDecreased

    
elif creation_decay_index + 1 == consumption_decay_index:
    d1 = slot_after_creation_decay_index - creation_slot
    d2 = consumption_slot - first_slot_consumption_decay_index
    maxAmountValueToScale = uint64(2^51-1)
	bitsDecreased := 0
	while amount > uint64(maxAmountValueToScale) {
		amount = amount >> 1
		bitsDecreased++
	}

    potential_mana = amount * (d1*1023 +  d2*1024) *2^(-(13- bitsDecreased))

else:
    d1 = slot_after_creation_decay_index - creation_slot
    d2 = consumption_slot - first_slot_consumption_decay_index
    potential_mana = amount *2^(-3) * 2^(-12)(d1*decay(n) + 4096 d2 +8380416*(4096-decay(n-1)))

    
``` 

<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Amount</td>
            <td>uint64</td>
            <td>
                The amount of IOTA tokens held in the output.
            </td>
        </tr>
        <tr>
            <td>Creation Slot</td>
            <td>uint64</td>
            <td>
                The index of slot in which the output was created.
            </td>
        </tr>
        <tr>
            <td>Consumption Slot</td>
            <td>uint64</td>
            <td>
                The index of slot in which the output is consumed.
            </td>
        </tr>
    </table>
    
## Stored Mana

*Stored Mana* is the main form of Mana. It is a UTXO-based form (i.e., it is contained in outputs, just like IOTA tokens) of Mana that can be transferred within certain rules between different users, which allows for Mana market development.

All output types except Foundry Outputs can hold stored Mana in the *Mana Amount* field.
This field represents the amount of stored Mana at the output's creation time until the time when the output is consumed without decay being applied to it.

### Stored Mana Semantic Validation
- Each output that contains stored Mana must also contain IOTA tokens due to storage deposit requirements.
- Stored Mana must be soulbound to an account.
- Because stored Mana lives on UTXOs and is consumed by transactions, it cannot be spent within a block. It must be allotted to an account's BIC in order to pay for Mana burned by blocks.
- *Mana Sales Outputs* must be used for transferring stored or potential Mana freely from one account to another.
- It is possible to transfer stored Mana without transferring IOTA tokens or the potential Mana generated from those tokens.
- The decay must be applied to stored Mana whenever the output containing that stored Mana is consumed.
- To calculate the decay of stored Mana, the creation time of each output with stored Mana must be contained in transactions.
- The amount of stored Mana must be decayed before stored Mana is transferred into a new output as follows: 
  - Let `Mana Amount`, `Consumption Slot`, and `Creation Slot`, be
  
      <table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Mana Amount</td>
        <td>uint64</td>
        <td>
            The amount of stored Mana held by the output.
        </td>
    </tr>
    <tr>
        <td>Creation Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which the output was created.
        </td>
    </tr>
    <tr>
        <td>Consumption Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which the output is consumed.
        </td>
    </tr>
    </table> 
   
   The algorithm to decay the stored Mana is as follows
``` 
creation_decay_index = decay_index(creation_slot)
consumption_decay_index = decay_index(consumption_slot)
if creation_decay_index == consumption_decay_index:
    new_mana_amount = mana_amount
    
else:    
    maxManaValueToScale = uint64(2^52-1)
	bitsDecreased := 0
	while mana_amount > uint64(maxManaValueToScale) {
		mana_amount = mana_amount >> 1
		bitsDecreased++
	}
    
    new_mana_amount = mana_amount * decay(consumption_decay_index - creation_decay_index) 
    new_mana_amount = new_mana_amount >> (12 - bitsDecreased)

```
 
## Block Issuance Credit

*Block Issuance Credit (BIC)* Mana is used for congestion control, i.e., to pay for blocks to be scheduled and gossiped around the network and seen by everyone.
Congestion control manages which blocks should be gossiped to neighbors based on Mana burned from the block issuance credits by the block.
It is important to distinguish between **blocks** and **transactions**:
congestion control only deals with blocks, which are the containers that carry transactions around the network. It does not care about the transactions inside the blocks.

The example below shows a ledger with a conflicting branch (perhaps due to a double spend), so only one branch (either the set of red or the set of green transactions)
can ultimately modify the ledger (UTXOs consumed), not both. However, all these blocks must be gossiped, whether they contain red or green transactions.
Thus, they must pay for the BIC used to get through schedulers regardless of whether the transaction within modifies the ledger.
This is why Mana cannot be burned from BIC by a transaction, it can only be burned by a block.
![](./img/gFLB1Ms.png)

### Block Issuance Credit Semantic Validation
- Block issuance credits must be stored on a per-account basis.
- Accounts must be represented by _Account Outputs_ on the UTXO ledger. The cost of permanently storing any outputs (until destruction) in the ledger is covered by the _storage deposit_.
Because of that, the number of accounts is capped at a number proportional to the max supply of tokens, contrary to the number of plain addresses.
Because BIC must be tracked in slot commitments, keeping the number of entries (even though the user can create multiple accounts) in that data structure as small as possible is desirable.
Using account IDs for that purpose is thus a good fit.
- It is not possible to store BIC without an Account Output because Mana burned by blocks must also be deducted from BIC, and the block cannot modify the Account Output.
Consequently, the ledger state is not bloated by having to keep track of block issuance credits because there is a corresponding account output in the UTXO ledger that requires a storage deposit
in IOTA tokens. Thus, the dust protection mechanism used for the UTXO ledger also indirectly prevents dust from accumulating in tracking the block issuance credits.
- A commitment and time division mechanism is required for BIC dynamics: current slot commitments present in IOTA 2.0.
    - The end time of an decay index is used for the decay calculations.
    - Definition of slots based on the time of the genesis slot and slot duration.
    - A commitment mechanism per slot is needed to ensure the unified perception of the BIC in the longer run.
- The global agreement on the BIC balances among all the nodes is required.
    - It can be achieved by including the BIC vector in the slot commitments. This guarantees that all nodes have the same perception of the BIC balances from a certain point in time.
- If a block is orphaned, the block will not be included in a commitment, and hence, the balance of BIC of the account that issued the block must be unaffected by that block.
- The time of the slot commitment must be used to align the local version of the BIC vector with the objective, committed version.
It allows for the global control of the BIC dynamic with a Mana decay function.
    - This decrease is also applied to the potential and stored Mana (that can be allotted to the account as BIC) so users cannot gain by delaying or advancing the allotting.
- The balance of the BIC vector at the slot commitment must be the sum of:
    - The balances of the previously committed BIC vector.
    - All Mana allotted as BIC in accepted transactions of the committed slot. Note that, in theory, in the case of only decaying the BIC vector at the end of each decay index, this Mana would have to be decayed by a factor proportional to the difference between the transaction slot index and the index of the last slot of the decay index. However, since the decay rate is small, this difference will be always smaller than half a percent. We understand that this difference (since it's not composable and can only be "taken profit of" once) does not justify the user experience-related issues (like having to allot more than 1 Mana to being able to burn 1 Mana in the same transaction) and implementation complications of applying this small decay. Thus, we allot as a BIC the total value of Mana being allotted in a transaction.
    - Subtract from BIC all Mana burned by accepted blocks of the committed slots.
- BIC updates (increase and or deduction/Mana burning) must happen upon slot commitments. BIC decays happen at the end of the decay index. 
- Mana decay must be applied at the end of decay index according to the algorithm:
  - Let `BIC_i` be the amount of BIC held by the account at the end of slot `i`, which is the last slot of an decay index. This means that all additions of allotted BIC and Mana burnt relative to slot `i` were already done. We must now decay the remaining value of BIC, by applying:
``` 
if BIC > 0:
    maxBICValueToScale = int64(2^51-1)
    bitsDecreased := 0
    while BIC > maxBICValueToScale {
        BIC = BIC >> 1
        bitsDecreased++
    }
    new_BIC = BIC * decay(1) 
    new_BIC = new_BIC >> (12 - bitsDecreased)
else: 
    new_BIC = BIC 

```
     
If `i` is not the last slot of athe decay index, this decay should not be applied.


- A block must include the permission of an account from which Mana will be burned from BIC to pay for the block.
    - A block must contain an account's permission (i.e., a digital signature) that nodes can use to verify that
the account has authorized the block and that Mana can be burned from the BIC of that account.
- The issuer must specify the maximum amount of Mana they will allow to be burned from BIC.
    - In the above-mentioned permission, the account owner must commit to a certain maximum amount of Mana that will be burned from BIC.
- The declared burning amount must be at least the required burning for the current slot.
    - The required burning amount for a block is calculated with the Reference Mana Cost (RMC), which depends on the past network activity and gets updated every slot.

## Mana rewards

*Mana rewards* are used to reward for participation in staking for validation and delegating IOTA tokens.
Rewarding validators and delegators with Mana is reasonable as it does not extract value from other IOTA token holders.

### Mana Rewards Semantic Validation
- Mana rewards must be calculated on a per-epoch basis.
- Mana rewards must become available for claiming when the last slot of the epoch is committed to.
- Mana rewards must be claimed by creating a transaction that consumes the original outputs that were staked or delegated.
- Mana rewards must be put on outputs as stored Mana on the output side of the transaction.
- The decay must be applied to Mana rewards before they are put on outputs according to the following algorithm:
  - Let `Reward`, `Reward Epoch`, `Reward Decay Index` and `Claiming Slot Decay Index` be as follows:
    <table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Reward</td>
        <td>uint64</td>
        <td>
            The amount of Mana rewards available to be claimed for staking or delegation for a specific epoch.
        </td>
    </tr>
    <tr>
        <td>Rewards Epoch</td>
        <td>uint64</td>
        <td>
            The index of the epoch for which Mana rewards are claimed.
        </td>
    </tr>   
    <tr>
        <td>Reward Decay Index</td>
        <td>uint64</td>
        <td>
            The decay index of the last slot in Rewards Epoch.
        </td>
    </tr>
    <tr>
        <td>Claiming Slot Decay Index</td>
        <td>uint64</td>
        <td>
            The decay index of the slot in which the Mana rewards are claimed.
        </td>
    </tr>
    </table> 
    
  - Let `n = Claiming Slot Decay Index - Reward Decay Index`. If `n > 0`, with the aid of the lookup table and the algorithm defined in the section [Mana and fixed point arithmetics](#mana-and-fixed-point-arithmetics), we must now decay the rewards, by applying:
    
    
    ``` 
    maxRewardValueToScale = int64(2^52)
    bitsDecreased := 0
    while Reward > maxRewardValueToScale {
        Reward = Reward >> 1
        bitsDecreased++
    }
    Reward = Reward * decay(n) 
    Reward = Reward >> (12 - bitsDecreased)
    ```
    - If `n = 0`, the amount to be put on outputs is the entire `Reward`. 



## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Global Protocol Parameters

Global protocol parameters used throughout this TIP are defined in [TIP-22 (IOTA)](../TIP-0022/tip-0022.md) and [TIP-32 (Shimmer)](../TIP-0032/tip-0032.md).

## Transaction Payload

[TIP-20](../TIP-0020/tip-0020.md) is the basis for output validation in this TIP.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
