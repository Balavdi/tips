---
tip: 39
title: Mana for IOTA 2.0
description: Define Mana, Mana dynamics, and other Mana-related concepts in the IOTA 2.0 protocol
author: TODO
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-03
requires: TIP-42
---

# Table of Contents

- [Table of Contents](#table-of-contents)
- [Summary](#summary)
- [Motivation](#motivation)
- [Building Blocks](#building-blocks)
  - [Mana design](#mana-design)
  - [Mana burn](#mana-burn)
    - [Reference Mana Cost](#reference-mana-cost)
  - [Mana decay](#mana-decay)
  - [Mana and fixed point arithmetics](#mana-and-fixed-point-arithmetics)
    - [How to use the lookup table](#how-to-use-the-lookup-table)
  - [Potential Mana](#potential-mana)
    - [Potential Mana Semantic Validation](#potential-mana-semantic-validation)
  - [Stored Mana](#stored-mana)
    - [Stored Mana Semantic Validation](#stored-mana-semantic-validation)
  - [Block Issuance Credit](#block-issuance-credit)
    - [Block Issuance Credit Semantic Validation](#block-issuance-credit-semantic-validation)
  - [Mana rewards](#mana-rewards)
    - [Mana Rewards Semantic Validation](#mana-rewards-semantic-validation)
  - [Data Types \& Subschema Notation](#data-types--subschema-notation)
  - [Global Protocol Parameters](#global-protocol-parameters)
  - [Transaction Payload](#transaction-payload)
- [Copyright](#copyright)

# Summary
This document defines the Mana-related concepts and the Mana dynamics in the IOTA 2.0 protocol.
The TIP defines the two types of Mana, namely **Potential Mana** and **Stored Mana,** as well as the **Block Issuance Credit (BIC)** that Mana can be allotted to.

# Motivation
Mana is a resource used to determine the allowed throughput of a user and as a payment form for block issuance in the Mana burn mechanism.
Mana can be obtained by actions helpful and profitable for the network, like token holding or engagement in securing the network. Additionally, it is necessary to use the network, so it plays the core role in the IOTA tokenomics. The following document gives a high-level overview of Mana types and dynamics. Mana is a key point of all changes introduced in the IOTA 2.0 protocol, such as staking, delegation, and congestion control changes. This document works with the Congestion Control Algorithm with Mana Credits (IOTA 2.0 version of the Congestion Control mechanism), in which a certain amount of Mana is burned in each block, which is deducted from the issuing account's Block Issuance Credit (BIC). A block issuer must allot Mana to their account to increase their BIC and ensure it does not go negative. In order to issue blocks, allot Mana, and fully use all the Mana functionalities, the user is required to have an account, which is introduced in [TIP-42](../TIP-0042/tip-0042.md).

# Building Blocks

## Mana design
Mana is a core element of the IOTA inactivation scheme. It is a resource that can be obtained through:
 * generating by holding IOTA tokens;
 * as a reward for staking IOTA tokens;
 * as a reward for delegating IOTA tokens;
 * or simply received from other IOTA users.

It is an essential element of the IOTA protocol, as it is used to:
 * determine the allowed throughput of an account;
 * as a payment form for the block issuance.

The following solutions are designed around the newest IOTA Congestion Control Algorithm (ICCA) with Mana Credits.
Additionally, Mana implementation is strictly connected to the accounts introduced in [TIP-42](../TIP-0042/tip-0042.md) and is the core point of the IOTA incentivization scheme.

**Mana** can have different forms, each of which is described in the following sections.

* [**Stored Mana**](#stored-mana) is the main form of Mana. It is the UTXO-based form of Mana that can be moved within certain rules between the different owners, which allows for Mana market development.
* [**Potential Mana**](#potential-mana) is the second form of Mana, which is generated by holding IOTA tokens.
It represents the newly generated Mana amounts from the IOTA holdings and is implicitly connected to the UTXO that holds the IOTA tokens.
* When the user spends the IOTA tokens, he is obliged to transition accumulated potential Mana to its more explicit form,
mentioned before stored Mana, and store the resource directly in the UTXO ledger, or the user can convert Mana to [**Block Issuance Credit**](#block-issuance-credit) (BIC).
* [**Mana rewards**](#mana-rewards) is another form of Mana used to reward for participation in staking for validation and delegating IOTA tokens.

The **Mana holdings** are referred to as the sum of all the potential Mana and stored Mana that the user owns. 

## Mana burn
According to the congestion control mechanism, during each block issuance, the block issuer needs to burn a certain amount of Mana dictated by the size of the block and the Reference Mana Cost (RMC). The Mana burned by the block is subtracted from the block issuer's BIC balance. Therefore, in order to prevent being locked out of their account, the block issuer must ensure that sufficient Mana is also allotted to their account to ensure their BIC balance remains non-negative.

### Reference Mana Cost
*Reference Mana Cost (RMC)* is used to decide upon commitment how much Mana is burned from BIC by each block in that slot.
RMC is computed according to an algorithm based on recent traffic activity: the algorithm counts the number of blocks in slots that are *Maximum Committable Age (MCA)* slots in the past
so that all nodes agree on that value of RMC.

From a high-level perspective, the RMC algorithm works as follows:
- If the number of blocks in slot `i-MCA` is larger than a given threshold, then the RMC increases.
- Otherwise, if the activity is low, the RMC decreases.
- The rate at which the RMC decreases is higher than its increase to tackle situations where the price suddenly becomes too large for the majority of users, and activity drops.

The RMC update only takes into account the blocks issued by accounts having non-negative BIC balances to avoid price manipulations by malicious actors.
Note that blocks from issuers with negative BIC balances are excluded with respect to the RMC calculation, but they do make part of the slot commitment.
To limit fluctuations in the RMC, it is proposed to update its value every MCA slot at least.

## Mana decay
Mana decay is introduced as a control mechanism of the Mana dynamics, altogether with the rate for the Mana generation both from IOTA tokens and the staking mechanism, which will be discussed in detail in the next sections. To guarantee non-gameability (any certain behavior, e.g.,
splitting accounts, cannot be profitable for the user) and the fairness of Mana, the same global decay factor needs to be applied to all forms of Mana:

- newly generated Mana ([Potential Mana](#potential-mana));
- Mana stored in UTXOs ([Stored Mana](#stored-mana));
- Mana bound to accounts for block issuance ([Block Issuance Credit](#block-issuance-credit));
- Mana rewarded for staking and delegation ([Mana rewards](#mana-rewards)).

As the form in which the decay factor will be applied might differ between the Mana types, it is essential to point out that all of them are based on the same exponential decay with the same parameter `β`. The Incentives Whitepaper provides the specific formula for the decay function in Appendix A.

Applying decay for the generation of new Mana and staking rewards is straightforward since it is done at the time of storing this Mana. Similarly, applying the decay on the already stored Mana happens during the UTXO spending. In any of those cases, the node must calculate the decay based on slot indices, not local times. For block issuance credit, it is advised to apply the decay function in a slot-based manner and update it upon slot commitment.

## Mana and fixed point arithmetics

Floating point operations might lead to inconsistencies among results in different nodes due to the different rounding behavior in different architectures. The results of the operations involving floating point variables might differ by amounts that are considered negligible for the modules that deal with local decisions (as the congestion control module, for example); however, differences that would be considered negligible by those modules can be fatal for the transaction validation and slot commitments, leading to forks and other undesirable behaviors in the system. For that reason, fixed point arithmetics (which does not expose the nodes to these rounding divergencies) must be used in all the modules that require exact consensus over values. In particular, all the Mana and rewards calculations have to be done with fixed point arithmetics.  

We introduce in this section a lookup table that will be used in the rest of this TIP (and possibly other TIPs), as a tool to perform calculations that would otherwise be done with floating point operations. Specifically, the lookup Table introduced is an integer approximation of `2^32 * exp(-β * Slot Duration * n)`, where `β` and `Slot Duration` are protocol parameters, for different values of `n`:


<table> <caption>Lookup Table: Decays for Mana in slot granularity</caption>
    <tr>
        <td><b>n</b></td>
        <td><b>Type</b></td>
        <td><b>decay(n)</b></td>   
    </tr>
    <tr>
        <td>1 (2^0)</td>
        <td>uint32</td>
        <td>4294966388</td>
    </tr>
    <tr>
        <td>2 (2^1)</td>
        <td>uint32</td>
        <td>4294965480</td>
    </tr>
    <tr>
        <td>4 (2^2)</td>
        <td>uint32</td>
        <td>4294963664</td>
    </tr>
    <tr>
        <td>8 (2^3)</td>
        <td>uint32</td>
        <td>4294960032</td>
    </tr>
    <tr>
        <td>16 (2^4)</td>
        <td>uint32</td>
        <td>4294952769</td>
    </tr>
    <tr>
        <td>32 (2^5)</td>
        <td>uint32</td>
        <td>4294938242</td>
    </tr>
    <tr>
        <td>64 (2^6)</td>
        <td>uint32</td>
        <td>4294909188</td>
    </tr>
    <tr>
        <td>128 (2^7)</td>
        <td>uint32</td>
        <td>4294851080</td>
    </tr>
    <tr>
        <td>256 (2^8)</td>
        <td>uint32</td>
        <td>4294734867</td>
    </tr>
    <tr>
        <td>512 (2^9)</td>
        <td>uint32</td>
        <td>4294502451</td>
    </tr>
    <tr>
        <td>1024 (2^10)</td>
        <td>uint32</td>
        <td>4294037656</td>
    </tr>    
    <tr>
        <td>2048 (2^11)</td>
        <td>uint32</td>
        <td>4293108217</td>
    </tr>
    <tr>
        <td>4096 (2^12)</td>
        <td>uint32</td>
        <td>4291249942</td>
    </tr>
    <tr>
        <td>8192 (2^13)</td>
        <td>uint32</td>
        <td>4287535805</td>
    </tr>
    <tr>
        <td>16384 (2^14)</td>
        <td>uint32</td>
        <td>4280117173</td>
    </tr>
    <tr>
        <td>32768 (2^15)</td>
        <td>uint32</td>
        <td>4265318395</td>
    </tr>
    <tr>
        <td>65536 (2^16)</td>
        <td>uint32</td>
        <td>4235874166</td>
    </tr>
    <tr>
        <td>131072 (2^17)</td>
        <td>uint32</td>
        <td>4177594080</td>
    </tr>
    <tr>
        <td>262144 (2^18)</td>
        <td>uint32</td>
        <td>4063428449</td>
    </tr>
    <tr>
        <td>524288 (2^19)</td>
        <td>uint32</td>
        <td>3844371709</td>
    </tr>
    <tr>
        <td>1048576 (2^20)</td>
        <td>uint32</td>
        <td>3441049213</td>
    </tr>
    <tr>
        <td>2097152 (2^21)</td>
        <td>uint32</td>
        <td>2756905669</td>
    </tr>
    <tr>
        <td>4194304 (2^22)</td>
        <td>uint32</td>
        <td>1769636029</td>
    </tr>    
</table> 

### How to use the lookup table

The table defined above only gives the values of `decay(n)` for some selected values of `n` in the form of powers of `2`. To calculate `decay(n)` for other `n`, we combine values of given `n` using the following algorithm:

- If `0 < n < 2^23`: Let `sum(c_k * 2^k) = n, k = 0,...,22`, i.e., let `(c_22, c_21, ..., c_1, c_0)` be the binary representation of `n`. 
  
```
value = uint64(2^32)
for k = 22,...,0:
    if (ck == 1):
      value = [value * decay(2^k)] >> 32
```

- If $n\geq 2^{23}$: Let $\sum_{k=0}^{K}c_k 2^k=n$, i.e., let $(c_{K}, c_{K-1},...,c_1,c_0)$ be the binary representation of $n$. Let $m$ be the decimal representation of $(c_{K}, c_{K-1},...,c_{23},c_{22})$.
- If `n ≥ 2^23`: Let `sum(c_k * 2^k) = n, k = 0,...,K`, i.e., let `(c_K, c_{K-1}, ..., c_1, c_0)` be the binary representation of `n`.
Let `m` be the decimal representation of `(c_K, c_{K-1}, ..., c_23, c_22)`.
  
```
value = uint64(2^32)
for i = 1,...,m:
  value = [value * decay(2^22)] >> 32
for k = 21,...,0:
    if (ck == 1):
      value = [value * decay(2^k)] >> 32
```

Notice that since the values in the table are type `uint32`, the multiplications in the algorithm have to be done using a `uint64` variable to avoid overflowing. The final result can be stored as a `uint32` value (if needed), since after the shift operation the result will be smaller than `2^32`.

- If `n = 0`, `exp(-β * Slot Duration * n) = 1`. Thus, in this case, the decay (and the lookup table) should not be applied.

Other implementations of the function are possible; however, one must be careful with the order of operations, which must be done as defined above. Having a well-defined order is crucial since sequences of divisions and multiplications with integers might lead to different results when the order is altered. 
Example: suppose one needs to calculate `1002*99/100*21/100`. Following the left-to-right order, this would result in `1002*99/100*21/100 = 99198/100*21/100 = 991*21/100 = 20811/100 = 208`. If someone did this operation in a different order, let's say `1002*21/100*99/100`, the result would be `1002*21/100*99/100 = 21042/100*99/100 = 210*99/100 = 20790/100 = 207`.


## Potential Mana
*Potential Mana* is a raw form of Mana that is generated over time from the IOTA tokens.
Every IOTA token, whether storage deposit or not, generates potential Mana.
The view on the potential Mana value can be deterministically derived from the UTXO ledger,
based on the UTXO IOTA token value and the time it was created stored in the UTXO metadata (the creation time is the slot index of the transaction).

### Potential Mana Semantic Validation
- Potential Mana must and can only be consumed when the corresponding output is consumed.
- When the UTXO is spent, the potential Mana is lost, therefore the user must specify what should happen to the accumulated potential Mana value. There are three options:
    - transition to stored Mana: the amount of potential Mana transitioned to the stored Mana form needs to be placed in the newly created output on the output side of the transaction;
    - transition to BIC: the amount of potential Mana that should be allotted to the account's Block Issuance Credit (BIC) should be specified in the `Allotment` field of the transaction;
    - ignored: generated Mana can be ignored, so that it will be destroyed during the transaction.
- The exact formula of the Potential Mana generated by an output $n$ slots old, holding $\text{Amount}$ IOTA tokens is given by:
    $$
    \frac{\text{Generation Rate}}{\beta}\left(1-\exp(-\beta \text{ SlotDuration } n)\right)\text{Amount}
    $$ 
    where $\text{Generation Rate}$, $\text{SlotDuration}$, and $\beta$ are protocol parameters.
- Thus, Potential Mana must be calculated explicitly including decay as follows: 
  - Let `Consumption Slot`, `Creation Slot` and `Amount` given by the table below
    <table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Amount</td>
            <td>uint64</td>
            <td>
                The amount of IOTA tokens held in the output.
            </td>
        </tr>
        <tr>
            <td>Creation Slot</td>
            <td>uint64</td>
            <td>
                The index of slot in which the output was created.
            </td>
        </tr>
        <tr>
            <td>Consumption Slot</td>
            <td>uint64</td>
            <td>
                The index of slot in which the output is consumed.
            </td>
        </tr>
    </table>
  - Let `n = Consumption Slot - Creation Slot`. With the aid of the lookup table and the algorithm defined in the last section, find `decay(n)`. If `decay(n)>0`: 
    - Approximate $2^{32}(1 - \exp{(-\beta \text{ SlotDuration } n)})$ by subtracting `2^32-decay(n)`. Since `decay(n)>0`, this value can be stored as a uint32.
    - Multiply by an approximation of $\text{Generation Rate}/\beta$. To do so, multiply by `13410781` and subsequently apply a right-shift of 16 bits. The result will be a uint128.
    - Finally, multiply the result by `Amount` (which will require 256 bits) and apply a right-shift of 32 bits.
  -  If `decay(n)=0`:
     - Multiply `Amount*13410781` and apply a right-shift of 16 bits.
## Stored Mana

*Stored Mana* is the main form of Mana. It is a UTXO-based form (i.e., it is contained in outputs, just like IOTA tokens) of Mana that can be transferred within certain rules between different users, 
which allows for Mana market development.

All output types except Foundry Outputs can hold stored Mana in the *Mana Amount* field.
This field represents the amount of stored Mana at the output's creation time until the time when the output is consumed without decay being applied to it.

### Stored Mana Semantic Validation
- Each output that contains stored Mana must also contain IOTA tokens due to storage deposit requirements.
- Stored Mana must be soulbound to an account.
- Because stored Mana lives on UTXOs and is consumed by transactions, it cannot be spent within a block. It must be allotted to an account's BIC in order to pay for Mana burned by blocks.
- *Mana Sales Outputs* must be used for transferring stored or potential Mana freely from one account to another.
- It is possible to transfer stored Mana without transferring IOTA tokens or the potential Mana generated from those tokens.
- Decay must be applied to stored Mana whenever the output containing that stored Mana is consumed.
- To calculate decay of stored Mana, the creation time of each output with stored Mana must be contained in transactions.
- The amount of stored Mana must be decayed before stored Mana is transferred into a new output as follows: `Mana Amount * decay(Consumption Slot - Creation Slot)`, where
  
  <table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Mana Amount</td>
        <td>uint64</td>
        <td>
            The amount of stored Mana held by the output.
        </td>
    </tr>
    <tr>
        <td>Creation Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which the output was created.
        </td>
    </tr>
    <tr>
        <td>Consumption Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which the output is consumed.
        </td>
    </tr>
</table> 

And `decay(Consumption Slot - Creation Slot)` is calculated with the lookup table and algorithm defined in section "Mana and fixed point arithmetics", by taking `n = Consumption Slot - Creation Slot`. After that, a right-shift of 32 bits must be applied.

## Block Issuance Credit

*Block Issuance Credit (BIC)* Mana is used for congestion control, i.e., to pay for blocks to be scheduled and gossiped around the network and seen by everyone.
Congestion control manages which blocks should be gossiped to neighbours based on Mana burned from the block issuance credits by the block.
It is important to distinguish between **blocks** and **transactions**:
congestion control only deals with blocks, which are the containers that carry transactions around the network. It does not care about the transactions inside the blocks.

The example below shows a ledger with a conflicting branch (perhaps due to a double spend), so only one branch (either the set of red or the set of green transactions)
can ultimately modify the ledger (UTXOs consumed), not both. However, all these blocks must be gossiped, whether they contain red or green transactions.
Thus, they must pay for the BIC used to get through schedulers regardless of whether the transaction within modifies the ledger.
This is why Mana cannot be burned from BIC by a transaction, it can only be burned by a block.
![](./img/gFLB1Ms.png)

### Block Issuance Credit Semantic Validation
- Block issuance credits must stored on a per-account basis.
- Accounts must be represented by _Account Outputs_ on the UTXO ledger. The cost of permanently storing any outputs (until destruction) in the ledger is covered by the _storage deposit_.
Because of that, the number of accounts is capped at a number proportional to the max supply of tokens, contrary to the number of plain addresses.
Because BIC must be tracked in slot commitments, keeping the number of entries (even though the user can create multiple accounts) in that data structure as small as possible is desirable.
Using account IDs for that purpose is thus a good fit.
- It is not possible to store BIC without an Account Output because Mana burned by blocks must also be deducted from BIC and the block cannot modify the Account Output.
Consequently, the ledger state is not bloated by having to keep track of block issuance credits because there is a corresponding account output in the UTXO ledger that requires a storage deposit
in IOTA tokens. Thus, the dust protection mechanism used for the UTXO ledger also indirectly prevents dust from accumulating in tracking the block issuance credits.
- A commitment and time division mechanism is required for BIC dynamics: current slot commitments present in IOTA 2.0.
    - The end time of an epoch is used for the decay calculation at the end of each epoch.
    - Definition of slots based on time of the genesis slot and a slot duration.
    - The commitment mechanism per slot is needed to ensure the unified perception of the BIC in the longer run.
- The global agreement on the BIC balances among all the nodes is required.
    - It can be achieved by including the BIC vector to the slot commitments. This guarantees that all nodes have the same perception of the BIC balances from a certain point in time.
- If a block is orphaned, the block will not be included in a commitment, and hence, the balance of BIC of the account that issued the block must be unaffected by that block.
- The time of the slot commitment must be used to align the local version of the BIC vector with the objective, committed version.
It allows for the global control of the BIC dynamic with a Mana decay function.
    - This decrease is also applied to the potential and stored Mana (that can be allotted to the account as BIC) so users cannot gain by delaying or advancing the allotting.
- The balance of the BIC vector at the slot commitment must be the sum of:
    - The balances of the previous committed BIC vector.
    - All Mana allotted as BIC in accepted transactions of the committed slot. Note that, in theory, in the case of only decaying the BIC vector at the end of each epoch, this Mana would have to be decayed by a factor proportional to the difference between the transaction slot index and the index of the last slot of the epoch. However, since the decays rate is small, this difference will be always smaller than half percent. We understand that this difference (since it's not composable and can only be "taken profit of" once) does not justify the user experience-related issues (like having to allot more than 1 Mana to being able to burn 1 Mana in the same transaction) and implementation complications of applying this small decay. Thus, we allot as a BIC the total value of Mana being allotted in a transaction.
    - Subtract from BIC all Mana burned by accepted blocks of the committed slots.
- BIC updates (increase and or deduction/Mana burning) must happen upon slot commitments. BIC decays happen at the end of the epoch. 
- Mana decay must be applied at the end of each epoch according to the algorithm:
  - Let $\text{BIC}_i$ be the amount of BIC held by account at the end of the slot `i`, which is the last slot of an epoch. This means that all additions of allotted BIC and Mana burnt relative to slot `i` were already done. We must now decay the remaining value of BIC, by first multiplying it by `4287129767` and subsequently applying a right-shift of 32 bits. If `i` is not the last slot of an epoch, this decay should not be applied.
- A block must include the permission of an account from which Mana will be burned from BIC to pay for the block.
    - A block must contain an account's permission (i.e., a digital signature) that nodes can use to verify that
the account has authorized the block and that Mana can be burned from BIC of that account.
- The issuer must specify the maximum amount of Mana they will allow to be burned from BIC.
    - In the above-mentioned permission, the account owner must commit to a certain maximum amount of Mana that will be burned from BIC.
- The declared burning amount must be at least the required burning for the current slot.
    - The required burning amount for a block is calculated with the Reference Mana Cost (RMC), which depends on the past network activity and gets updated every slot.

## Mana rewards

*Mana rewards* are used to reward for participation in staking for validation and delegating IOTA tokens.
Rewarding validators and delegators with Mana is reasonable as it does not extract value from other IOTA token holders.

### Mana Rewards Semantic Validation
- Mana rewards must be calculated on a per-slot basis.
- Mana rewards must become available for claiming at slot commitments.
- Mana rewards must be claimed by creating a transaction that consumes the original outputs that were staked or delegated.
- Mana rewards must be put on outputs as stored Mana on the output side of the transaction.
- Decay must be applied to Mana rewards before they are put on outputs according to the following algorithm:
  - Let `Reward`, `Consumption Slot` and `Creation Slot` be as follows:
    <table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Reward</td>
        <td>uint64</td>
        <td>
            The amount of Mana rewards available to be claimed for staking or delegation for a specific slot.
        </td>
    </tr>
    <tr>
        <td>Commitment Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which that specific slot, for which Mana rewards are claimed, was committed.
        </td>
    </tr>
    <tr>
        <td>Claiming Slot</td>
        <td>uint64</td>
        <td>
            The index of slot in which Mana rewards are claimed.
        </td>
    </tr>
    </table> 
  - Let `n = Consumption Slot - Creation Slot`. If `n > 0`, with the aid of the lookup table and the algorithm defined in the section "Mana and fixed point arithmetics", find `decay(n)`.
    - Multiply `Reward * decay(n)`. This result should be an uint128. Apply a right-shift of 32 bits. This final value can be stored as a uint64.
  - If `n = 0`, the amount to be put on outputs is the entire `Reward`. However, this behaviour should not be the usual, since for the rewards to be claimed, the slot has to be committed to. We leave this edge case specified just to prevent bugs or unusual and unforeseen node behaviour.


## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Global Protocol Parameters

Global protocol parameters used throughout this TIP are defined in [TIP-22 (IOTA)](../TIP-0022/tip-0022.md) and [TIP-32 (Shimmer)](../TIP-0032/tip-0032.md).

## Transaction Payload

[TIP-20](../TIP-0020/tip-0020.md) is the basis for output validation in this TIP.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
