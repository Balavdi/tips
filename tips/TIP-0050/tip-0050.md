---
tip: 50
title: Configurable Addresses
description: Extendable and configurable address format supporting various signature schemes and address types
author: TODO
discussions-to: TODO
status: TODO
type: Standards
layer: Interface
created: 2023-09-04
replaces: 11
---

# Table of Contents

1. [Summary](#summary)
2. [Motivation](#motivation)
3. [Binary serialization](#binary-serialization)
   - [Address Types](#address-types)
   - [Allowed Capabilities](#allowed-capabilities)
   - [Bech32 encoding](#bech32-encoding)
   - [Examples](#examples)
     - [Allowed Capabilities Bit Patterns](#allowed-capabilities-bit-patterns)
     - [Bech32 Strings](#bech32-strings)
4. [Drawbacks](#drawbacks)
5. [Rationale & Alternatives](#rationale--alternatives)
6. [Copyright](#copyright)

# Summary

This document proposes an extension to the address format to make them configurable. This enables an address to opt-in
or -out of certain functionality, like disabling the receival of Native Tokens or NFTs. Additionally, this TIP
introduces _implicit account creation addresses_ as a new address type. The address format and encoding was previously
defined in [TIP-11](../TIP-0011/tip-0011.md) and this TIP replaces it.

The human-readable encoding of addresses continues to be done through Bech32, which is an extendable address format
supporting various signature schemes and address types. It is defined in
[Bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) and provides a compact, human-readable encoding
with strong error correction guarantees.

# Motivation

IOTA 2.0 uses an [account-centric ledger](../TIP-0042/tip-0042.md). Accounts face a bootstrapping problem where users
need to own an Account with a _Block Issuer Feature_ in order to issue blocks, but cannot create it themselves, since
they cannot issue blocks yet. To support the _implicit account_ creation mechanism defined in that TIP, a new address
type for such addresses are needed.

With the introduction of the [TIP-18](../TIP-0018/tip-0018.md), a multi-asset ledger was introduced. Every user is able
to receive different kinds of Outputs (Basic, Alias, NFTs) and the ledger has useful functionality like time-based
unlock conditions. Not every user wants to deal with the complexity of this functionality, but were so far unable to
disable them. Certain users do not want to receive certain asset classes. For example, some users may not want to
receive Native Tokens or Non-Fungible Tokens for legal reasons. Configurable addresses solve this issue by adding
capabilities to addresses. Such addresses self-describe their capabilities, such as being unable to receive Native
Tokens or NFTs. Configurable addresses make it possible to express whether an address can receive such assets. In
essence, these address capabilities can add additional validation rules in the transaction in which Outputs are sent to
an address.

This TIP builds on the format defined in TIP-11 in a backwards-compatible manner, while extending the capabilities of
the address.

# Binary serialization

The address format uses a simple serialization scheme which consists of three parts:

- The first byte describes the type of the address.
- The following bytes contain the type-specific raw address bytes.
- Depending on the address type, the address may contain additional bytes as bitflags which are the _allowed
  capabilities_. See [Allowed Capabilities](#allowed-capabilities) for their serialization.

## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Address Types

The following table shows the mapping from the address type of the **first byte** to the address type:

| Address                   | Type Byte as `uint8` | Bech32 Encoded |
| ------------------------- | -------------------- | -------------- |
| Ed25519                   | 0                    | iota1**q**...  |
| Restricted Ed25519        | 1                    | iota1**q**...  |
| Account                   | 8                    | iota1**p**...  |
| Restricted Account        | 9                    | iota1**p**...  |
| NFT                       | 16                   | iota1**z**...  |
| Restricted NFT            | 17                   | iota1**z**...  |
| Implicit Account Creation | 24                   | iota1**r**...  |

| :information_source: Human readability of Bech32 Encoding |
| --------------------------------------------------------- |

The _Address Type_ of a raw address has an effect on the starting character of the bech32 encoded address.

An IOTA mainnet address starts with `iota1`, and continues with the bech32 encoded bytes of the address. By choosing the
integer value of the _Address Type_ as a multiple of 8 for different address types, the first character after the `1`
separator in the bech32 address will always be different.

By looking at the address, a user can identify whether it is a signature backed address, an account, an NFT address or
an implicit account creation address. By increasing the type value by `1` for restricted addresses, the first bech32
character after the separator does not change and users can still identify an Ed25519 address as one, no matter if it is
restricted or not.

### Ed25519 Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
</table>

### Restricted Ed25519 Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Restricted Ed25519 Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Restricted Ed25519 Address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### Account Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
        </td>
    </tr>
    <tr>
        <td>Account ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
</table>

### Restricted Account Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 9</strong> to denote an <i>Restricted Account Address</i>.
        </td>
    </tr>
    <tr>
        <td>Account ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### NFT Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
        </td>
    </tr>
    <tr>
        <td>NFT ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
</table>

### Restricted NFT Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 17</strong> to denote an <i>Restricted NFT Address</i>.
        </td>
    </tr>
    <tr>
        <td>NFT ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### Implicit Account Creation Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 24</strong> to denote an <i>Implicit Account Creation Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Implicit Account Creation Address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
</table>

Note: This address type has additional transaction validation rules specified in [TIP-42](../TIP-0042/tip-0042.md).

## Allowed Capabilities

Allowed Capabilities are a `ByteArray` with a length prefix. For the address that contains them to be valid, the
following conditions must hold:

- The length prefix must be `0` or `1`.
  - Future replacements of this TIP may relax this condition.
- Bit indices start at `0` and are counted starting from the least-significant bit.

### Capability Flags

The following table shows the mapping from the bit pattern to the capability flags, where the `Flag Index` is the index
of the bit.

This list is an Allowlist: If the bit is `1` (**set**) the address has the capability, if the bit is `0` (**unset**) it
does not have it.

| Flag Index | Capability (if flag is set)                                       |
| ---------- | ----------------------------------------------------------------- |
| 0          | Can receive Native Tokens.                                        |
| 1          | Can receive Mana.                                                 |
| 2          | Can receive Outputs with Timelock Unlock Condition.               |
| 3          | Can receive Outputs with Expiration Unlock Condition.             |
| 4          | Can receive Outputs with Storage Deposit Return Unlock Condition. |
| 5          | Can receive Account Outputs.                                      |
| 6          | Can receive NFT Outputs.                                          |
| 7          | Can receive Delegation Outputs.                                   |

#### Semantic transaction validation rules

This section defines the transaction validation rules coming into effect with the capability flags. These are defined in
terms of the flags being **unset**. If the flag is **set**, the rule does not apply to the transaction.

If an output is created on the output side of a transaction with an unlock condition containing an address with this
flag **unset**, then the following conditions must hold for that output:

- Flag 0: The transaction is invalid if the output's `Native Tokens Count != 0`.
- Flag 1: The transaction is invalid if the output's `Mana != 0`.
- Flag 2: The transaction is invalid if the output contains an unlock condition of type Timelock Unlock Condition.
- Flag 3: The transaction is invalid if the output contains an unlock condition of type Expiration Unlock Condition.
- Flag 4: The transaction is invalid if the output contains an unlock condition of type Storage Deposit Return Unlock
  Condition.
- Flag 5: The transaction is invalid if the output is an Account Output.
- Flag 6: The transaction is invalid if the output is an NFT Output.
- Flag 7: The transaction is invalid if the output is an Delegation Output.

## Bech32 encoding

The human-readable encoding of the address is Bech32 (as described in
[BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)). A Bech32 string is at most 90 characters
long and consists of:

- The **human-readable part** (HRP), which conveys the network to which the address belongs (IOTA or Shimmer) and
  distinguishes between production and test networks. See the protocol parameters of the respective network for the
  concrete HRP value.
- The **separator**, which is always `1`.
- The **data part**, which consists of the Base32 binary-encoded serialized address and the 6-character checksum.

## Examples

### Allowed Capabilities Bit Patterns

The following shows examples of Allowed Capabilites bit patterns and their meaning. This only shows the first byte of
the Allowed Capabilites array.

| Bit Pattern (Byte 0) | Meaning                                                                   |
| -------------------- | ------------------------------------------------------------------------- |
| 0000 0011            | Can receive Native Tokens and Mana.                                       |
| 1110 0000            | Can receive Delegation, Account and NFT Outputs (= all kinds of Outputs). |
| 0000 1100            | Can receive Outputs with time-based unlock conditions.                    |

### Bech32 Strings

- **Ed25519 & Implicit Account Creation Address Examples**
  - Common Input
    - Ed25519 compressed public key (32 bytes): `6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8`
    - BLAKE2b-256 hash (32 bytes): `efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 HRP: `iota`
  - **Ed25519 Address (Plain)**
    - serialized (33 bytes): `00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx`
  - **Restricted Ed25519 Address (Every Capability Allowed)**
    - serialized (35 bytes): `01efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a301ff`
    - Bech32 string: `iota1q8hacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xq0l828jhc`
  - **Restricted Ed25519 Address (Every Capability Disallowed)**
    - serialized (34 bytes): `01efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a300`
    - Bech32 string: `iota1q8hacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqq7ar5ue`
  - **Restricted Ed25519 Address (Can receive all kinds of Outputs)**
    - serialized (35 bytes): `01efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a301e0`
    - Bech32 string: `iota1q8hacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xq0qdxukan`
  - **Implicit Account Creation Address**
    - serialized (33 bytes): `18efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1rrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xg4ad2d`

# Drawbacks

- Having a configurable version of each address type means a proliferation of address types. However,
  backwards-compatibility to existing addresses while also allowing for address configuration was a higher priority.

# Rationale & Alternatives

- An alternative would be to reuse the current address type byte as both a type indicator and for capability flags. This
  makes serialization less straightforward as there could be many bit patterns that identify a given address type.
  Separating the address type and capabilities separates serialization and capability setting/extraction, which are two
  different concerns.
- For each address type there are two versions: An unrestricted one and a restricted one. The former allows every
  capability implicitly, and the latter - in contrast - disallows everything by default, if the default capability byte
  is `0x00`. That is why the flags are defined as an Allow List rather than a Deny List. A `0x00` byte disallows every
  available capability for restricted address types.
- Implicit Account Creation Address is a separate type of address rather than a capability because it implies many of
  the capability flags but also has additional non-trivial transaction validation rules that don't fit together with the
  other boolean flags that are only concerned about one aspect of transaction validity. It would also have impliciations
  for address validity. For instance, it would be invalid for an NFT Address to have the flag for implicit account
  creation set. Other capability flags do not have impliciations for address validity. These reasons warrant a separate
  address type.
- Backwards-compatibility with the existing address format is important since addresses are highly user-facing and users
  expect them to be stable and permanent. Thus, adding separate configurable versions of addresses means
  backwards-compatibility with previous address types while also allowing for configurable versions at the cost of
  address type proliferation.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
