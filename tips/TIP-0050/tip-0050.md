---
tip: 50
title: Configurable Bech32 Addresses
description: Extendable and configurable address format supporting various signature schemes and address types
author: TODO
discussions-to: TODO
status: TODO
type: Standards
layer: Interface
created: 2023-09-04
replaces: 11
---

# Summary

This document proposes an extension of Bech32 addresses, defined in [TIP-11](../TIP-0011/tip-0011.md), to make them
configurable. Bech32 is an extendable address format for the IOTA protocol supporting various signature schemes and
address types. It relies on the [Bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) format to
provide a compact, human-readable encoding with strong error correction guarantees.

# Motivation

IOTA 2.0 uses an [account-centric ledger](../TIP-0042/tip-0042.md). Accounts face a bootstrapping problem where users
need to own an Account with a _Block Issuer Feature_ in order to issue blocks, but cannot create it themselves, since
they cannot issue blocks yet. To support the _implicit account_ creation mechanism defined in that TIP, configurable
addresses are needed. These are addresses that self-describe their capabilities, such as being an _implicit account
address_.

Another motivation for such configurable addresses is that certain users do not want to receive certain asset classes.
For example, some users may not want to receive Native Tokens or Non-Fungible Tokens for legal reasons. Configurable
addresses make it possible to express whether an address can receive such assets. In essence, these address capabilities
can add additional validation rules in the transaction in which outputs owned by these addresses are consumed or when
outputs owned by these addresses are created.

This TIP therefore builds on the format defined in TIP-11 in a backwards-compatible manner, while extending the
capabilities of the address.

# Detailed design

## Binary serialization

The address format uses a simple serialization scheme which consists of two parts:

- The first byte describes the type and capability of the address as bitflags and whether more bytes follow that express
  additional capability flags. See [Capability Byte](#capability-bytes) for their serialization.
- The remaining bytes contain the type-specific raw address bytes.

## Bech32 for human-readable encoding

The human-readable encoding of the address is Bech32 (as described in
[BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)). A Bech32 string is at most 90 characters
long and consists of:

- The **human-readable part** (HRP), which conveys the network to which the address belongs (IOTA or Shimmer) and
  distinguishes between production and test networks. See the protocol parameters of the respective network for the
  concrete HRP value.
- The **separator**, which is always `1`.
- The **data part**, which consists of the Base32 encoded serialized address and the 6-character checksum.

## Capability Bytes

Capability Bytes are a sequence of bytes that need to follow these rules:

- There must be exactly one capability byte in this version of the TIP.
- The bit pattern of the first byte is `MRRT TCCC` (with the space for display purposes only). Bit indices are counted
  starting from the least significant bytes.
- If the most significant bit `M` in a capability byte is `1`, there is a continuation byte.
  - However, `M` must be `0` in this version of the TIP. The usage of continuation bytes is left to be defined in a
    future replacement of this TIP.
- Bits `R` with indices `5` and `6` are reserved for future use and may be used as address type bits or as capability
  flags. They must be `0` in this version of the TIP.
- Bits `T` with indices `3` and `4` indicate the type of the address.
- Bits `C` with indices `0` to `2` are mapped to a capability.

### Address Type Table

The following table shows the mapping from the bit to the address type:

| Bit Pattern | Address Type    |
| ----------- | --------------- |
| 0000 0CCC   | Ed25519 Address |
| 0000 1CCC   | Account Address |
| 0001 0CCC   | NFT Address     |

- If a bit pattern is not listed it is an invalid address.

### Capability Flags Table

The following table shows the mapping from the bit flag index to the capability:

| Flag Index | Set                                    | Unset                           |
| ---------- | -------------------------------------- | ------------------------------- |
| 0          | Cannot receive Native Tokens (1)       | Can receive Native Tokens       |
| 1          | Cannot receive Non-Fungible Tokens (2) | Can receive Non-Fungible Tokens |
| 2          | Implicit Account (3)                   | No effect                       |

#### Additional address validation rules

- If the flag index is `2`, the address is only valid if the type is `Account Address`, otherwise it is invalid.

#### Additional semantic transaction validation rules

This section defines additional transaction validation rules coming into effect with the capability flags.

- (1) If an output is created on the output side of a transaction with an unlock condition containing an address with
  this flag, the transaction is invalid if the output can hold native tokens and `Native Tokens Count != 0`.
- (2) If an NFT Output is created on the output side of a transaction with an unlock condition containing an address
  with this flag, the transaction is invalid.
- (3) The transaction validation rules of implicit account addresses are defined in [TIP-42](../TIP-0042/tip-0042.md).
  TODO: Link more specificially.

## Examples

### Bit Patterns

The following shows examples of bit patterns and their meaning.

| Bit Pattern | Meaning                                                                 |
| ----------- | ----------------------------------------------------------------------- |
| 0000 0000   | Plain Ed25519 Address                                                   |
| 0000 1000   | Plain Account Address                                                   |
| 0001 0000   | Plain NFT Address                                                       |
| 0000 1100   | Implicit Account Address                                                |
| 0000 0011   | Ed25519 Address which cannot receive Native Tokens or NFTs              |
| 0000 1111   | Implicit Account Address which cannot receive Native Tokens or NFTs     |
| 0001 0100   | Invalid (implicit account flag requires the type to be Account Address) |
| 1000 0000   | Invalid (continuation bytes are not defined in this version of the TIP) |
| 0001 1000   | Invalid (unknown address type)                                          |

### Bech32 Strings

- **Ed25519 Address Examples**
  - Common Input
    - Ed25519 compressed public key (32-byte): `6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8`
    - BLAKE2b-256 hash (32-byte): `efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 HRP: `iota`
  - **Ed25519 Address (Plain)**
    - serialized (33-byte): `00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx`
  - **Ed25519 Address (No Native Tokens and NFTs)**
    - serialized (33-byte): `03efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1q0hacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8qj2pk`
- **Account Address Examples**
  - Common Input
    - Account ID: `0x601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 HRP: `iota`
  - **Account Address (Plain)**
    - serialized (33-byte): `0x08601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 string: `iota1ppspu4mpwse86wz6rp7kgjgugpzry8nsfeh9682h9fvjcnc0q4es5m3qzs9`
  - **Account Address (Implicit)**
    - serialized (33-byte): `0x0c601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 string: `iota1p3spu4mpwse86wz6rp7kgjgugpzry8nsfeh9682h9fvjcnc0q4es5gkx9ut`

# Drawbacks

- This approach convolutes the address type and the capability flags, making it less straightforward to specify. It is
  also harder to deserialize the address based only on the type byte, since multiple byte values map to the same address
  type and the byte needs to be preserved to have access to the flags. However, backwards-compatibility was a higher
  priority.

# Rationale and alternatives

- TODO

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
