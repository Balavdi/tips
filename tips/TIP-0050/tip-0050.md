---
tip: 50
title: Configurable Addresses
description: Extendable and configurable address format supporting various signature schemes and address types
author: TODO
discussions-to: TODO
status: TODO
type: Standards
layer: Interface
created: 2023-09-04
replaces: 11
---

# Table of Contents

1. [Summary](#summary)
2. [Motivation](#motivation)
3. [Binary serialization](#binary-serialization)
   - [Address Types](#address-types)
   - [Allowed Capabilities](#allowed-capabilities)
   - [Bech32 encoding](#bech32-encoding)
   - [Examples](#examples)
4. [Copyright](#copyright)

# Summary

This document proposes an extension to the address format to make them configurable. This enables an address to opt-in
or -out of certain functionality, like disabling the receival of Native Tokens or NFTs. The address format and encoding
was previously defined in [TIP-11](../TIP-0011/tip-0011.md) and this TIP replaces it.

The human-readable encoding of addresses continues to be done through Bech32, which is an extendable address format for
the IOTA protocol supporting various signature schemes and address types. It relies on the
[Bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) format to provide a compact, human-readable
encoding with strong error correction guarantees.

# Motivation

IOTA 2.0 uses an [account-centric ledger](../TIP-0042/tip-0042.md). Accounts face a bootstrapping problem where users
need to own an Account with a _Block Issuer Feature_ in order to issue blocks, but cannot create it themselves, since
they cannot issue blocks yet. To support the _implicit account_ creation mechanism defined in that TIP, configurable
addresses are needed. These are addresses that self-describe their capabilities, such as being an _implicit account
address_.

Another motivation for such configurable addresses is that certain users do not want to receive certain asset classes.
For example, some users may not want to receive Native Tokens or Non-Fungible Tokens for legal reasons. Configurable
addresses make it possible to express whether an address can receive such assets. In essence, these address capabilities
can add additional validation rules in the transaction in which outputs owned by these addresses are consumed or when
outputs owned by these addresses are created.

This TIP therefore builds on the format defined in TIP-11 in a backwards-compatible manner, while extending the
capabilities of the address.

# Binary serialization

The address format uses a simple serialization scheme which consists of three parts:

- The first byte describes the type of the address.
- The following bytes contain the type-specific raw address bytes.
- Depending on the address type, the address may contain additional bytes as bitflags capability flags. See
  [Capability Byte](#capability-bytes) for their serialization.

## Address Types

The following table shows the mapping from the address type of the **first byte** to the address type:

- If a bit pattern is not listed it is an invalid address. Only Ed25519 Addresses can have capabilities.

| :information_source: Good to know about address format |
| ------------------------------------------------------ |

The _Address Type_ of a raw address has an effect on the starting character of the bech32 encoded address.

An IOTA mainnet address start with `iota1`, and continues with the bech32 encoded bytes of the address. By choosing the
integer value of the _Address Type Byte_ as a multiple of 8 for different address types, the first character after the
`1` separator in the bech32 address will always be different.

| Address                   | Type Byte as `uint8` | Bech32 Encoded |
| ------------------------- | -------------------- | -------------- |
| Ed25519                   | 0                    | iota1**q**...  |
| Restricted Ed25519        | 1                    | iota1**q**...  |
| Account                   | 8                    | iota1**p**...  |
| Restricted Account        | 9                    | iota1**p**...  |
| NFT                       | 16                   | iota1**z**...  |
| Restricted NFT            | 17                   | iota1**z**...  |
| Implicit Account Creation | 24                   | iota1**r**...  |

By looking at the address, a user can identify whether it is a signature backed address, an account, an NFT address or
an implicit account creation address. By increasing the type value by `1` for restricted addresses, the bech32 character
does not change, so users can still identify an Ed25519 address as one, no matter if it is restricted or not.

### Ed25519 Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
</table>

### Restricted Ed25519 Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 1</strong> to denote an <i>Restricted Ed25519 Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Restricted Ed25519 Address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### Account Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 8</strong> to denote an <i>Account Address</i>.
        </td>
    </tr>
    <tr>
        <td>Account ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
</table>

### Restricted Account Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 9</strong> to denote an <i>Restricted Account Address</i>.
        </td>
    </tr>
    <tr>
        <td>Account ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>Account ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### NFT Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 16</strong> to denote an <i>NFT Address</i>.
        </td>
    </tr>
    <tr>
        <td>NFT ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
</table>

### Restricted NFT Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 17</strong> to denote an <i>Restricted NFT Address</i>.
        </td>
    </tr>
    <tr>
        <td>NFT ID</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the <i>NFT ID</i> which is the BLAKE2b-256 hash of the outputID that created it.</td>
    </tr>
    <tr>
        <td>Allowed Capabilities</td>
        <td>(uint8)ByteArray</td>
        <td>Bitflags expressed as a series of bytes. A leading uint8 denotes its length.</td>
    </tr>
</table>

### Implicit Account Creation Address

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Address Type</td>
        <td>uint8</td>
        <td>
            Set to <strong>value 24</strong> to denote an <i>Implicit Account Creation Address</i>.
        </td>
    </tr>
    <tr>
        <td>PubKeyHash</td>
        <td>ByteArray[32]</td>
        <td>The raw bytes of the Implicit Account Creation Address which is the BLAKE2b-256 hash of the Ed25519 public key.</td>
    </tr>
</table>

## Allowed Capabilities

Allowed Capabilities are a sequence of bytes. For the address that contains them to be valid, the following conditions
must hold:

- The length prefix must be `0` or `1`.
- Bit indices start at `0` and are counted starting from the least-significant bit.

### Capability Flags Table

The following table shows the mapping from the bit pattern to the capability flags, where the `Flag Index` is the index
of the bit. This list is an Allowlist, meaning it allows functionality that is otherwise disallowed.

| Flag Index | Allowed Capability                                               |
| ---------- | ---------------------------------------------------------------- |
| 0          | Can receive Native Tokens                                        |
| 1          | Can receive Mana                                                 |
| 2          | Can receive Outputs with Timelock Unlock Condition               |
| 3          | Can receive Outputs with Expiration Unlock Condition             |
| 4          | Can receive Outputs with Storage Deposit Return Unlock Condition |
| 5          | Can receive Account Outputs                                      |
| 6          | Can receive NFT Outputs                                          |
| 7          | Can receive Delegation Outputs                                   |

#### Additional semantic transaction validation rules

This section defines additional transaction validation rules coming into effect with the capability flags. These are
defined in terms of the flags being **unset** (`0`). If the flag is **set** (`1`), the rule does not apply to the
transaction.

If an output is created on the output side of a transaction with an unlock condition containing an address with this
flag **unset**, then the following conditions must hold:

- Flag 0: The transaction is invalid if the output can hold native tokens and `Native Tokens Count != 0`.
- Flag 1: The transaction is invalid if the output can hold Mana and `Mana != 0`.
- Flag 2: The transaction is invalid if the output contains an unlock condition of type Timelock Unlock Condition.
- Flag 3: The transaction is invalid if the output contains an unlock condition of type Expiration Unlock Condition.
- Flag 4: The transaction is invalid if the output contains an unlock condition of type Storage Deposit Return Unlock
  Condition.
- Flag 5: The transaction is invalid if the output is an Account Output.
- Flag 6: The transaction is invalid if the output is an NFT Output.
- Flag 7: The transaction is invalid if the output is an Delegation Output.

## Bech32 encoding

The human-readable encoding of the address is Bech32 (as described in
[BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)). A Bech32 string is at most 90 characters
long and consists of:

- The **human-readable part** (HRP), which conveys the network to which the address belongs (IOTA or Shimmer) and
  distinguishes between production and test networks. See the protocol parameters of the respective network for the
  concrete HRP value.
- The **separator**, which is always `1`.
- The **data part**, which consists of the Base32 binary-encoded serialized address and the 6-character checksum.

## Examples

TODO

<!-- ### Bit Patterns

The following shows examples of bit patterns and their meaning.

| Bit Pattern | Meaning                                                                 |
| ----------- | ----------------------------------------------------------------------- |
| 0000 0000   | Plain Ed25519 Address                                                   |
| 0000 1000   | Plain Account Address                                                   |
| 0001 0000   | Plain NFT Address                                                       |
| 0000 1100   | Implicit Account Address                                                |
| 0000 0011   | Ed25519 Address which cannot receive Native Tokens or NFTs              |
| 0000 1111   | Implicit Account Address which cannot receive Native Tokens or NFTs     |
| 0001 0100   | Invalid (implicit account flag requires the type to be Account Address) |
| 1000 0000   | Invalid (continuation bytes are not defined in this version of the TIP) |
| 0001 1000   | Invalid (unknown address type)                                          |

### Bech32 Strings

- **Ed25519 Address Examples**
  - Common Input
    - Ed25519 compressed public key (32-byte): `6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8`
    - BLAKE2b-256 hash (32-byte): `efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 HRP: `iota`
  - **Ed25519 Address (Plain)**
    - serialized (33-byte): `00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx`
  - **Ed25519 Address (No Native Tokens and NFTs)**
    - serialized (33-byte): `03efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3`
    - Bech32 string: `iota1q0hacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8qj2pk`
- **Account Address Examples**
  - Common Input
    - Account ID: `0x601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 HRP: `iota`
  - **Account Address (Plain)**
    - serialized (33-byte): `0x08601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 string: `iota1ppspu4mpwse86wz6rp7kgjgugpzry8nsfeh9682h9fvjcnc0q4es5m3qzs9`
  - **Account Address (Implicit)**
    - serialized (33-byte): `0x0c601e576174327d385a187d64491c4044321e704e6e5d1d572a592c4f0f05730a`
    - Bech32 string: `iota1p3spu4mpwse86wz6rp7kgjgugpzry8nsfeh9682h9fvjcnc0q4es5gkx9ut` -->

<!-- # Drawbacks

- This approach convolutes the address type and the capability flags, making it less straightforward to specify. It is
  also harder to deserialize the address based only on the type byte, since multiple byte values map to the same address
  type and the byte needs to be preserved to have access to the flags. However, backwards-compatibility was a higher
  priority.

# Rationale and alternatives

- An alternative serialization format would be to add dedicated bytes for the capability flags, e.g. of the format
  `<address type byte><capability flag bytes><raw address bytes>`. This would result in better serialization support,
  since the type and capabilites would be strictly separated. However, this format is not backwards-compatible.
  Backwards-compatibility is important since addresses are highly user-facing and users expect them to be stable and
  permanent. A change in compatibility could be problematic.
  - A potential solution to maintain backwards-compatibility with this approach is to continue to support old addresses,
    which, relative to the above proposal, can be detected by their shorter length due to the missing capability flags.
    That means effectively supporting two address formats, one of which would be configurable. This adds complexity and
    is less desirable than a single address format that is both backwards-compatible, configurable and extensible in the
    future. -->

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
