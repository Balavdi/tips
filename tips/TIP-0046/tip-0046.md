---
tip: 46
title: Tangle Block for IOTA 2.0
description: The Block for IOTA 2.0 and validation block type
author: TODO
discussions-to: TODO
status: Draft
type: Standards
layer: Core
replaces: 24
created: 2023-05-16
---

# Table of Contents

- [Table of Contents](#table-of-contents)
- [Summary](#summary)
- [Motivation](#motivation)
- [Building Blocks](#building-blocks)
  - [Block ID](#block-id)
    - [Calculation](#calculation)
  - [Slot Index](#slot-index)
  - [Slot Commitment](#slot-commitment)
    - [Slot Commitment ID](#slot-commitment-id)
  - [Signature](#signature)
- [Block Types](#block-types)
  - [Block](#block)
    - [Serialized Layout](#serialized-layout)
    - [Syntactic validation](#syntactic-validation)
    - [Semantic Validation](#semantic-validation)
    - [Payloads](#payloads)
  - [Validation Block](#validation-block)
    - [Serialized Layout](#serialized-layout-1)
    - [Syntactic validation](#syntactic-validation-1)
    - [Semantic Validation](#semantic-validation-1)
- [Rationale and alternatives](#rationale-and-alternatives)
- [Copyright](#copyright)

# Summary

The Tangle is the graph data structure behind IOTA. For the Stardust upgrade we introduced an additional abstraction
layer on top of legacy IOTA version transactions where the vertices are generalized _blocks_, which then contain the
transactions or other structures that are processed by the IOTA protocol. Just as before, each block directly approves
other blocks, which are known as _parents_. The new block structure matches the requirements introduced by the IOTA 2.0
version of the protocol. We change the calculation of the `Block ID`. Additionally, to updating the fields of the
existing Block data structure, we introduce the _Validation Block_, which is a special type of block that is used by
validators.

The Block can contain a payload. These are core payloads that will be processed by all nodes as part of the IOTA
protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.

Validation Blocks have additional functionality and different fields, validation rules, and allowed payloads.

# Motivation

To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame
that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a
certain responsibility and once this responsibility is completed, we move on to the next layer.

The same is true with how blocks are parsed. The outer layer of the block enables the mapping of the block to a vertex
in the Tangle and allows us to perform some basic validation. The next layer may be a transaction that mutates the
ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.

By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to
accommodate future needs.

# Building Blocks

This section describes common building blocks used across multiple block types.

## Block ID

A Block ID denotes an identifier of a block, with type `ByteArray[40]`. It is created from three separately spelled out
fields due to commitment proof requirements to keep attestation proofs lightweight. It is calculated as the following
steps, using the [BLAKE2b-256](https://tools.ietf.org/html/rfc7693) hash function:

- `content` is the serialized block **without** signature and nonce.
- `slot_index` is the slot index of the `Issuing Time` of the block. **Note**: It is **not** the same slot index as in
  the Slot Commitment.
- `signatureBytes` is the serialized signature.

### Calculation

1. `content_hash` = hash(`content`)
2. `id` = hash(concat(`content_hash`, signatureBytes))
3. `Block ID` = concat(`id`, `slot_index`)

The string format of the Block ID is the hexadecimal encoding of the `Block ID` with a `0x` prefix.

## Slot Index

Timeline is divided into slots, and each slot has a corresponding slot index, which is a `uint64`.
To calculate the slot index of a timestamp, `genesisTimestamp` and the duration of a slot are needed.
The slot index of timestamp `ts` is `(ts - genesisTimestamp)/duration + 1`.
Slots are counted starting from 1 because 0 is reserved for the genesis which has to be addressable as its own.

## Slot Commitment

A Slot Commitment contains a summary of a slot. The Slot Commitment is serialized as follows:

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Index</td>
    <td>uint64</td>
    <td>
      The slot index.
    </td>
  </tr>
  <tr>
    <td>Prev ID</td>
    <td>ByteArray[40]</td>
    <td>The slot identifier of the previous slot in the chain.</td>
  </tr>
  <tr>
    <td>Roots ID</td>
    <td>ByteArray[32]</td>
    <td>The Merkle Tree Root of all commitment elements.</td>
  </tr>
  <tr>
    <td>Cumulative Weight</td>
    <td>uint64</td>
    <td>The weight of the chain of the <code>Index</code> minus <code>Maximum Committable Age</code> slots in the past. This is required for attestations on whether to switch slot commitment chains.</td>
  </tr>
</table>

### Slot Commitment ID

Slot Commitment ID denotes an identifier of a slot commitment, with type `ArrayBytes[40]`. It is calculated as the following steps, using BLAKE2b-256 hash function:

* `content` is the serialized slot commitment.
* `slot_index` is the slot index of the slot commitment.

Calculation:
1. `content_hash` = hash(`content`)
2. And finally, `CommitmentID` = Concat(`content_hash`, `slot_index`) 

The string format of Slot Commitment ID is hexadecimal encoding of Slot Commitment ID with `0x` prefix.

## Signature

The _Ed25519 Signature_ is supported. It is serialized as follows:

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Signature Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
    </td>
  </tr>
  <tr>
    <td>Public key</td>
    <td>ByteArray[32]</td>
    <td>The Ed25519 public key of the signature.</td>
  </tr>
  <tr>
    <td>Signature</td>
    <td>ByteArray[64]</td>
    <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
  </tr>
</table>

The `Signature` field over the block is computed as follows:

1. Compute the `serializedTime` by serializing the `int64` representing the nanoseconds of `Issuing Time` in little
   endian.
2. Compute the `commitmentId` by computing the slot identifier of the slot commitment.
3. Compute the `contentHash` by computing the Blake2b-256 hash over the serialized block without the `Signature` and
   `Nonce` fields.
4. Generate the `signingInput` as the concatentation of `serializedTime`, `commitmentId` and `contentHash`.
5. Sign the `signingInput` with Ed25519 which returns a `ByteArray[64]`.

**Semantic Validation**

In order for the signature to be valid all of the following conditions must hold:

- The `Public Key` must verify the `Signature`.
- The `Public Key` must be included as a _Block Issuer Key_ in the Account identified by the block's `Account ID` field.
  This check is executed against the account state at the slot index corresponding to the `Issuing Time` of the block
  minus `Maximum Committable Age` slots in the past.

# Block Types

## Block

_Block_ uses the introduced [Block ID](#block-id) as its identifier.

### Serialized Layout

The following table describes the serialization of a _Block_ following the notation from
[TIP-21](../TIP-0021/tip-0021.md):

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Type</td>
    <td>uint8</td>
    <td>This field denotes the type of the block, used to decide which rules apply to the block. Set to <strong>value 0</strong> to denote a <i>Block</i>.</td>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Strong Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are strongly directly approved.</td>
  </tr>
  <tr>
    <td>Strong Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the strong parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Weak Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are weakly directly approved.</td>
  </tr>
  <tr>
    <td>Weak Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Shallow Like Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are directly referenced to adjust opinion.</td>
  </tr>
  <tr>
    <td>Shallow Like Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Account ID</td>
    <td>ByteArray[32]</td>
    <td>The identifier of the account that issued this block.</td>
  </tr>
  <tr>
    <td>Issuing Time</td>
    <td>uint64</td>
    <td>The time at which the block was issued. It is a Unix timestamp in nanoseconds.</td>
  </tr>
<tr>
  <td>Burned Mana</td>
    <td>uint64</td>
    <td>The amount of Mana the Account identified by <code>Account ID</code> is at most willing to burn for this block. The actual Mana deducted from this Account's Block Issuance Credit is calculated according to its size and the current RMC value which may be lower than the value of this field.</td>
</tr>
  <tr>
    <td>Slot Commitment</td>
    <td colspan="2">
      <details open="open">
        <summary>Slot Commitment</summary>
        <blockquote>
          A Slot Commitment contains a summary of a slot. More details in the <a href="#slot-commitment">Slot Commitment section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
  <tr>
    <td>Latest Finalized Slot</td>
    <td>uint64</td>
    <td>The slot index of the latest finalized slot.</td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td>Payload <code>optOneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Tagged Data Payload</summary>
        <blockquote>
          With Payload Type 5, more details are described in Tagged Data Payload section.
        </blockquote>
      </details>
      <details>
        <summary>Transaction Payload</summary>
        <blockquote>
          With Payload Type 6, more details are described in Transaction section.
        </blockquote>
      </details>
  </tr>
  <tr>
    <td>Signature <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Ed25519 Signature</summary>
        <blockquote>
          An Ed25519 Signature. More details in the <a href="#slot-commitment">Signature section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
</table>

### Syntactic validation

The Tangle can only contain syntactically valid blocks. Invalid blocks must be rejected by the node. The following
criteria defines whether the block passes the syntactic validation:

- The total length of the serialized block must not exceed `Max Block Length`.
- `Type` must comply with the allowed block types for the `Protocol Version` config parameter of the node.
  - It must hold true that 1 ≤ `Strong Parents Count` ≤ 8.
  - It must hold true that 0 ≤ `Weak Parents Count` ≤ 8.
  - It must hold true that 0 ≤ `Shallow Like Parents Count` ≤ 8.
- `Strong Parents`, `Weak Parents`, `Shallow Like Parents` must comply with the following rules:
  - must be lexically ordered.
  - must not have duplicates in each list.
- `Weak Parents` must be disjoint to the rest of the parents, no weak parent should be in either strong or shallow like
  parents.
- Each `Block ID` must be unique.
- Payload (if present):
  - `Payload Type` must match one of the values described under [Payloads](#payloads).
  - `Data Fields` must be correctly parsable in the context of the `Payload Type`.
  - The payload itself must pass syntactic validation.
- There must be no trailing bytes after all block fields have been parsed.

### Semantic Validation
- The `Signature` must pass semantic validation.
- Time restrictions for blocks including a transaction:
  - If a `Block` contains a transaction payload. The Slot Index from `Issuing Time` of a block must be greater or equal than Issuing Time slot of the transaction included.

### Payloads

While blocks without a payload, i.e. `Payload Length` set to zero, are valid, such blocks do not contain any
information. As such, blocks usually contain a payload. The detailed specification of each payload type is out of scope
of this TIP. The following table lists all currently specified payloads that can be part of a block and links to their
specification:

| Payload Name | Type Value | TIP                               |
| ------------ | ---------- | --------------------------------- |
| No Payload   | -          | -                                 |
| Tagged Data  | 5          | [TIP-23](../TIP-0023/tip-0023.md) |
| Transaction  | 7          | [TIP-45](../TIP-0045/tip-0045.md) |

## Validation Block

A Validation Block is a special type of block used by validators to secure the network. It is recognised by the
Congestion Control of the IOTA 2.0 protocol and can be issued without burning Mana within the
constraints of the allowed validator throughput. It is allowed to reference more parent blocks than a normal _Block_.
_Validation Block_ uses the introduced [Block ID](#block-id) as its identifier.

### Serialized Layout

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
 <tr>
    <td>Type</td>
    <td>uint8</td>
    <td>This field denotes the type of the block, used to decide which rules apply to the block. Set to <strong>value 1</strong> to denote a <i>Validation Block</i>.</td>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Strong Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are strongly directly approved.</td>
  </tr>
  <tr>
    <td>Strong Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the strong parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Weak Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are weakly directly approved.</td>
  </tr>
  <tr>
    <td>Weak Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Shallow Like Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are directly referenced to adjust opinion.</td>
  </tr>
  <tr>
    <td>Shallow Like Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
<tr>
    <td>Account ID</td>
    <td>ByteArray[32]</td>
    <td>The identifier of the account that issued this block.</td>
  </tr>
  <tr>
    <td>Issuing Time</td>
    <td>uint64</td>
    <td>The time at which the block was issued. It is a Unix timestamp in nanoseconds.</td>
  </tr>
  <tr>
<td>Slot Commitment</td>
    <td colspan="2">
      <details open="open">
        <summary>Slot Commitment</summary>
        <blockquote>
          A Slot Commitment contains a summary of a slot. More details in the <a href="#slot-commitment">Slot Commitment section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
  <tr>
    <td>Latest Finalized Slot</td>
    <td>uint64</td>
    <td>The slot index of the latest finalized slot.</td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td>Payload <code>optOneOf</code></td>
    <td colspan="2">
      <details>
        <summary>None</summary>
      </details>
  </tr>
  <tr>
    <td>Signature <code>oneOf</code></td>
    <td colspan="2">
          <details>
        <summary>Ed25519 Signature</summary>
        <blockquote>
          An Ed25519 Signature. More details in the <a href="#slot-commitment">Signature section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
</table>

### Syntactic validation

The Tangle can only contain syntactically valid blocks. Invalid blocks must be rejected by the node. The following
criteria defines whether the block passes the syntactic validation:

- The total length of the serialized block must not exceed `Max Block Length`.
- `Type` must comply with the allowed block types for the `Protocol Version` config parameter of the node.
  - TODO: How many parents can a validation block reference?
  - It must hold true that 1 ≤ `Strong Parents Count` ≤ TODO.
  - It must hold true that 0 ≤ `Weak Parents Count` ≤ TODO.
  - It must hold true that 0 ≤ `Shallow Like Parents Count` ≤ TODO.
- `Strong Parents`, `Weak Parents`, `Shallow Like Parents` must comply with the following rules:
  - must be lexically ordered.
  - must not have duplicates in each list.
- `Weak Parents` must be disjoint to the rest of the parents, no weak parent should be in either strong or shallow like
  parents.
- Each `Block ID` must be unique.
- `Payload Length` must be 0 and the `Payload` must not be present.
- There must be no trailing bytes after all block fields have been parsed.

### Semantic Validation

- The `Signature` must pass semantic validation.

# Rationale and alternatives

**Validation Block**

The alternative could be to use a `Block` instead of `Validation Block` with some additional validation logic. However,
having a separate block type for validator related responsibilites is much cleaner and allows for additional changes
like allowing to reference more parents, or having specific payload types or fields in the future.

**Burned Mana**

The rationale for including the `Burned Mana` field on the block is the following. For a given block, the account
identified by the `Account ID` field on the block needs to burn the amount of Mana corresponding to the RMC and the
block size. A malicious node might provide a false, lower RMC value. If the field was not present, the required Mana
would be deducted from the account's Block Issuance Credit (BIC), but the account would not allot enough Mana in the
containing transaction, since it assumed a lower RMC value. This would result in a negative BIC balance and the locking
of the account. The `Burned Mana` field prevents this situation by effectively stating the assumption under which the
account operates. If `Burned Mana` is lower than it should be, the block can simply be dropped without incurring a cost
for the issuing account. Thus, as long as `Burned Mana` matches the amount allotted in the contained transaction, the
transaction will never result in the locking of the account.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
