---
tip: 46
title: Tangle Block for IOTA 2.0
description: The Block for IOTA 2.0 and validation block type
author: TODO
discussions-to: TODO
status: Draft
type: Standards
layer: Core
replaces: 24
created: 2023-05-16
---

# Table of Contents

1. [Summary](#summary)
2. [Motivation](#motivation)
3. [Building Blocks](#building-blocks)
    - [Block ID](#block-id)
    - [Slot Commitment](#slot-commitment)
    - [Signature](#signature)
4. [Block Types](#block-types)
    - [Block](#block)
    - [Validation Block](#validation-block)
5. [Rationale and Alternatives](#rationale-and-alternatives)
5. [Copyright](#copyright)

# Summary

The Tangle is the graph data structure behind IOTA. For the Stardust upgrade we introduced an additional abstraction layer on top of legacy IOTA version transactions where the vertices are generalized *blocks*, which then contain the transactions or other structures that are processed by the IOTA protocol. Just as before, each block directly approves other blocks, which are known as _parents_. The new block structure matches the requirements introduced by the IOTA 2.0 version of the protocol. We change the calculation of the `Block ID`. Additionally, to updating the fields of the existing Block data structure, we introduce the _Validation Block_, which is a special type of block that is used by validators.

The Block can contain a payload. These are core payloads that will be processed by all nodes as part of the IOTA protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.

Validation Blocks have additional functionality and different fields, validation rules, and allowed payloads.

# Motivation

To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a certain responsibility and once this responsibility is completed, we move on to the next layer.

The same is true with how blocks are parsed. The outer layer of the block enables the mapping of the block to a vertex in the Tangle and allows us to perform some basic validation. The next layer may be a transaction that mutates the ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.

By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to accommodate future needs.

# Building Blocks

This section describes common building blocks used across multiple block types.

## Block ID

A Block ID denotes an identifier of a block, with type `ByteArray[40]`. It is created from three separately spelled out fields due to commitment proof requirements to keep attestation proofs lightweight. It is calculated as the following steps, using the [BLAKE2b-256](https://tools.ietf.org/html/rfc7693) hash function:

* `content` is the serialized block **without** signature and nonce.
* `slot_index` is the slot index of the `Issuing Time` of the block.
  **Note**: It is **not** the same slot index as in the Slot Commitment.
* `signatureBytes` is the serialized signature.

### Calculation

1. `content_hash` = hash(`content`)
2. `id` = hash(concat(`content_hash`, signatureBytes))
3. `Block ID` = concat(`id`, `slot_index`)

The string format of the Block ID is the hexadecimal encoding of the `Block ID` with a `0x` prefix.

## Slot Commitment

A Slot Commitment contains a summary of a slot. The Slot Commitment is serialized as follows:

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Index</td>
    <td>uint64</td>
    <td>
      The slot index.
    </td>
  </tr>
  <tr>
    <td>Prev ID</td>
    <td>ByteArray[40]</td>
    <td>The slot identifier of the previous slot in the chain.</td>
  </tr>
  <tr>
    <td>Roots ID</td>
    <td>ByteArray[32]</td>
    <td>The Merkle Tree Root of all commitment elements.</td>
  </tr>
  <tr>
    <td>Cumulative Weight</td>
    <td>uint64</td>
    <td>The weight of the chain of the <code>Index</code> minus <code>Maximum Committable Age</code> slots in the past. This is required for attestations on whether to switch slot commitment chains.</td>
  </tr>
</table>

## Signature

The _Ed25519 Signature_ is supported. It is serialized as follows:

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Signature Type</td>
    <td>uint8</td>
    <td>
      Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
    </td>
  </tr>
  <tr>
    <td>Public key</td>
    <td>ByteArray[32]</td>
    <td>The Ed25519 public key of the signature.</td>
  </tr>
  <tr>
    <td>Signature</td>
    <td>ByteArray[64]</td>
    <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
  </tr>
</table>

The `Signature` field over the block is computed as follows:

1. Compute the `serializedTime` by serializing the `int64` representing the nanoseconds of `Issuing Time` in little endian. TODO: In code this is currently serialized as int64 but the block field is uint64 - inconsistent.
2. Compute the `commitmentId` by computing the slot identifier of the slot commitment. The slot identifier is of type `ByteArray[40]`, computed as follows:
    - Compute the Blake2b-256 hash over the serialized slot commitment.
    - Return the slot identifier as the concatenation of the hash with the little-endian encoded slot index.
3. Compute the `contentHash` by computing the Blake2b-256 hash over the serialized block without the `Signature` and `Nonce` fields.
4. Generate the `signingInput` as the concatentation of `serializedTime`, `commitmentId` and `contentHash`.
5. Sign the `signingInput` with Ed25519 which returns a `ByteArray[64]`.

**Semantic Validation**

In order for the signature to be valid all of the following conditions must hold:

- The `Public Key` must verify the `Signature`.
- The `Public Key` must be included as a _Block Issuer Key_ in the Account identified by the block's `Account ID` field. This check is executed against the account state at `MCA` slots in the past.

# Block Types

## Block

_Block_ uses the introduced [Block ID](#block-id) as its identifier.

### Serialized Layout

The following table describes the serialization of a _Block_ following the notation from [TIP-21](../TIP-0021/tip-0021.md):

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Type</td>
    <td>uint8</td>
    <td>This field denotes the type of the block, used to decide which rules apply to the block. Set to <strong>value 0</strong> to denote a <i>Block</i>.</td>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Strong Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are strongly directly approved.</td>
  </tr>
  <tr>
    <td>Strong Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the strong parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Weak Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are weakly directly approved.</td>
  </tr>
  <tr>
    <td>Weak Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Shallow Like Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are directly referenced to adjust opinion.</td>
  </tr>
  <tr>
    <td>Shallow Like Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Account ID</td>
    <td>ByteArray[32]</td>
    <td>The identifier of the account that issued this block.</td>
  </tr>
  <tr>
    <td>Issuing Time</td>
    <td>uint64</td>
    <td>The time at which the block was issued. It is a Unix timestamp in nanoseconds.</td>
  </tr>
<tr>
  <td>Burned Credits</td>
    <td>uint64</td>
    <td>The amount of Block Issuance Credits the Account identified by <code>Account ID</code> is at most willing to burn for this block. The congestion control shall only burn credits for the block according to its size and the current RMC value which may be lower than the value of this field.</td>
</tr>
  <tr>
    <td>Slot Commitment</td>
    <td colspan="2">
      <details open="open">
        <summary>Slot Commitment</summary>
        <blockquote>
          A Slot Commitment contains a summary of a slot. More details in the <a href="#slot-commitment">Slot Commitment section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
  <tr>
    <td>Latest Finalized Slot</td>
    <td>uint64</td>
    <td>The slot index of the latest finalized slot.</td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td>Payload <code>optOneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Tagged Data Payload</summary>
        <blockquote>
          With Payload Type 5, more details are described in Tagged Data Payload section.
        </blockquote>
      </details>
      <details>
        <summary>Transaction Payload</summary>
        <blockquote>
          With Payload Type 6, more details are described in Transaction section.
        </blockquote>
      </details>
  </tr>
  <tr>
    <td>Signature <code>oneOf</code></td>
    <td colspan="2">
      <details>
        <summary>Ed25519 Signature</summary>
        <blockquote>
          An Ed25519 Signature. More details in the <a href="#slot-commitment">Signature section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
</table>

### Syntactic validation

The Tangle can only contain syntactically valid blocks. Invalid blocks must be rejected by the node.
The following criteria defines whether the block passes the syntactic validation:

- The total length of the serialized block must not exceed `Max Block Length`.
- `Type` must comply with the allowed block types for the `Protocol Version` config parameter of the node.
  - It must hold true that 1 ≤ `Strong Parents Count` ≤ 8.
  - It must hold true that 0 ≤ `Weak Parents Count` ≤ 8.
  - It must hold true that 0 ≤ `Shallow Like Parents Count` ≤ 8.
- `Strong Parents`, `Weak Parents`, `Shallow Like Parents` must comply with the following rules:
  - must be lexically ordered.
  - must not have duplicates in each list.
- `Weak Parents` must be disjoint to the rest of the parents, no weak parent should be in either strong or shallow like parents.
- Each `Block ID` must be unique.
- Payload (if present):
  - `Payload Type` must match one of the values described under [Payloads](#payloads).
  - `Data Fields` must be correctly parsable in the context of the `Payload Type`.
  - The payload itself must pass syntactic validation.
  - If the `Payload Type` is a `Transaction` and contains an `Account Unlock`, the slot index corresponding to the `Issuing Time` of the block must be equal to the slot of the transaction.
    - TODO: Doesn't deal with Expiration UCs present in inputs, as that requires a much deeper inspection of the TX which may not be feasible since the inputs aren't included in full in the TX so those inputs would have to be loaded from storage? Options: (1) Get rid of Expiration UC, (2) always require block slot == tx slot, (3) be fine with loading inputs from storage during block validation.
- There must be no trailing bytes after all block fields have been parsed.

### Semantic Validation

- The `Signature` must pass semantic validation.

### Payloads

While blocks without a payload, i.e. `Payload Length` set to zero, are valid, such blocks do not contain any information. As such, blocks usually contain a payload. The detailed specification of each payload type is out of scope of this TIP. The following table lists all currently specified payloads that can be part of a block and links to their specification:

| Payload Name | Type Value | TIP                               |
|--------------|------------|-----------------------------------|
| No Payload   | -          | -                                 |
| Tagged Data  | 5          | [TIP-23](../TIP-0023/tip-0023.md) |
| Transaction  | 6          | [TIP-20](../TIP-0020/tip-0020.md) |

### Example

TODO: update example

Below is the full serialization of a valid block with a _Tagged Data Payload_. The tag is the "IOTA" ASCII string and the data is the "hello world" ASCII string. Bytes are expressed as hexadecimal numbers.

- Protocol Version (1-byte): `02` (2)
- Parents Count (1-byte): `02` (2)
- Parents (64-byte):
  - `210fc7bb818639ac48a4c6afa2f1581a8b9525e20fda68927f2b2ff836f73578`
  - `db0fa54c29f7fd928d92ca43f193dee47f591549f597a811c8fa67ab031ebd9c`
- Payload Length (4-byte): `18000000` (24)
- Payload (24-byte):
  - Payload Type (4-byte): `05000000` (5)
  - Tag (5-byte):
    - Length (1-byte): `04` (4)
    - Tag (4-byte): `494f5441` ("IOTA")
  - Data (15-byte):
    - Length (4-byte): `0b000000` (11)
    - Data (11-byte): `68656c6c6f20776f726c64` ("hello world")
- Nonce (8-byte): `ce6d000000000000` (28110)

## Validation Block

A Validation Block is a special type of block used by validators to secure the network. It is recognised by the Congestion Control of the IOTA 2.0 protocol and can be issued without burning block issuance credits within the constraints of the allowed validator throughput. It is allowed to reference more parent blocks than a normal _Block_. _Validation Block_ uses the introduced [Block ID](#block-id) as its identifier.

## Serialized Layout

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
 <tr>
    <td>Type</td>
    <td>uint8</td>
    <td>This field denotes the type of the block, used to decide which rules apply to the block. Set to <strong>value 1</strong> to denote a <i>Validation Block</i>.</td>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Strong Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are strongly directly approved.</td>
  </tr>
  <tr>
    <td>Strong Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the strong parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Weak Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are weakly directly approved.</td>
  </tr>
  <tr>
    <td>Weak Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved block.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
  <tr>
    <td>Shallow Like Parents Count</td>
    <td>uint8</td>
    <td>The number of blocks that are directly referenced to adjust opinion.</td>
  </tr>
  <tr>
    <td>Shallow Like Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Block ID</td>
            <td>ByteArray[40]</td>
            <td>The Block ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
<tr>
    <td>Account ID</td>
    <td>ByteArray[32]</td>
    <td>The identifier of the account that issued this block.</td>
  </tr>
  <tr>
    <td>Issuing Time</td>
    <td>uint64</td>
    <td>The time at which the block was issued. It is a Unix timestamp in nanoseconds.</td>
  </tr>
  <tr>
<td>Slot Commitment</td>
    <td colspan="2">
      <details open="open">
        <summary>Slot Commitment</summary>
        <blockquote>
          A Slot Commitment contains a summary of a slot. More details in the <a href="#slot-commitment">Slot Commitment section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
  <tr>
    <td>Latest Finalized Slot</td>
    <td>uint64</td>
    <td>The slot index of the latest finalized slot.</td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td>Payload <code>optOneOf</code></td>
    <td colspan="2">
      <details>
        <summary>None</summary>
      </details>
  </tr>
  <tr>
    <td>Signature <code>oneOf</code></td>
    <td colspan="2">
          <details>
        <summary>Ed25519 Signature</summary>
        <blockquote>
          An Ed25519 Signature. More details in the <a href="#slot-commitment">Signature section</a>.
        </blockquote>
      </details>
    </td>
  </tr>
</table>

### Syntactic validation

The Tangle can only contain syntactically valid blocks. Invalid blocks must be rejected by the node.
The following criteria defines whether the block passes the syntactic validation:

- The total length of the serialized block must not exceed `Max Block Length`.
- `Type` must comply with the allowed block types for the `Protocol Version` config parameter of the node. TODO: How many parents can a validation block reference?
  - It must hold true that 1 ≤ `Strong Parents Count` ≤ XYZ.
  - It must hold true that 0 ≤ `Weak Parents Count` ≤ XYZ.
  - It must hold true that 0 ≤ `Shallow Like Parents Count` ≤ XYZ.
- `Strong Parents`, `Weak Parents`, `Shallow Like Parents` must comply with the following rules:
  - must be lexically ordered.
  - must not have duplicates in each list.
- `Weak Parents` must be disjoint to the rest of the parents, no weak parent should be in either strong or shallow like parents.
- Each `Block ID` must be unique.
- `Payload Length` must be 0 and the `Payload` must not be present.
- There must be no trailing bytes after all block fields have been parsed.

### Semantic Validation

- The `Signature` must pass semantic validation.

# Rationale and alternatives

The alternative could be to use a `Block` instead of `Validation Block` with some additional validation logic. However, having a separate block type for validator related responsibilites is much cleaner and allows for additional changes like allowing to reference more parents, or having specific payload types or fields in the future.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
