---
tip: 40
title: Staking & Delegation
description: Staking, Delegation and Mana Rewards
author:
  Philipp Gackstatter (@PhilippGackstatter) <philipp.gackstatter@iota.org>, Olivia Saa (@oliviasaa)
  <olivia.saa@iota.org>, Daria Dziuba≈Çtowska (@daria305) <daria.dziubaltowska@iota.org>
discussions-to: TODO
status: Draft
type: Standards
layer: Core
created: 2023-05-03
requires: TIP-19, TIP-20, TIP-21 and TIP-22
---

# Summary

Staking and delegation are mechanisms by which users contribute to the network's security and for which they are
rewarded. Stakers lock IOTA coins to become eligible to be selected for the validator committee and consequently give
weight to blocks and transactions. On the other hand, delegators delegate IOTA coins (which does not imply locking these
tokens) to a validator, forming a validator pool. The weight that validators give to blocks is derived from the total
stake of the pool (i.e., from the locked tokens of the staker and the delegated tokens of all its delegators) and the
total combined stake among pools. If the validator of a pool performs its task well, the pool is rewarded with Mana.
Each participant in the pool can claim rewards roughly proportional to the amount of staked or delegated tokens. This
results in a mechanism that incentivizes users to contribute to the security and well-functioning of the network while
receiving rewards for their contribution. Note that the size of the committee is bounded, so not all pools might get
rewards for a given epoch.

This TIP specifies the details of staking, delegation, committee selection, and Mana rewards.

# Motivation

In IOTA 1.5, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions they should
consider confirmed. The Coordinator was always intended as a temporary solution; thus, it is removed with the upgrade to
IOTA 2.0 (a.k.a. Coordicide). In IOTA 2.0, the Coordinator is replaced by a weight-based voting scheme to resolve
conflicts and finalize transactions. Each of those votes must have a weight associated with it, which depends on the
identity that cast the vote. Determining the weight of an identity is closely related to the type of Sybil protection
mechanism used.

IOTA 2.0 uses Proof-of-Stake as the Sybil protection mechanism. Proof-of-Stake assigns to every participant a weight
proportional to the number of tokens they hold. Since tokens are a scarce resource, they can be used as a base for a
Sybil protection mechanism, being much more efficient than relying on scarce resources external to the system, such as
hardware or electricity, as in Proof-of-Work-based systems.

The IOTA 2.0 consensus protocol is founded upon the principle of seat-based committees, determined through staking and
committee-selection mechanisms. At any given point in time, the validator committee is composed of a limited number of
seats, with each seat exclusively assigned to a single validator. The rules governing acceptance, confirmation, and
finalization are contingent on the number of seats that have endorsed (cast their votes in favor of) a block
(transaction). This voting mechanism inherently enables decentralization, as a single entity can, at most, occupy one
seat within the committee and, thus, have a restricted level of influence in the voting process, proportional to the
staked and delegated tokens.

Using Proof-of-Stake in IOTA 2.0 results in a system with low financial barriers to entry. The technical requirements
for participation are also low and allow everyone to contribute to the network's security. Those who cannot or do not
want to vote (i.e., stake) can delegate stake instead while still adding to the network's security. Proof-of-Stake is,
moreover, energy efficient and environmentally friendly.

In line with IOTA's goal for _Digital Autonomy_, these properties make Proof-of-Stake a good choice.

# Building Blocks

## Data Types & Subschema Notation

Data types and subschemas used throughout this TIP are defined in [TIP-21](../TIP-0021/tip-0021.md).

## Protocol Parameters

Protocol parameters used throughout this TIP are defined in [TIP-49](../TIP-0049/tip-0049.md).

## Transaction Payload

[TIP-45](../TIP-0045/tip-0045.md) is the basis for output validation in this TIP.

## Common Parameters and Functions

- Let `decay(value, n)` be calculated with the algorithm and lookup table in [TIP-39](../TIP-0039/tip-0039.md).

# Staking

The IOTA protocol accepts blocks and transactions after they reach a certain weight through voting. The voters are a
selected validator committee. The following gives a high-level idea of the selection process, while the rest of the
section specifies its normative details.

Stakers, or interchangeably called _registered validators_, must lock their IOTA coins to stake them. By locking the
tokens, the stakers prove control over them, so the protocol assigns them a proportional amount of _stake_ in exchange.
Other users - the so-called delegators - can _delegate_ their IOTA coins to a staker to further increase their influence
in the system. A staker plus all its delegators are called a _staking or validator pool_. Stakers are eligible to be
selected into a committee for a certain duration. Only the votes of those selected into the committee are considered to
determine the _Witness Weight_, used for the acceptance of blocks, and _Approval Weight_, used for conflict resolution
and transaction acceptance. Stake is only used to determine who is selected for the committee. Once selected, every
validator in the committee occupies a seat, and every seat has the same voting weight.

The IOTA protocol slices time into slots and epochs. An epoch is simply a specified number of slots, and a slot has a
protocol-defined duration in seconds. A new validator committee is selected for each epoch. Shortly before an epoch
ends, the current activity of all registered validators, as well as the pools' stakes, are determined. Then, a committee
is selected out of all the registered stakers with enough block issuance activity, depending on their pool stake. Once
selected, each validator is responsible for issuing _Validation Blocks_ across the epoch through which they vote on
conflicts. A performance factor is calculated based on how many such blocks they issued for each slot and how many they
were expected to issue. This factor determines the amount of _Mana rewards_ the validator's pool receives.

After an epoch ends, the delegators of the pool can claim their rewards. The validator may continue to stake or end its
stake by going through an unbonding period of its locked tokens. After this period ends, the validator can unlock their
IOTA coins and claim their Mana rewards.

## Registration

Accounts are considered registered for validation if they have a _Staking Feature_ in their _Features_. This feature and
its transaction validation rules are specified in [TIP-42](../TIP-0042/tip-0042.md).

## Committee Selection

![](./assets/selection-timing.png)

_This figure gives an overview of the timing around committee selection in epochs. Note that the exact length of those
windows is not accurately depicted here and instead depends on the value of the corresponding Protocol Parameters._

The following explains how the committee selection for a certain epoch `n` works, with the following time boundaries
used in the algorithm:

- Let `Epoch Start Slot(n))` be the first slot index of epoch `n`.
- Let `Registration Slot(n)` be the registration slot with index
  `Epoch Start Slot(n) - Epoch Nearing Threshold - Activity Window Duration - 1`. To be eligible for the committee
  selection of epoch `n`, a potential validator must register until this slot.
- Let `Activity Window Slot(n)` be the slot of `Epoch Start Slot(n) - Epoch Nearing Threshold - 1`. To be eligible for
  the committee selection of epoch `n`, a potential validator must issue at least one block between
  `Registration Slot(n)`+1. and this slot.
- Let `Cutoff Slot(n)` be the slot with index `Epoch Start Slot(n) - Maximum Committable Age - 1`. This slot is used in
  checks to decide whether the committee will be rotated or not in the epoch.

The committee will be a subset of the active _registered validators_. To define this subset, the following steps are
taken:

- The set of _registered validators_ is defined as all Account Outputs that satisfy all of the following conditions:
  - The account has a _Staking Feature_ at the end of the `Registration Slot(n)`.
  - The account's Staking Feature's `End Epoch` is greater or equal to `n`.
- For any validator `i` in the set of _registered validators_ the activity is determined. The validator is active if the
  following condition holds; otherwise, it is inactive:
  - The account with `Account ID` issues at least one block whose `Account ID` field is equal to that of the account,
    and the block's `Issuing Time` field converted to a slot index `Block Slot Index`, satisfies all of the following
    conditions:
    - `Block Slot Index > Registration Slot(n)`.
    - `Block Slot Index <= Activity Window Slot(n)`.
- For any validator `i` in the set of _registered validators_ the pool stake is equal to `Stake_i + DelegatedStake_i` at
  the end of the slot with index `Registration Slot(n)`, where:
  - `Stake_i` is the `Staked Amount` of IOTA coins of the validator's _Staking Feature_.
  - `DelegatedStake_i` is the sum of all _Delegation Output's_ `Amount` field where the value of the `Validator ID`
    field is equal to `i`.
- The set of _registered validators_ who are active constitute the set of _eligible validators_, which is sorted by pool
  stake in descending order. The first `Committee Size` entries in the _eligible validators_ set is Epoch `n`'s
  preliminary committee.
- The preliminary committee becomes the selected committee if the `Activity Window Slot(n)` is finalized before the
  `Cutoff Slot(n)` is committed; otherwise, the committee of the current epoch becomes the selected committee of the
  next epoch.

### Committee Tasks

The selected members of the committee are expected to issue _Validation Blocks_, defined in
[TIP-46](../TIP-0046/tip-0046.md). Only the votes of those selected into the committee are considered to determine the
Witness Weight, used for the acceptance of blocks, and Approval Weight, used for conflict resolution and transaction
acceptance. The [performance](#performance-factor) of a validator is determined by the issued Validation Blocks, and
affects the validator pool's Mana rewards.

# Delegation

By delegating IOTA coins, a user increases a validator's stake proportionally to the number of tokens they delegate
without becoming a validator themselves. To delegate, a _Delegation Output_ must be created. The following section
specifies how delegation is implemented.

## Delegation Output

Delegation is implemented with a special output type, the so-called Delegation Output.

Upon the creation of a Delegation Output, the protocol assigns to it a unique identifier called `Delegation ID`. The
`Delegation ID` is the BLAKE2b-256 hash of the `Output ID` that created the Delegation Output.

<details>
  <summary>Delegation Output</summary>
  <blockquote>Describes a Delegation Output, which delegates its contained IOTA coins to a validator.</blockquote>
</details>
<table>
  <tr>
    <td>
      <b>Name</b>
    </td>
    <td>
      <b>Type</b>
    </td>
    <td>
      <b>Description</b>
    </td>
  </tr>
  <tr>
    <td>Output Type</td>
    <td>uint8</td>
    <td>Set to <strong>value 5</strong> to denote a <i>Delegation Output</i>.</td>
  </tr>
  <tr>
    <td>Amount</td>
    <td>uint64</td>
    <td>The amount of IOTA coins held by the output.</td>
  </tr>
  <tr>
    <td>Delegated Amount</td>
    <td>uint64</td>
    <td>The amount of delegated IOTA coins.</td>
  </tr>
  <tr>
    <td>Delegation ID</td>
    <td>ByteArray[32]</td>
    <td>Unique identifier of the Delegation Output, which is the BLAKE2b-256 hash of the <i>Output ID</i> that created it.</td>
  </tr>
  <tr>
    <td>Validator Address</td>
    <td>ByteArray[32]</td>
    <td>The <i>Account Address</i> of the validator to which this output is delegating.</td>
  </tr>
  <tr>
    <td>Start Epoch</td>
    <td>uint64</td>
    <td>The index of the first epoch for which this output delegates.</td>
  </tr>
  <tr>
    <td>End Epoch</td>
    <td>uint64</td>
    <td>The index of the last epoch for which this output delegates.</td>
  </tr>
  <tr>
    <td>Unlock Conditions Count</td>
    <td>uint8</td>
    <td>The number of unlock conditions following.</td>
  </tr>
  <tr>
    <td valign="top">Unlock Conditions <code>atMostOneOfEach</code></td>
    <td colspan="2">
      <details>
        <summary>Address Unlock Condition</summary>
        <blockquote>Defines the Address that owns this output. It can unlock the output with the proper <i>Unlock</i> in a transaction. Defined in <a href='../TIP-0038/tip-0038.md#address-unlock-condition'>TIP-38 (Address Unlock Condition)</a>.</blockquote>
        <table>
          <tr>
            <td>
              <b>Name</b>
            </td>
            <td>
              <b>Type</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr>
            <td>Unlock Condition Type</td>
            <td>uint8</td>
            <td>Set to <strong>value 0</strong> to denote an <i>Address Unlock Condition</i>.</td>
          </tr>
          <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Address</summary>
                <blockquote>An Address derived from an Ed25519 Public Key. Defined in <a href='../TIP-0038/tip-0038.md#ed25519-address'>TIP-38 (Ed25519 Address)</a>.</blockquote>
              </details>
              <details>
                <summary>Account Address</summary>
                <blockquote>An Address derived from an Account ID which can be unlocked by unlocking the corresponding Account. Defined in <a href='../TIP-0038/tip-0038.md#account-address'>TIP-38 (Account Address)</a>.</blockquote>
              </details>
              <details>
                <summary>NFT Address</summary>
                <blockquote>An Address derived from an NFT ID which can be unlocked by unlocking the corresponding NFT. Defined in <a href='../TIP-0038/tip-0038.md#nft-address'>TIP-38 (NFT Address)</a>.</blockquote>
              </details>
              <details>
                <summary>Anchor Address</summary>
                <blockquote>An Address derived from an Anchor ID which can be unlocked by unlocking the corresponding Anchor. Defined in <a href='../TIP-0038/tip-0038.md#anchor-address'>TIP-38 (Anchor Address)</a>.</blockquote>
              </details>
              <details>
                <summary>Multi Address</summary>
                <blockquote>Defines a Multi Address that consists of addresses with weights and a threshold value. The Multi Address can be unlocked if the cumulative weight of all unlocked addresses is equal to or exceeds the threshold. Defined in <a href='../TIP-0052/tip-0052.md#multi-address'>TIP-52 (Multi Address)</a>.</blockquote>
              </details>
              <details>
                <summary>Restricted Address</summary>
                <blockquote>An address that contains another address and allows for configuring its capabilities. Defined in <a href='../TIP-0050/tip-0050.md#restricted-address'>TIP-50 (Restricted Address)</a>.</blockquote>
              </details>
            </td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>

### Additional Transaction Syntactic Validation Rules

#### Output Syntactic Validation

- `Amount` field must fulfill the [storage deposit requirements](../TIP-0047/tip-0047.md) and must not be `0`.
- `Amount` field must be ‚â§ `Token Supply`.
- It must hold true that `1` ‚â§ `Unlock Conditions Count` ‚â§ `1`.
- `Unlock Condition Type` of an <i>Unlock Condition</i> must define one of the following types:
  - <i>Address Unlock Condition</i>
- <i>Unlock Conditions</i> must be sorted in ascending order based on their `Unlock Condition Type`.
- Syntactic validation of all present unlock conditions must pass.
- <i>Address Unlock Condition</i> must be present.
- `Validator ID` must not be zeroed out.

### Additional Transaction Semantic Validation Rules

- Explicit `Delegation ID`: `Delegation ID` is taken as the value of the `Delegation ID` field in the Delegation output.
- Implicit `Delegation ID`: When a Delegation output is consumed as an input in a transaction and `Delegation ID` field
  is zeroed out, take the BLAKE2b-256 hash of the `Output ID` of the input as `Delegation ID`.
- For every non-zero explicit `Delegation ID` on the output side there must be a corresponding Delegation Output on the
  input side. The corresponding Delegation output has the explicit or implicit `Delegation ID` equal to that of the
  Delegation output on the output side.
- Let `Past Bounded Slot Index` be given by `Commitment Index + Max Committable Age` where `Commitment Index` is the
  slot index of the commitment input.
- Let `Past Bounded Epoch Index` be the epoch index corresponding to the slot index `Past Bounded Slot Index`.
- Let `Future Bounded Slot Index` be given by `Commitment Index + Min Committable Age` where `Commitment Index` is the
  slot index of the commitment input.
- Let `Future Bounded Epoch Index` be the epoch index corresponding to the slot index `Future Bounded Slot Index`.
- If the past bounded indices are required for transaction validation, a _Commitment Input_ must be present. This is the
  case for any transaction containing a _Delegation Output_ on the input or output side except when it is destroyed in
  _Delayed Claiming State_.

#### Consumed Outputs

Whenever a Delegation output is consumed in a transaction, it means that the output is transitioned into its next state.
From its initial state, the _Delegating State_, a Delegation Output can either be destroyed or transitioned to a
_Delayed Claiming_ state, from which it can then be destroyed. The current state is defined as the consumed Delegation
output, while the next state is defined as the Delegation output with the same explicit `Delegation ID` on the output
side. There are thus two types of transitions: delayed claiming transition and destruction transition.

- Delayed Claiming Transition
  - Is identified by a zeroed-out `Delegation ID` on the input side and a non-zeroed-out `Delegation ID` on the output
    side.
  - The fields `Delegated Amount`, `Start Epoch` and `Validator ID` must not be changed.
  - `End Epoch` on the output must be set as follows.
    - Let `Registration Slot(n)` be defined as in [committee selection](#committee-selection), where `n` is equal to
      `Future Bounded Epoch Index`.
    - If `Future Bounded Slot Index <= Registration Slot(n+1)` then `End Epoch` must be set to
      `Future Bounded Epoch Index`, otherwise to `Future Bounded Epoch Index + 1`.
- Destruction Transition
  - Is identified by the absence of a Delegation Output on the output side with an explicit `Delegation ID` that
    corresponds to the `Delegation ID` of the one on the input side, which may be an implicit or explicit Delegation ID.
    The next state is the empty state.
  - During this transition, Mana rewards may be added to the total sum of Mana on the output side of the transaction,
    according to [delegation rewards](#delegation-rewards).

#### Created Outputs

- When `Delegation ID` is zeroed out certain fields of the Delegation Output must be set as follows.
  - Let `Registration Slot(n)` be defined as in [committee selection](#committee-selection), where `n` is equal to
    `Past Bounded Epoch Index`.
  - If `Past Bounded Slot Index <= Registration Slot(n+1)` then `Start Epoch` must be set to
    `Past Bounded Epoch Index + 1`, otherwise to `Past Bounded Epoch Index + 2`.
  - Set `Delegated Amount` to the value of the `Amount` field.
  - Set `End Epoch` to `0`.

### Storage Score

A Delegation Output incurs additional computational cost in order to compute the total stake of a validator. Due to
this, such an output has an additional storage score offset, the `Rent Parameters::Storage Score Offset Delegation` as
defined in [TIP-49](../TIP-0049/tip-0049.md).

# Mana Rewards

Mana Rewards are claimed and tracked for past epochs on an epoch level. For an ongoing epoch, they are tracked on a slot
level and are then combined into an epoch rewards entry when the epoch ends. Rewards for an epoch become claimable when
the epoch ends, that is, when its last slot is committed.

## Slot Level

For each slot, the performance factor of each validator in the selected committee must be tracked. For an epoch, this
results in a list of performance factors for a validator. The rewards for an ongoing epoch are tracked by keeping a map
with `Validator ID`s as keys, of type `ByteArray[32]`, and the values being a list of objects consisting of these
fields:

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Slot Index</td>
        <td><code>uint64</code></td>
        <td>The slot index for which the performance factor is tracked.</td>
    </tr>
    <tr>
        <td>Performance Factor</td>
        <td><code>uint8</code></td>
        <td>The slot performance factor of the validator, scaled to TargetValidationBlocks.</td>
    </tr>
</table>

### Performance Factor

This performance factor for a slot is defined as follows.

#### Input values

- Let `Validation Blocks Issued` be the array of _Validation Blocks_ issued by a given validator in a certain slot.
- Let `TargetValidationBlocks` be a protocol parameter representing the number of validation blocks a validator is
  supposed to issue per slot. Note that, when using an `uint8` to store `Performance Factor`, `TargetValidationBlocks`
  must be strictly smaller than `2^8`, otherwise the performance of a well behaved validator would overflow the
  variable.

#### Calculations

- First, divide the slot representing times `[beginningSlot, endSlot)` into `TargetValidationBlocks` subslots of length
  `subslotLenght = slotDuration/TargetValidationBlocks` given by
  `[beginningSlot+(i-1)*subslotLenght, beginningSlot+i*subslotLenght)`, for `i=1,...,TargetValidationBlocks`.
- Then, count how many of these subslots have at least one validation block issued in them. In principle, this will be
  the `Slot Performance Factor`.
- Check if the total number of validation blocks issued in this slot is larger than `TargetValidationBlocks`. In the
  case that `TargetValidationBlocks` is strictly smaller than `2^8-1`, one could set `Slot Performance Factor` to
  `TargetValidationBlocks + 1`, to signal that the validator issued more validation blocks than it was supposed to and
  it should be punished when combining the `Slot Performance Factors` into `Epoch Performance Factors`. In the case that
  `TargetValidationBlocks` is larger or equal than `2^8-1`, this "trick" can overflow the variables used.

## Epoch Level

### Epoch performance factor

#### Input values

- Let `Slot Performance Factor Array` be the array of _Slot Performance Factors_ of a given validator in each slot on an
  epoch.

#### Calculations

- Then `Performance Factor` is given by the average between these values, rounded down to the nearest integer.
  Additionally, if the validator issued more than `TargetValidationBlocks` validation blocks in any slot, the
  performance factor for the whole epoch is set to 0 as a form of punishment.

Note that the value of the `Performance Factor` will be an integer between 0 and `TargetValidationBlocks`.

### Profit Margins

#### Input values

- Let `Total Stake` be the sum of all `Pool Stake` values, that is, the total amount of delegated and staked IOTA coins
  in the selected committee.
- Let `Total Validator Stake` be the sum of `Validator Stake(i)` for each validator `i` in the selected committee.

#### Parameters

- Let `ProfitMarginExponent` be 8.

#### Calculations

- Given the values defined above, then
  `Profit Margin = (Total Validator Stake<<ProfitMarginExponent)/(Total Validator Stake + Total Stake)`. Note that this
  will be an integer strictly smaller than `2^ProfitMarginExponent`, so `Profit Margin` can be set to use
  `ProfitMarginExponent` bits.

Additionally, the profit margins must be tracked for each epoch.

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Epoch Index</td>
        <td>uint64</td>
        <td>
            The epoch index for which the profit margin is tracked.
        </td>
    </tr>
    <tr>
        <td>Profit Margin</td>
        <td>uint8</td>
        <td>
            An integer representing the epoch profit margin, scaled to `2^ProfitMarginExponent`.
        </td>
    </tr>
</table>

### Epoch Rewards

The rewards of an epoch are tracked by keeping a map with `Validator ID`s as keys, of type `ByteArray[32]`, and the
values being a list of objects consisting of these fields:

<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Epoch Index</td>
        <td><code>uint64</code></td>
        <td>The epoch index for which the rewards can be claimed.</td>
    </tr>
    <tr>
        <td>Pool Stake</td>
        <td><code>uint64</code></td>
        <td>The total amount of IOTA coins staked by the validator and all its delegators.</td>
    </tr>
    <tr>
        <td>Pool Rewards</td>
        <td><code>uint64</code></td>
        <td>The total amount of rewards the validator pool received.</td>
    </tr>
</table>

The next section defines how these values can be obtained from the slot-level data, after the commitment of the last
slot of that epoch.

### Slot-Epoch Conversion of the Rewards

The following section specifies how to convert the slot-level data into epoch-level data.

#### Parameters needed for calculations:

- `Bootstrapping Duration` = 1154 (approximately 3 years)
- `Rewards Mana Share Coefficient` = 2 (relative to the term $\theta/(1-\theta)$ from the Whitepaper, with
  $\theta = 2/3$)
- `Final Reward` =
  `(Total Supply * Rewards Mana Share Coefficient * generationRate) >> (generationRateExponent - slotsPerEpochExponent) `
  (constant reward per epoch after the bootstrapping phase)
- `Decay Balancing Constant Coefficient` = 8
- `Decay Balancing Constant = ` (integer approximation of
  $2^{\text{Decay Balancing Constant Coefficient}}\frac{e \Delta}{T(1-\exp{(-\beta \Delta)})}$, for $Delta =$ epoch
  duration in years, $T=$ `Bootstrapping Duration`, and $\beta=1/3$). For `Decay Balancing Constant Coefficient` = 8,
  `Decay Balancing Constant` = 696.
- `Initial Reward` = `(Final Reward * Decay Balancing Constant) >> Decay Balancing Constant Coefficient` (parameter to
  calculate the reward per epoch in the bootstrapping phase)
- `Pool Coefficient Exponent` = 11

#### Input values

- Let `Validator Stake(i)` be the amount of IOTA coins staked by the validator with Account ID `i`, i.e. the
  `Staked Amount` in the _Staking Feature_ of the validator at the end of the registration slot.
- Let `Pool Stake` be the total amount of delegated and staked IOTA coins by the validator pool which was determined at
  the time of the pool stake calculation, i.e. the end of the registration slot.
- Let `Total Stake` be the sum of all `Pool Stake` values, that is, the total amount of delegated and staked IOTA coins
  in the selected committee.
- Let `Total Validator Stake` be the sum of `Validator Stake(i)` for each validator `i` in the selected committee.

#### Calculations

- The total target reward `Target Reward(n)` for an epoch index `n` is defined as:
  - `Initial Reward * decay(n)` if `n <= Bootstrapping Duration`.
  - `Final Reward` if `n > Bootstrapping Duration`.
- The Pool Reward `Pool Reward` for an epoch index `n`, and pool `i` is calculated as follows:
  - Let `Pool Coefficient` be
    `((Pool Stake << Pool Coefficient Exponent)/Total Stake) + (Validator Stake(i) << Pool Coefficient Exponent) / Total Validator Stake`.
    Notice that, since both `Pool Stake` and `Validator Stake(i)` use at most 53 bits of the variable, to not overflow
    the calculation, `Pool Coefficient Exponent` must be at most 11. `Pool Coefficient` will then use at most
    `Pool Coefficient Exponent + 1` bits.
  - Take the `Performance Factor` for the whole epoch `n` according to [Performance Factor](#performance-factor)
  - Let `Scaled Pool Reward` be `Pool Coefficient * Target Reward(n) * Performance Factor`. Since `Pool Coefficient`
    uses at most 12 bits, `Target Reward(n)` uses at most 41 bits, and `Performance Factor` uses at most 8 bits, this
    multiplication will not overflow using uint64 variables.
  - Finally, `Pool Reward` will be `((Scaled Pool Reward/TargetValidationBlocks) >> (Pool Coefficient Exponent+1))`.
    Note that if this value is smaller than `Fixed Cost`, the validator will not receive rewards from this epoch. This
    is done to incentivize validators to define reasonable values for their fixed cost.

## Validator Rewards

An account with a _Staking Feature_ can claim rewards in the same transaction where the feature is removed. The
transaction validation rules for removing the feature are defined in [TIP-42](../TIP-0042/tip-0042.md). Upon removal,
the amount of Mana Rewards that can be claimed is defined as follows.

#### Parameters

`ProfitMarginExponent` = 8

#### Input Values

- Let `Profit Margin(n)` be the `Profit Margin` for epoch index `n`.
- Let `Pool Rewards(n)` be the `Pool Rewards` of the entry in `Claimable Rewards` with epoch index `n`.
- Let `Pool Stake(n)` be the `Pool Stake` of the entry in `Claimable Rewards` with epoch index `n`.
- Let `Fixed Cost` be the `Fixed Cost` defined in the _Staking Feature_.

#### Calculations

- Let `Future Bounded Epoch Index` be given by `Commitment Index + Min Committable Age` where `Commitment Index` is the
  slot index of the _Commitment Input_. If no _Commitment Input_ is present, the transaction is invalid.
  - Note that the presence of a _Commitment Input_ is already required for any transaction containing a _Staking
    Feature_ on the input or output side.
- Let the `Claimable Rewards` be all reward entries for the validator identified by the Account ID of the account that
  removes the Staking Feature, where the entry's `Epoch Index` satisfies `Epoch Index >= Start Epoch + 1` and
  `Epoch Index < Future Bounded Epoch Index`.
- Let the total claimable rewards at epoch `m` be the sum of `Rewards(n)` for a certain set of epoch indexes `n<m`.
  Calculate the `Undecayed Rewards(n)` for each epoch `n` in the validation period. If `Pool Rewards(n)-Fixed Cost‚â•0`,
  it will be given by:
  - `Undecayed Rewards(n)` = `Fixed Cost + Profit Margin Factor + Residual Validator Factor` where -
    `Profit Margin Complement = (1 << ProfitMarginExponent) - Profit Margin(n) ` -
    `Profit Margin Factor = (Profit Margin(n) * (Pool Rewards(n)-Fixed Cost)) >> ProfitMarginExponent` -
    `Residual Validator Factor = ((Profit Margin Complement * (Pool Rewards(n)-Fixed Cost)) >> ProfitMarginExponent) * Staked Amount/Pool Stake(n)`.
    Note that `((Profit Margin Complement * Pool Rewards(n)) >> ProfitMarginExponent) * Staked Amount` uses up to 94
    bits and `Pool Stake(n)` up to 53, so to prevent overflowing the first factor should be either stored as a 128 bits
    integer or it should be stored as 2 uint64 variables (and the proper 128 by 64 division algorithm must be used).
    Otherwise (i.e., if `Pool Rewards(n)-Fixed Cost<0`), `Undecayed Rewards(n)` must be set to zero.
- Finally, decay the rewards according to [Mana Decay](../TIP-0039/tip-0039.md#mana-decay), meaning that
  `Rewards(n)=decay(Undecayed Rewards(n),m-n)`, where the function `decay` is defined in
  [TIP-39](../TIP-0039/tip-0039.md). The total claimable decayed reward for validator `i` will be, then, the sum of
  `Rewards(n)` for n in the validation period.

## Delegation Rewards

To claim rewards, a _Delegation Output_ must be destroyed. Depending on the state it is in at that point, different
conditions for claiming rewards apply. An output destroyed in _Delegating State_ will always forfeit _potential_ rewards
for the epoch in which it is destroyed, since the rewards for that epoch only become available in the next epoch. They
are _potential_ since the validator to which the output is delegating may not have been selected into the committee for
that epoch.

#### Parameters

`ProfitMarginExponent` = 8 and `DecayExponent` = 32

#### Input Values

- Let `Profit Margin(n)` be the `Profit Margin` for epoch index `n`.
- Let `Pool Rewards(n)` be the `Pool Rewards` of the entry in `Claimable Rewards` with epoch index `n`.
- Let `Pool Stake(n)` be the `Pool Stake` of the entry in `Claimable Rewards` with epoch index `n`.
- Let `Fixed Cost` be the `Fixed Cost` of the Validator, as defined in its Staking Feature.

#### Calculations

The amount of Mana Rewards that can be claimed for a _Delegation Output_ which is destroyed is defined as follows.

- Let the `Claimable Rewards` be all reward entries for the validator identified by the Account ID `Validator ID` field
  in the output, where its `Epoch Index` satisfies `Epoch Index >= Start Epoch` and `Epoch Index <= Delegation End`,
  where:
  - If the output is in _Delegating State_ let `Delegation End` be `Future Bounded Epoch Index - 1`, where:
    - `Future Bounded Epoch Index` is given by `Commitment Index + Min Committable Age` where `Commitment Index` is the
      slot index of the _Commitment Input_. If no _Commitment Input_ is present, the transaction is invalid.
      - Note that the presence of a _Commitment Input_ is already required for any transaction containing a _Delegation
        Output_ on the input or output side, except when it is destroyed in the _Delayed Claiming State_.
    - Note that no transaction validation rule exists to prevent claiming rewards before the rewards of the previous
      epoch became available, thus forfeiting the potential rewards of that previous epoch.
  - If the output is in _Delayed Claiming State_ let `Delegation End` be `End Epoch`.

Let the total claimable rewards be the sum of `Rewards(n)` for an epoch index `n`. Calculate the undecayed rewards for
each epoch `n` `Undecayed Rewards(n)`. In the case where `Pool Rewards(n)-Fixed Cost‚â•0`, the following holds:
`Undecayed Rewards(n)` =
`((Profit Margin Complement * (Pool Rewards(n)-Fixed Cost)) >> ProfitMarginExponent) * Delegated Amount/Pool Stake(n)`.
Note that `((Profit Margin Complement * (Pool Rewards(n)-Fixed Cost)) >> ProfitMarginExponent) * Delegated Amount` uses
up to 94 bits and `Pool Stake(n)` up to 53, so to prevent overflowing the first factor should be either stored as a 128
bits integer or it should be stored as 2 uint64 variables (and the proper 128 by 64 division algorithm must be used).
Otherwise (i.e., if `Pool Rewards(n)-Fixed Cost<0`), set the undecayed rewards as `Undecayed Rewards(n)` =
`((Profit Margin Complement * Pool Rewards(n)) >> ProfitMarginExponent) * Delegated Amount/Pool Stake(n)`. Then, decay
the rewards according to [Mana Decay](../TIP-0039/tip-0039.md#mana-decay), meaning that
`Rewards(n)=decay(Undecayed Rewards(n),m-n)`. The total claimable decayed reward for validator `i` will then be the sum
of `Rewards(n)` for n in the validation period.

# Rationale & Design

This section describes the rationale behind some of the design choices and explains how the introduced concepts fit
together. It is however not part of the formal specification and thus non-normative.

## Delegation Output

Using dedicated Delegation Outputs over a Delegation Feature in an Account has some advantages. First, it makes it
easily possible to delegate to multiple validators from the same account, by creating multiple outputs. In the Stardust
Design ([TIP-18](../TIP-0018/tip-0018.md)), Features are assumed to be unique in an output, and thus having multiple
Delegation Features to allow for multiple delegation targets would require changing that assumption. Second, it
decouples the delegation logic from the Account. Delegation, in contrast to staking, does not require that an account
must be the delegator. A Delegation Output can be owned by a plain Ed25519 address or an NFT or Account Address, making
it more flexible. A Delegation Feature would only allow for Delegation from an account.

### Delayed Claiming

Mana Rewards for some epoch `X` only become available after that epoch ends. At that point, the pool stake for the
following epoch `X+1` has already been calculated. That means, if one waits until the rewards for `X` are available and
consumes their Delegation Output to claim rewards, they have already delegated for `X+1` but will lose out on the
rewards they would get for that delegation.

With delayed claiming, however, a user can delegate for `X` and then transition to delayed claiming. At that point, the
output only needs to contain the minimum storage deposit. The remaining funds can be put in a new Delegation Output to
delegate for `X+1`, which can repeat this procedure. In this manner, one can delegate for one epoch at a time and never
lose out on any rewards. The following figure exemplifies this procedure.

![](./assets/delayed-claiming.png)

Delayed Claiming also allows for a high degree of liquidity while delegating. Even without delayed claiming, this
delegation mechanism implements _liquid delegation_ as Delegation Outputs are never locked and can be accessed anytime.
However, one might lose out on rewards. Delayed Claiming fixes this: If one delegated for the current epoch but needs to
access the funds immediately, one can transition to delayed claiming and access all the funds (minus the small storage
deposit), and still claim rewards later.

Additionally, Delayed Claiming enables Layer 2 Smart Contract Chains to hold their funds in Delegation Outputs and
delegate the tokens of their users for them, while they can use those wrapped tokens on Layer 2. Since an Account Output
belonging to an SC chain is transitioned very frequently, without Delayed Claiming, they would never hold the Delegation
Output long enough for it to be able to claim rewards. With Delayed Claiming SC chains can implement this kind of
delegation.

#### Start and End Epoch

This figure showcases how epochs are set when creating and transitioning Delegation Outputs. Note that the length of
epochs in slots is not accurately depicted here. What matters for epoch setting is 1) what the current epoch is and 2)
whether the creation or transition happens before or after the registration slot for the following epoch.

![](./assets/delegation-epochs.png)

- Delegation Output X is created before the end of the Registration Slot. Therefore its `Start Epoch` is set to `21`, as
  that is the earliest epoch for which it could receive rewards. However, it is also transitioned before the end of the
  slot, so its `End Epoch` is set to `20`, as that is the last epoch for which it could receive rewards. However, the
  condition for claiming rewards is not satisfied for any epoch index. There will be no epoch index `A` that satisfies
  `A >= 21 && A <= 20`. This Delegation Output will consequently not be able to claim any rewards at all, as it was
  never included in any pool stake calculation.
- Delegation Output Y is created before the end of the Registration Slot. Therefore its `Start Epoch` is set to `21`, as
  that is the earliest epoch for which it could receive rewards. It is transitioned after the end of the Registration
  Slot, so it was included in the pool stake calculation. Therefore the last epoch for which it could get rewards is
  `21`, which is the value of `End Epoch`. In sum, the delegation output will therefore be able to claim rewards for
  epoch `21` only.
- Delegation Output Z is analogous to X, only shifted by one epoch. It is created after the Registration Slot of Epoch
  21 but before the Registration Slot of Epoch 22. Therefore its `Start Epoch` is set to `22`, as that is the earliest
  epoch for which it could receive rewards. It is however transitioned before the Registration Slot of Epoch 22, so it
  will not be included in the pool stake calculation for said epoch. Its `End Epoch` is thus set to `21`, as that may be
  the last epoch for which it could get rewards. Similar to Output X, the delegation output will not be able to claim
  any rewards as it was never included in any pool stake calculation and no epoch index `A` satisfies
  `A >= 22 && A <= 21`.

These examples show that transitioning a Delegation Output without crossing a Registration Slot boundary does not yield
any rewards. At least one such boundary must be crossed for any rewards to be claimable.

### Time Boundaries

When designing transaction validation rules, a choice must be made between choosing to bound the past or the future,
that is, whether to prevent faking the past or faking the future. To maximize rewards, users are incentivized to make
the range of epochs for which they can claim rewards as large as possible. Thus, there's an incentive to set
`Start Epoch` as early or low as possible and `End Epoch` as high or late as possible. To prevent malicious behavior,
like setting `Start Epoch` to the current epoch when the block itself, that contained the transaction in which the
delegation started, was issued past the registration slot of the next epoch, the boundaries must be set appropriately.
Thus, `Start Epoch` must be set to or compared against the past-bounded slot index, which prevents faking the past. A
past-bounded slot index is always at least equal to the slot to which the block belongs, based on its `Issuing Time`,
since the oldest, valid commitment that can be picked is `Max Committable Age` slots old. Analogously, `End Epoch` must
be set to or compared against the future-bounded slot index, which prevents faking the future. A future-bounded slot
index is always at most equal to the slot to which the block belongs, based on its `Issuing Time`, since the newest,
valid commitment that can be picked is `Min Committable Age` slots old.

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
